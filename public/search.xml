<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Dagger2学习</title>
      <link href="/2019/07/14/Android-Dagger%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/07/14/Android-Dagger%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="What"><a href="#What" class="headerlink" title="What"></a>What</h2><p>关于<code>IOC（控制反转）</code>和<code>DI（依赖注入）</code>，<code>DI</code>只是<code>IOC</code>的实现的一种方式，另一种是<code>依赖查找</code>，详细见 <a href="[https://zh.wikipedia.org/zh-cn/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC](https://zh.wikipedia.org/zh-cn/控制反转)">控制反转维基百科</a></p><p>完全静态的依赖注入框架。依赖注入的概念真的是到哪都有，以前学Spring的就天天看它，到了android还是跑不了，现在的dagger是以半静态注入的形式，说白了，通过注解处理器分析注解，生成java代码，将对象池和需要对象的地方连接起来，其实就和自己创键差不多，我就简单总结下怎么用吧(里面的概念我也挺晕乎的，注解处理器那里我也是挺头疼的。)</p><p>官网：  <a href="https://dagger.dev/users-guide" target="_blank" rel="noopener">Dagger users-guide</a> （果然还是还是官方文档讲的好呃呃）</p><h2 id="How"><a href="#How" class="headerlink" title="How"></a>How</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">'com.google.dagger:dagger:2.20'</span></span><br><span class="line">annotationProcessor <span class="string">'com.google.dagger:dagger-compiler:2.20'</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="最简单的例子"><a href="#最简单的例子" class="headerlink" title="最简单的例子"></a>最简单的例子</h3><p>首先需求是我需要一个对象。使用<code>@Inject</code>注解构造方法表示构造器注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Apple</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写注入器，用<code>@Component</code>注解的一个接口即可，里面有一个<code>inject</code>方法，参数类型是你要注入的地方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AppleComponet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(TestActivity activity)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注入，构建项目，然后生成许多类，我们只用在意形如DaggerAppleComponet这样以Dagger开头的生成器就行了。</p><p>同样用<code>@Inject</code>注解我要注入的对象，<code>DaggerAppleComponet.builder().build().inject(this);</code>这样就完成注入了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Inject</span> Apple mApple;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        DaggerAppleComponet.builder().build().inject(<span class="keyword">this</span>);</span><br><span class="line">        Log.d(<span class="string">"TestActivity"</span>, <span class="string">"onCreate: "</span> + mApple);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在依赖注入里面是会自动解决依赖的。比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Inject</span> A(B)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">   <span class="meta">@Inject</span> B()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时A依赖B，在注入A的时候会自动取注入B。只需要二者存在注入形式就行。</p><h3 id="使用module注入"><a href="#使用module注入" class="headerlink" title="使用module注入"></a>使用module注入</h3><p>构造器注入挺简单方便，但是不是所有的对象都能够构造器注入，比如第三方类实例，你就无法添加注解，还有比如Retrofit中动态生成的接口API对象，也不能。所以<code>注入module</code>登场，在这里面用于产出对象。</p><p>使用<code>@Module</code>注解类名，就表示这是一个module，可以有构造函数传入我们需要的依赖，比如<code>Context</code>。</p><p>使用<code>@Provides</code>修饰方法，命名为：<code>providesXX</code>，就表示产出对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonModule</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CommonModule</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        mContext = context;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function">TextView <span class="title">providesTextView</span><span class="params">(Context context, Cat cat)</span></span>&#123;</span><br><span class="line">        TextView textView = <span class="keyword">new</span> TextView(context);</span><br><span class="line">        textView.setText(cat.sayHello());</span><br><span class="line">        <span class="keyword">return</span> textView;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function">Context <span class="title">providesContextContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mContext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function">Cat <span class="title">providesCat</span><span class="params">(Hello hello)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Cat(hello);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function">Hello <span class="title">providesHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样需要声明注入器</p><p>和上面不同的是需要，写入Module类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(modules = &#123;CommonModule.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloCompont</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(TestDagger2Activity activity)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDagger2Activity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = TestDagger2Activity.class.getSimpleName();</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    TextView mTextView;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        DaggerHelloCompont.builder().commonModule(<span class="keyword">new</span> CommonModule(<span class="keyword">this</span>)).build().inject(<span class="keyword">this</span>);</span><br><span class="line">        setContentView(mTextView);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这只是另一种注入方式而已。</p><h3 id="注解说明"><a href="#注解说明" class="headerlink" title="注解说明"></a>注解说明</h3><h4 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h4><p>注解接口，标注为注入器，构建后会生成前缀Dagger的类，用于注入</p><h4 id="Module"><a href="#Module" class="headerlink" title="@Module"></a>@Module</h4><p>注解类，标注为注入模型，用于生成模型注入对象</p><h4 id="Inject"><a href="#Inject" class="headerlink" title="@Inject"></a>@Inject</h4><ul><li><p>注解构造方法表示，构造器注入</p></li><li><p>注解变量，表示被注入的引用，访问限定不能为private</p></li><li><p><strong>不可以修饰接口，即使是通过Provides产出的接口类型，也只是能够通过方法依赖传递，并不能注入到标注了@Inject的引用上去</strong></p><p>因为我遇到了过这个问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//大概举例</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">//通过Retrofit生成A</span></span><br><span class="line"><span class="function">A <span class="title">providesA</span><span class="params">(Retrofit retrofit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> retrofit.create(A.class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此时我们是无法通过@Inject获得A的</span></span><br><span class="line"><span class="meta">@Inject</span> A;<span class="comment">//无效</span></span><br><span class="line"><span class="comment">//包装下</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataModel</span> </span>&#123;</span><br><span class="line">    A mA;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    DataModel(A a) &#123;</span><br><span class="line">        mA = a;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> A <span class="title">getA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时我就可以这样</span></span><br><span class="line"><span class="meta">@Inject</span> DataModel mModel;</span><br><span class="line">A a = mModel.getA();</span><br></pre></td></tr></table></figure></li></ul><h4 id="Provides"><a href="#Provides" class="headerlink" title="@Provides"></a>@Provides</h4><p>在模型中，注解方法，一般规范以provides前缀开头方法，表示产出某对象</p><h4 id="Named"><a href="#Named" class="headerlink" title="@Named"></a>@Named</h4><p>可能存在同种类型的对象，需要通过命名区分，其实@Named也是通过@Qualifier定义的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Named</span>(<span class="string">"one"</span>)</span><br><span class="line"><span class="meta">@Provides</span></span><br><span class="line"><span class="function">Hello <span class="title">providesHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Hello();<span class="comment">//产出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Named</span>(<span class="string">"tow"</span>)</span><br><span class="line"><span class="meta">@Provides</span></span><br><span class="line"><span class="function">Hello <span class="title">providesHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Hello();<span class="comment">//产出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法可以是静态的，这就意味着Module不需要实例化传入compoent</p><h4 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h4><p>修饰注解，来标注具体那个对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Qualifier</span></span><br><span class="line"><span class="meta">@interface</span> A&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Qualifier</span></span><br><span class="line"><span class="meta">@interface</span> B&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@A</span></span><br><span class="line"><span class="meta">@Provides</span></span><br><span class="line"><span class="function">Hello <span class="title">providesHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Hello();<span class="comment">//产出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@B</span></span><br><span class="line"><span class="meta">@Provides</span></span><br><span class="line"><span class="function">Hello <span class="title">providesHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Hello();<span class="comment">//产出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Scope"><a href="#Scope" class="headerlink" title="@Scope"></a>@Scope</h4><p>修饰注解，用于生成标注注入对象的作用域单例的注解</p><p>例如以下就生成了一个@PerFragment的作用域注解，在这个作用域内，@PerFragment修饰的对象为单例，即局部单例，亦或者搭配限定符使用，产出不同限定的单例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> PerFragment &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将该注解用于修饰注入器，和产出对象的地方</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PerFragment</span></span><br><span class="line"><span class="meta">@Subcomponent</span>(modules = HomeFragmentModule.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HomeFragmentComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(HomeFragment homeFragment)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeArticlesFragmentModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PerFragment</span></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function">List&lt;Article&gt; <span class="title">providesArticles</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Singleton"><a href="#Singleton" class="headerlink" title="@Singleton"></a>@Singleton</h4><p>这个注解也是官方通过@Scope实现的，直接表明单例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Singleton &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><p>默认会在调用前就将对象注入到引用，使用以下形式可以懒加载，不会立马注入对象，只有在lazy.get()时才会去获得对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inject</span></span><br><span class="line">Lazy&lt;Object&gt; object;</span><br></pre></td></tr></table></figure><h3 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h3><p>有时候许多要不断注入同一类型的对象比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inject</span> A a1;</span><br><span class="line"><span class="meta">@Inject</span> A a2;</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">List&lt;A&gt; list;</span><br><span class="line"></span><br><span class="line">list.add(a1);</span><br><span class="line">list.add(a2);</span><br></pre></td></tr></table></figure><p>像这样需要不止一个对象，这时候就需要使用Provider了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inject</span> Provider&lt;Filter&gt; filterProvider;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">brew</span><span class="params">(<span class="keyword">int</span> numberOfPots)</span> </span>&#123;</span><br><span class="line"> ...</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; numberOfPots; p++) &#123;</span><br><span class="line">     maker.addFilter(filterProvider.get()); <span class="comment">//每次都会去获得新的对象</span></span><br><span class="line">     maker.addCoffee(...);</span><br><span class="line">     maker.percolate();</span><br><span class="line">     ...</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="Componet注入器之间关系"><a href="#Componet注入器之间关系" class="headerlink" title="Componet注入器之间关系"></a>Componet注入器之间关系</h3><p>之前的简单场景都是仅限于当前注入环境，倘若我们又这个需求，比如Fragment需要用到Activity的对象，亦或者全局环境需要用到全局注入对象，这个时候前面的基础操作就不管用了。因为它只关心注入的当前环境T<code>inject(T)</code>，离开了这个环境你也就无法获得注入对象了。</p><p>所有我们就得需要以下几个概念</p><h4 id="注入器之间相互依赖"><a href="#注入器之间相互依赖" class="headerlink" title="注入器之间相互依赖"></a>注入器之间相互依赖</h4><p>依赖就是，A的工作需要B的帮忙，也就能名正言顺的获得B注入器的注入对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A(B b);</span><br></pre></td></tr></table></figure><p>在注入器我们可这样声明依赖的注入器，通过在@Componet添加依赖的注入器，可以添加很多的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PerFragment</span></span><br><span class="line"><span class="meta">@Component</span>(modules = LoginFragmentModule.class, dependencies = AppComponent.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoginFragmentComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(LoginFragment fragment)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注入过程，既然是已依赖的方式注入，就得要拿到依赖的注入器对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DaggerLoginFragmentComponent.builder()</span><br><span class="line">    .appComponent(App.getAppComponent())</span><br><span class="line">    .build()</span><br><span class="line">    .inject(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>如果你想获得依赖的对象，必须要在注入器暴露接口，才能打开一个通往注入器依赖的入口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="meta">@Component</span>(modules = AppModule.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AppComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(App app)</span></span>;</span><br><span class="line">    <span class="function">App <span class="title">getApp</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">DataModel <span class="title">getDataModel</span><span class="params">()</span></span>;<span class="comment">//暴露</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就能名正言顺的使用依赖注入器的依赖对象了。</p><h4 id="注入器继承"><a href="#注入器继承" class="headerlink" title="注入器继承"></a>注入器继承</h4><p>第二种方式，比如一个Activity有很多的Fragment，这个时候使用继承关系来获取注入器内容更好，不需要暴露依赖对象接口</p><p>看父注入器声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PerActivity</span></span><br><span class="line"><span class="meta">@Component</span>(dependencies = AppComponent.class, modules = MainActivityModule.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MainActivityComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(MainActivity mainActivity)</span></span>;</span><br><span class="line">    <span class="function">HomeFragmentComponent <span class="title">getHomeFragmentComponent</span><span class="params">(HomeFragmentModule homeFragmentModule)</span></span>;<span class="comment">//提供子注入器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子注入器声明，使用@SubComponet表明这个子注入器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PerFragment</span></span><br><span class="line"><span class="meta">@Subcomponent</span>(modules = HomeFragmentModule.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HomeFragmentComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(HomeFragment homeFragment)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">((MainActivity) mActivity)</span><br><span class="line">.getComponent()<span class="comment">//通过Activity获得父注入器</span></span><br><span class="line">    .getHomeFragmentComponent(<span class="keyword">new</span> HomeFragmentModule())<span class="comment">//通过父注入器获得子注入器并且传入Modele</span></span><br><span class="line">    .inject(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>通过继承的方式将应用对象图谱分割成不同的部分，子注入器可以依赖祖先注入器的绑定对象，反之父注入器不能依赖子注入器绑定对象，同级注入器也无法依赖。换句话说父注入器的对象图是子注入器的对象图的子对象图。</p><p>呃呃好像官方文档使用Builder另一种方式写的SubComponent</p><p>这种基于Builder写起来真麻烦啊</p><h4 id="在Component提供依赖"><a href="#在Component提供依赖" class="headerlink" title="在Component提供依赖"></a>在Component提供依赖</h4><p>这样主动暴露依赖，其实去工厂里拿</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Componet</span><br><span class="line">public interface AComponet&#123;</span><br><span class="line">Apple getApple();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Multibindings"><a href="#Multibindings" class="headerlink" title="Multibindings"></a>Multibindings</h3><p>允许将绑定对象进集合</p><h4 id="绑定进Set"><a href="#绑定进Set" class="headerlink" title="绑定进Set"></a>绑定进Set</h4><p>使用<code>@IntoSet</code>表示将绑定对象输入set</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyModuleA</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Provides</span> <span class="meta">@IntoSet</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> String <span class="title">provideOneString</span><span class="params">(DepA depA, DepB depB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"ABC"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>@ElementsIntoSet</code>表示将一个set输送进set</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyModuleB</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Provides</span> <span class="meta">@ElementsIntoSet</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> Set&lt;String&gt; <span class="title">provideSomeStrings</span><span class="params">(DepA depA, DepB depB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HashSet&lt;String&gt;(Arrays.asList(<span class="string">"DEF"</span>, <span class="string">"GHI"</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绑定好的set可以解决set的依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Inject</span> Bar(Set&lt;String&gt; strings) &#123;</span><br><span class="line">    <span class="keyword">assert</span> strings.contains(<span class="string">"ABC"</span>);</span><br><span class="line">    <span class="keyword">assert</span> strings.contains(<span class="string">"DEF"</span>);</span><br><span class="line">    <span class="keyword">assert</span> strings.contains(<span class="string">"GHI"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者这样使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(modules = &#123;MyModuleA.class, MyModuleB.class&#125;)</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyComponent</span> </span>&#123;</span><br><span class="line">  <span class="function">Set&lt;String&gt; <span class="title">strings</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span> <span class="function"><span class="keyword">void</span> <span class="title">testMyComponent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  MyComponent myComponent = DaggerMyComponent.create();</span><br><span class="line">  assertThat(myComponent.strings()).containsExactly(<span class="string">"ABC"</span>, <span class="string">"DEF"</span>, <span class="string">"GHI"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以结合 <code>Set&lt;Foo&gt;</code>以及 <code>Provider&lt;Set&lt;Foo&gt;&gt;</code> or <code>Lazy&lt;Set&lt;Foo&gt;&gt;</code>这样的形式，但是不能<code>Set&lt;Provider&lt;Foo&gt;&gt;</code></p><p>同样可以结合<code>@Qualifier</code>来限定</p><h4 id="绑定进Map"><a href="#绑定进Map" class="headerlink" title="绑定进Map"></a>绑定进Map</h4><p>还可以绑定进map，好吧本来我想看到上面就写的。下面其实就是看到官方文档上的23333</p><h5 id="普通使用"><a href="#普通使用" class="headerlink" title="普通使用"></a>普通使用</h5><p>使用<code>@IntoMap</code>注解进入map的对象，使用<code>@StringKey</code>表示String类型的key，使用<code>@ClassKey</code>表示Class类型的key</p><p>之后我们就可获得<code>Map&lt;String, Long&gt;</code>的Map</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyModule</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Provides</span> <span class="meta">@IntoMap</span></span><br><span class="line">  <span class="meta">@StringKey</span>(<span class="string">"foo"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Long <span class="title">provideFooValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100L</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Provides</span> <span class="meta">@IntoMap</span></span><br><span class="line">  <span class="meta">@ClassKey</span>(Thing.class)</span><br><span class="line">  <span class="function"><span class="keyword">static</span> String <span class="title">provideThingValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"value for Thing"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(modules = MyModule.class)</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyComponent</span> </span>&#123;</span><br><span class="line">  <span class="function">Map&lt;String, Long&gt; <span class="title">longsByString</span><span class="params">()</span></span>;</span><br><span class="line">  Map&lt;Class&lt;?&gt;, String&gt; stringsByClass();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span> <span class="function"><span class="keyword">void</span> <span class="title">testMyComponent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  MyComponent myComponent = DaggerMyComponent.create();</span><br><span class="line">  assertThat(myComponent.longsByString().get(<span class="string">"foo"</span>)).isEqualTo(<span class="number">100L</span>);</span><br><span class="line">  assertThat(myComponent.stringsByClass().get(Thing.class))</span><br><span class="line">      .isEqualTo(<span class="string">"value for Thing"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="枚举和带泛型的KEY"><a href="#枚举和带泛型的KEY" class="headerlink" title="枚举和带泛型的KEY"></a>枚举和带泛型的KEY</h5><p>通过<code>@MapKey</code>来自定以枚举key，以及符合泛型通配的key</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> MyEnum &#123;</span><br><span class="line">  ABC, DEF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MapKey</span></span><br><span class="line"><span class="meta">@interface</span> MyEnumKey &#123;</span><br><span class="line">  <span class="function">MyEnum <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MapKey</span></span><br><span class="line"><span class="meta">@interface</span> MyNumberClassKey &#123;</span><br><span class="line">  Class&lt;? extends Number&gt; value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyModule</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Provides</span> <span class="meta">@IntoMap</span></span><br><span class="line">  <span class="meta">@MyEnumKey</span>(MyEnum.ABC)</span><br><span class="line">  <span class="function"><span class="keyword">static</span> String <span class="title">provideABCValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"value for ABC"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Provides</span> <span class="meta">@IntoMap</span></span><br><span class="line">  <span class="meta">@MyNumberClassKey</span>(BigDecimal.class)</span><br><span class="line">  <span class="function"><span class="keyword">static</span> String <span class="title">provideBigDecimalValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"value for BigDecimal"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(modules = MyModule.class)</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyComponent</span> </span>&#123;</span><br><span class="line">  <span class="function">Map&lt;MyEnum, String&gt; <span class="title">myEnumStringMap</span><span class="params">()</span></span>;</span><br><span class="line">  Map&lt;Class&lt;? extends Number&gt;, String&gt; stringsByNumberClass();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span> <span class="function"><span class="keyword">void</span> <span class="title">testMyComponent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  MyComponent myComponent = DaggerMyComponent.create();</span><br><span class="line">  assertThat(myComponent.myEnumStringMap().get(MyEnum.ABC)).isEqualTo(<span class="string">"value for ABC"</span>);</span><br><span class="line">  assertThat(myComponent.stringsByNumberClass.get(BigDecimal.class))</span><br><span class="line">      .isEqualTo(<span class="string">"value for BigDecimal"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="更加复杂的KEY"><a href="#更加复杂的KEY" class="headerlink" title="更加复杂的KEY"></a>更加复杂的KEY</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MapKey</span>(unwrapValue = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@interface</span> MyKey &#123;</span><br><span class="line">  <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">  Class&lt;?&gt; implementingClass();</span><br><span class="line">  <span class="keyword">int</span>[] thresholds();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyModule</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Provides</span> <span class="meta">@IntoMap</span></span><br><span class="line">  <span class="meta">@MyKey</span>(name = <span class="string">"abc"</span>, implementingClass = Abc.class, thresholds = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>&#125;)</span><br><span class="line">  <span class="function"><span class="keyword">static</span> String <span class="title">provideAbc1510Value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"foo"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(modules = MyModule.class)</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyComponent</span> </span>&#123;</span><br><span class="line">  <span class="function">Map&lt;MyKey, String&gt; <span class="title">myKeyStringMap</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于复杂的Key来说，编译时是无法具体确认的，考虑使用<code>Set&lt;Map.KeyEntry&gt;</code>来完成同样可以达到map效果</p><p>上面的只是讲了个大概目前用到，其实还有关于子注入器更多的知识和Producers的内容，以后再补充吧。</p><h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><p>参考</p><ul><li><a href="https://www.jianshu.com/p/26d9f99ea3bb" target="_blank" rel="noopener">https://www.jianshu.com/p/26d9f99ea3bb</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Retrofit学习</title>
      <link href="/2019/07/14/Android-Retrofit%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/07/14/Android-Retrofit%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="what"><a href="#what" class="headerlink" title="what"></a>what</h2><p>网络请求框架，底层是使用OkHttp请求实现的。通过动态代理来创键创键解耦的请求，具体的请求交给OkHttp。同时支持Rxjava，以及各种格式的转换。官方文档地址：<a href="https://square.github.io/retrofit/" target="_blank" rel="noopener">Retrofit</a></p><h2 id="how"><a href="#how" class="headerlink" title="how"></a>how</h2><h3 id="定义请求API"><a href="#定义请求API" class="headerlink" title="定义请求API"></a>定义请求API</h3><p>创键接口，以及请求定义方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> okhttp3.ResponseBody;</span><br><span class="line"><span class="keyword">import</span> retrofit2.Call;</span><br><span class="line"><span class="keyword">import</span> retrofit2.http.GET;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestApi</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"article/list/0/json"</span>)</span><br><span class="line">    <span class="function">Call&lt;ResponseBody&gt; <span class="title">getArticle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder().baseUrl(url).build();</span><br><span class="line">TestApi testApi = retrofit.create(TestApi.class);</span><br><span class="line">Response&lt;ResponseBody&gt; response = testApi.getArticle().execute();</span><br><span class="line">System.out.println(response.code());</span><br><span class="line">System.out.println(response.isSuccessful());</span><br><span class="line">System.out.println(response.body().string());</span><br><span class="line"></span><br><span class="line"><span class="comment">//ouput</span></span><br><span class="line"><span class="number">200</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line">数据</span><br></pre></td></tr></table></figure><h3 id="请求方法声明"><a href="#请求方法声明" class="headerlink" title="请求方法声明"></a>请求方法声明</h3><h4 id="GET"><a href="#GET" class="headerlink" title="@GET"></a>@GET</h4><p>get请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GET</span>(<span class="string">"article/list/0/json"</span>)</span><br><span class="line"><span class="function">Call&lt;ResponseBody&gt; <span class="title">getArticle</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="POST"><a href="#POST" class="headerlink" title="@POST"></a>@POST</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@POST</span>(<span class="string">"login"</span>)</span><br><span class="line"><span class="function">Call&lt;ResponseBody&gt; <span class="title">login</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="其它的请求方式"><a href="#其它的请求方式" class="headerlink" title="其它的请求方式"></a>其它的请求方式</h4><p> <code>PUT</code>, <code>DELETE</code>, and <code>HEAD</code></p><h3 id="Url构建"><a href="#Url构建" class="headerlink" title="Url构建"></a>Url构建</h3><h4 id="Path"><a href="#Path" class="headerlink" title="@Path"></a>@Path</h4><p>当我们需要对路径进行动态参数，比如`/page/1/json，这种带参路径，好像和springMVC的挺像，这样就会替换了</p><p><strong>如果路径种出现了多个参数，映射形参一定要按照顺序写，不然会出问题</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GET</span>(<span class="string">"article/list/&#123;pageNum&#125;/json"</span>)</span><br><span class="line"><span class="function">Call&lt;ResponseBody&gt; <span class="title">getArticle</span><span class="params">(@Path(<span class="string">"pageNum"</span>)</span> <span class="keyword">int</span> pageNum)</span>;</span><br><span class="line"><span class="comment">//article/list/0/json</span></span><br></pre></td></tr></table></figure><h4 id="Query"><a href="#Query" class="headerlink" title="@Query"></a>@Query</h4><p>url查询参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GET</span>(<span class="string">"article/list/0/json"</span>)</span><br><span class="line">Observable&lt;BaseResponse&lt;Articles&gt;&gt; getArticlesByCid(<span class="meta">@Query</span>(<span class="string">"cid"</span>) <span class="keyword">int</span> cid);</span><br><span class="line"></span><br><span class="line"><span class="comment">//article/list/0/json?cid=1</span></span><br></pre></td></tr></table></figure><p><strong>@Path和@Query共同出现时，映射形参一定要先path再query的写，不然真的会出问题呃呃</strong></p><h4 id="QueryMap"><a href="#QueryMap" class="headerlink" title="@QueryMap"></a>@QueryMap</h4><p>这个和@Query类似，传入map表示查询参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GET</span>(<span class="string">"group/&#123;id&#125;/users"</span>)</span><br><span class="line">Call&lt;List&lt;User&gt;&gt; groupList(<span class="meta">@Path</span>(<span class="string">"id"</span>) <span class="keyword">int</span> groupId, <span class="meta">@QueryMap</span> Map&lt;String, String&gt; options);</span><br></pre></td></tr></table></figure><h3 id="请求体构建"><a href="#请求体构建" class="headerlink" title="请求体构建"></a>请求体构建</h3><h4 id="Field和-FormUrlEncoded"><a href="#Field和-FormUrlEncoded" class="headerlink" title="@Field和@FormUrlEncoded"></a>@Field和@FormUrlEncoded</h4><p>post提交表单得这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@POST</span>(<span class="string">"user/login"</span>)</span><br><span class="line"><span class="meta">@FormUrlEncoded</span></span><br><span class="line">Observable&lt;BaseResponse&lt;Login&gt;&gt; login(</span><br><span class="line">    <span class="meta">@Field</span>(<span class="string">"username"</span>) String userName,</span><br><span class="line">    <span class="meta">@Field</span>(<span class="string">"password"</span>) String password</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><h4 id="Body"><a href="#Body" class="headerlink" title="@Body"></a>@Body</h4><p>标注请求体</p><p>自定义RequestBody，参看OkHttp，这里不需要FormUrlEncoded</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@POST</span>(<span class="string">"xxxxxxx"</span>)   </span><br><span class="line"><span class="function">Call&lt;Object&gt; <span class="title">login</span><span class="params">( @Body RequestBody body)</span></span>;</span><br></pre></td></tr></table></figure><p>如果没有加入转化器的话就只能修饰RequestBody</p><p>请求体为json对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@POST</span>(<span class="string">"xxxxxxx"</span>)   </span><br><span class="line"><span class="function">Call&lt;Object&gt; <span class="title">login</span><span class="params">( @Body JSONObject parmas )</span></span>;</span><br></pre></td></tr></table></figure><h4 id="Multipart-和-Part"><a href="#Multipart-和-Part" class="headerlink" title="@Multipart 和 @Part"></a>@Multipart 和 @Part</h4><p>其实也是完全对应OkHttp的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Multipart</span></span><br><span class="line"><span class="meta">@PUT</span>(<span class="string">"user/photo"</span>)</span><br><span class="line"><span class="function">Call&lt;User&gt; <span class="title">updateUser</span><span class="params">(@Part(<span class="string">"photo"</span>)</span> RequestBody photo, @<span class="title">Part</span><span class="params">(<span class="string">"description"</span>)</span> RequestBody description)</span>;</span><br></pre></td></tr></table></figure><h3 id="请求头构建"><a href="#请求头构建" class="headerlink" title="请求头构建"></a>请求头构建</h3><h4 id="Headers-和-Headers-HeaderMap"><a href="#Headers-和-Headers-HeaderMap" class="headerlink" title="@Headers 和 @Headers @HeaderMap"></a>@Headers 和 @Headers @HeaderMap</h4><p>添加单个Header头</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Headers</span>(<span class="string">"Cache-Control: max-age=640000"</span>)</span><br><span class="line"><span class="meta">@GET</span>(<span class="string">"widget/list"</span>)</span><br><span class="line">Call&lt;List&lt;Widget&gt;&gt; widgetList();</span><br></pre></td></tr></table></figure><p>添加多个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Headers</span>(&#123;</span><br><span class="line">    <span class="string">"Accept: application/vnd.github.v3.full+json"</span>,</span><br><span class="line">    <span class="string">"User-Agent: Retrofit-Sample-App"</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="meta">@GET</span>(<span class="string">"users/&#123;username&#125;"</span>)</span><br><span class="line"><span class="function">Call&lt;User&gt; <span class="title">getUser</span><span class="params">(@Path(<span class="string">"username"</span>)</span> String username)</span>;</span><br></pre></td></tr></table></figure><p>动态赋值Header</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GET</span>(<span class="string">"user"</span>)</span><br><span class="line"><span class="function">Call&lt;User&gt; <span class="title">getUser</span><span class="params">(@Header(<span class="string">"Authorization"</span>)</span> String authorization)</span></span><br></pre></td></tr></table></figure><p>动态添加多个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GET</span>(<span class="string">"user"</span>)</span><br><span class="line"><span class="function">Call&lt;User&gt; <span class="title">getUser</span><span class="params">(@HeaderMap Map&lt;String, String&gt; headers)</span></span></span><br></pre></td></tr></table></figure><p>基本上一一对应着OkHttp，真好用啊</p><h3 id="转换器"><a href="#转换器" class="headerlink" title="转换器"></a>转换器</h3><p>默认Retrofit是响应构建是发出<code>RequestBody</code>和响应<code>ResponseBody</code>，如果需要进一步对响应进行转换处理就需要用到转换器了。</p><p>大概有这么几种把：（官网拷的）</p><ul><li><a href="https://github.com/google/gson" target="_blank" rel="noopener">Gson</a>: <code>com.squareup.retrofit2:converter-gson</code></li><li><a href="http://wiki.fasterxml.com/JacksonHome" target="_blank" rel="noopener">Jackson</a>: <code>com.squareup.retrofit2:converter-jackson</code></li><li><a href="https://github.com/square/moshi/" target="_blank" rel="noopener">Moshi</a>: <code>com.squareup.retrofit2:converter-moshi</code></li><li><a href="https://developers.google.com/protocol-buffers/" target="_blank" rel="noopener">Protobuf</a>: <code>com.squareup.retrofit2:converter-protobuf</code></li><li><a href="https://github.com/square/wire" target="_blank" rel="noopener">Wire</a>: <code>com.squareup.retrofit2:converter-wire</code></li><li><a href="http://simple.sourceforge.net/" target="_blank" rel="noopener">Simple XML</a>: <code>com.squareup.retrofit2:converter-simplexml</code></li><li>Scalars (primitives, boxed, and String): <code>com.squareup.retrofit2:converter-scalars</code></li></ul><h4 id="Gson"><a href="#Gson" class="headerlink" title="Gson"></a>Gson</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">    .baseUrl(<span class="string">"https://api.github.com"</span>)</span><br><span class="line">    .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">GitHubService service = retrofit.create(GitHubService.class);</span><br></pre></td></tr></table></figure><h3 id="call适配器"><a href="#call适配器" class="headerlink" title="call适配器"></a>call适配器</h3><h4 id="联动Rxjava"><a href="#联动Rxjava" class="headerlink" title="联动Rxjava"></a>联动Rxjava</h4><p>导入依赖</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">'com.squareup.retrofit2:converter-gson:2.5.0'</span></span><br><span class="line">implementation <span class="string">'com.squareup.retrofit2:adapter-rxjava2:2.5.0'</span></span><br></pre></td></tr></table></figure><p>添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Provides</span></span><br><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="function">Retrofit <span class="title">provideRetrofit</span><span class="params">(OkHttpClient client)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">        .baseUrl(Constant.BASE_URL)</span><br><span class="line">        .client(client)</span><br><span class="line">        .addConverterFactory(GsonConverterFactory.create())<span class="comment">//Gson</span></span><br><span class="line">        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())<span class="comment">//Rxjava</span></span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Gson和Rxajva结合后，接着我们请求API就可以这样写了</p><p>定义和响应对应的实体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseResponse</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> errorCode;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="keyword">private</span> String errorMsg;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getErrorCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> errorCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setErrorCode</span><span class="params">(<span class="keyword">int</span> errorCode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.errorCode = errorCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getErrorMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setErrorMsg</span><span class="params">(String errorMsg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.errorMsg = errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"BaseResponse&#123;"</span> + <span class="string">"errorCode="</span> + errorCode + <span class="string">", data="</span> + data + <span class="string">", errorMsg='"</span> + errorMsg + <span class="string">'\''</span> + <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HomeApis</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"article/list/&#123;pageNum&#125;/json"</span>)</span><br><span class="line">    Observable&lt;BaseResponse&lt;Articles&gt;&gt; getArticles(<span class="meta">@Path</span>(<span class="string">"pageNum"</span>) <span class="keyword">int</span> pageNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送请求处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">addRxSubscribe( mModel.getArticles(pageNum)</span><br><span class="line">               .compose(RxUtil.rxSchedulerhelper())</span><br><span class="line">               .compose(RxUtil.handleResult())</span><br><span class="line">               .subscribeWith(<span class="keyword">new</span> BaseObserver&lt;Articles&gt;(getView()) &#123;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Articles articles)</span> </span>&#123;</span><br><span class="line">                       <span class="keyword">super</span>.onNext(articles);</span><br><span class="line">                       getView().showArticles(articles.getDatas());</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;));</span><br></pre></td></tr></table></figure><p>顺带着我们可以将线程变换，以及初步的响应处理进行复用，使用Rxjava进行流处理就行，甚至我们可以再重写一个Observer等等(我也是看别人代码这样学的写的哈哈)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RxUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ObservableTransformer&lt;T, T&gt; <span class="title">rxSchedulerhelper</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> observable -&gt; observable.subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ObservableTransformer&lt;BaseResponse&lt;T&gt;,T&gt; handleResult() &#123;</span><br><span class="line">        <span class="keyword">return</span> upstream -&gt;</span><br><span class="line">            upstream.flatMap(baseResponse -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (baseResponse.getErrorCode() == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> createObservable(baseResponse.getData());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> Observable.error(<span class="keyword">new</span> ApiException(baseResponse.getErrorCode(), baseResponse.getErrorMsg()));</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">createObservable</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Observable.create(emitter -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                emitter.onNext(data);</span><br><span class="line">                emitter.onComplete();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                emitter.onError(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="why"><a href="#why" class="headerlink" title="why"></a>why</h2><p>这个大概的原理就是通过动态代理取生成api，读取注解，组装request，构建成真正的OkHttp的Call，继而调用。</p><p>创键API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">    .baseUrl(<span class="string">"https://api.github.com"</span>)</span><br><span class="line">    .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">    .build();</span><br><span class="line">GitHubService service = retrofit.create(GitHubService.class);</span><br></pre></td></tr></table></figure><p>上面的Builder模式就先不看了，直接从create开始</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class="line">  Utils.validateServiceInterface(service);<span class="comment">//校验是否是接口</span></span><br><span class="line">  <span class="keyword">if</span> (validateEagerly) &#123;</span><br><span class="line">    eagerlyValidateMethods(service);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//动态代理</span></span><br><span class="line">  <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">      <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Object[] emptyArgs = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">          <span class="comment">// If the method is a method from Object then defer to normal invocation.</span></span><br><span class="line">          <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;<span class="comment">//肯定不等</span></span><br><span class="line">            <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (platform.isDefaultMethod(method)) &#123;<span class="comment">//默认就返回fasle</span></span><br><span class="line">            <span class="keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> loadServiceMethod(method).invoke(args != <span class="keyword">null</span> ? args : emptyArgs);<span class="comment">//真正调用这里</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态代理返回的对象，实际调用的调用是根据具体的methdo去构建的ServiceMethod.invoke方法。</p><p>先看下<code>loadServiceMethod(method)</code>吧，首先去map查询，没查询到就解析构建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ServiceMethod&lt;?&gt; loadServiceMethod(Method method) &#123;</span><br><span class="line">  ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);<span class="comment">//从缓存map拿去</span></span><br><span class="line">  <span class="keyword">if</span> (result != <span class="keyword">null</span>) <span class="keyword">return</span> result;<span class="comment">//拿到返回</span></span><br><span class="line">  <span class="keyword">synchronized</span> (serviceMethodCache) &#123;</span><br><span class="line">    result = serviceMethodCache.get(method);<span class="comment">//继续拿</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">      result = ServiceMethod.parseAnnotations(<span class="keyword">this</span>, method);<span class="comment">//解析注解构建</span></span><br><span class="line">      serviceMethodCache.put(method, result);<span class="comment">//入缓存map</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;<span class="comment">//返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着到<code>ServiceMethod#parseAnnotations</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">ServiceMethod&lt;T&gt; <span class="title">parseAnnotations</span><span class="params">(Retrofit retrofit, Method method)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//解析注解并获得Request工厂</span></span><br><span class="line">    RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);</span><br><span class="line">    Type returnType = method.getGenericReturnType();</span><br><span class="line">    <span class="keyword">if</span> (Utils.hasUnresolvableType(returnType)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> methodError(method,</span><br><span class="line">          <span class="string">"Method return type must not include a type variable or wildcard: %s"</span>, returnType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (returnType == <span class="keyword">void</span>.class) &#123;</span><br><span class="line">      <span class="keyword">throw</span> methodError(method, <span class="string">"Service methods cannot return void."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>接着走向RequestFactory#parseAnnotations去解析注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> RequestFactory <span class="title">parseAnnotations</span><span class="params">(Retrofit retrofit, Method method)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Builder(retrofit, method).build();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>直接看build方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RequestFactory <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (Annotation annotation : methodAnnotations) &#123;</span><br><span class="line">    parseMethodAnnotation(annotation);<span class="comment">//遍历每个注解，解析</span></span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">//。。。省略</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RequestFactory(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>parseMethodAnnotation</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseMethodAnnotation</span><span class="params">(Annotation annotation)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> DELETE) &#123;</span><br><span class="line">     parseHttpMethodAndPath(<span class="string">"DELETE"</span>, ((DELETE) annotation).value(), <span class="keyword">false</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> GET) &#123;</span><br><span class="line">     parseHttpMethodAndPath(<span class="string">"GET"</span>, ((GET) annotation).value(), <span class="keyword">false</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> HEAD) &#123;</span><br><span class="line">     parseHttpMethodAndPath(<span class="string">"HEAD"</span>, ((HEAD) annotation).value(), <span class="keyword">false</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> PATCH) &#123;</span><br><span class="line">     parseHttpMethodAndPath(<span class="string">"PATCH"</span>, ((PATCH) annotation).value(), <span class="keyword">true</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> POST) &#123;</span><br><span class="line">     parseHttpMethodAndPath(<span class="string">"POST"</span>, ((POST) annotation).value(), <span class="keyword">true</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> PUT) &#123;</span><br><span class="line">     parseHttpMethodAndPath(<span class="string">"PUT"</span>, ((PUT) annotation).value(), <span class="keyword">true</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> OPTIONS) &#123;</span><br><span class="line">     parseHttpMethodAndPath(<span class="string">"OPTIONS"</span>, ((OPTIONS) annotation).value(), <span class="keyword">false</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> HTTP) &#123;</span><br><span class="line">     HTTP http = (HTTP) annotation;</span><br><span class="line">     parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> retrofit2.http.Headers) &#123;</span><br><span class="line">     String[] headersToParse = ((retrofit2.http.Headers) annotation).value();</span><br><span class="line">     <span class="keyword">if</span> (headersToParse.length == <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">throw</span> methodError(method, <span class="string">"@Headers annotation is empty."</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     headers = parseHeaders(headersToParse);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> Multipart) &#123;</span><br><span class="line">     <span class="keyword">if</span> (isFormEncoded) &#123;</span><br><span class="line">       <span class="keyword">throw</span> methodError(method, <span class="string">"Only one encoding annotation is allowed."</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     isMultipart = <span class="keyword">true</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> FormUrlEncoded) &#123;</span><br><span class="line">     <span class="keyword">if</span> (isMultipart) &#123;</span><br><span class="line">       <span class="keyword">throw</span> methodError(method, <span class="string">"Only one encoding annotation is allowed."</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     isFormEncoded = <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在这里就很明显，根据不同的注解进行解析。反正都是去获得注解的值啊生成，最终在invoke组建真正的call尽调用。</p><p>后面都是直接装配之前解析的东西了</p><p>最后看看<code>HttpServiceMethod#invoke</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function">ReturnT <span class="title">invoke</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> callAdapter.adapt(</span><br><span class="line">        <span class="keyword">new</span> OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里的话就会去返回<code>OkHttpCall</code>里面调用产生的原生的<code>OkHttp</code>的<code>Call</code>，外面包裹着<code>callAdapter</code>，这里是用于转换Call的，即又进行了一次适配，不过这次的对象是call，这个为啥要适配呢，默认的话我们返回的是<code>Call&lt;&gt;</code>这种样子的，但是我们可以给定Adapteri进行对Call进一步处理，比如RxJava适配器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Retrofit <span class="title">provideRetrofit</span><span class="params">(OkHttpClient client)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">                .baseUrl(Constant.BASE_URL)</span><br><span class="line">                .client(client)</span><br><span class="line">                .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">                .addCallAdapterFactory(RxJava2CallAdapterFactory.create())<span class="comment">//这个</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后我们就能产生<code>Observale&lt;&gt;</code>的东西了。</p><p>继续看OkHttpCall是个啥东西。它实现了Retrofi的Call，里面包裹着真正的OkHttp的Call。所以形式很明了了。</p><p>通过调Retorfit的Call的execute或者enqueue，去组建真正的Call然后调用到OkHttp了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response&lt;T&gt; <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    okhttp3.Call call;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already executed."</span>);</span><br><span class="line">      executed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (creationFailure != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (creationFailure <span class="keyword">instanceof</span> IOException) &#123;</span><br><span class="line">          <span class="keyword">throw</span> (IOException) creationFailure;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (creationFailure <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">          <span class="keyword">throw</span> (RuntimeException) creationFailure;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> (Error) creationFailure;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      call = rawCall;</span><br><span class="line">      <span class="keyword">if</span> (call == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          call = rawCall = createRawCall();<span class="comment">//组建真正的OkHttp的Call</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | RuntimeException | Error e) &#123;</span><br><span class="line">          throwIfFatal(e); <span class="comment">//  Do not assign a fatal error to creationFailure.</span></span><br><span class="line">          creationFailure = e;</span><br><span class="line">          <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (canceled) &#123;</span><br><span class="line">      call.cancel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> parseResponse(call.execute());<span class="comment">//调用</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>原理呢就大概是这样。适配器和转换器也很明了</p><p>Gson相应体转换器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GsonResponseBodyConverter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">ResponseBody</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Gson gson;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> TypeAdapter&lt;T&gt; adapter;</span><br><span class="line"></span><br><span class="line">  GsonResponseBodyConverter(Gson gson, TypeAdapter&lt;T&gt; adapter) &#123;</span><br><span class="line">    <span class="keyword">this</span>.gson = gson;</span><br><span class="line">    <span class="keyword">this</span>.adapter = adapter;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> T <span class="title">convert</span><span class="params">(ResponseBody value)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    JsonReader jsonReader = gson.newJsonReader(value.charStream());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      T result = adapter.read(jsonReader);</span><br><span class="line">      <span class="keyword">if</span> (jsonReader.peek() != JsonToken.END_DOCUMENT) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> JsonIOException(<span class="string">"JSON document was not fully consumed."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      value.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RxJava Call适配器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RxJava2CallAdapter</span>&lt;<span class="title">R</span>&gt; <span class="keyword">implements</span> <span class="title">CallAdapter</span>&lt;<span class="title">R</span>, <span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Type responseType;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> Scheduler scheduler;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isAsync;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isResult;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isBody;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isFlowable;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isSingle;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isMaybe;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isCompletable;</span><br><span class="line"></span><br><span class="line">  RxJava2CallAdapter(Type responseType, <span class="meta">@Nullable</span> Scheduler scheduler, <span class="keyword">boolean</span> isAsync,</span><br><span class="line">      <span class="keyword">boolean</span> isResult, <span class="keyword">boolean</span> isBody, <span class="keyword">boolean</span> isFlowable, <span class="keyword">boolean</span> isSingle, <span class="keyword">boolean</span> isMaybe,</span><br><span class="line">      <span class="keyword">boolean</span> isCompletable) &#123;</span><br><span class="line">    <span class="keyword">this</span>.responseType = responseType;</span><br><span class="line">    <span class="keyword">this</span>.scheduler = scheduler;</span><br><span class="line">    <span class="keyword">this</span>.isAsync = isAsync;</span><br><span class="line">    <span class="keyword">this</span>.isResult = isResult;</span><br><span class="line">    <span class="keyword">this</span>.isBody = isBody;</span><br><span class="line">    <span class="keyword">this</span>.isFlowable = isFlowable;</span><br><span class="line">    <span class="keyword">this</span>.isSingle = isSingle;</span><br><span class="line">    <span class="keyword">this</span>.isMaybe = isMaybe;</span><br><span class="line">    <span class="keyword">this</span>.isCompletable = isCompletable;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Type <span class="title">responseType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> responseType;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Object <span class="title">adapt</span><span class="params">(Call&lt;R&gt; call)</span> </span>&#123;</span><br><span class="line">    Observable&lt;Response&lt;R&gt;&gt; responseObservable = isAsync</span><br><span class="line">        ? <span class="keyword">new</span> CallEnqueueObservable&lt;&gt;(call)</span><br><span class="line">        : <span class="keyword">new</span> CallExecuteObservable&lt;&gt;(call);</span><br><span class="line">    Observable&lt;?&gt; observable;</span><br><span class="line">    <span class="keyword">if</span> (isResult) &#123;</span><br><span class="line">      observable = <span class="keyword">new</span> ResultObservable&lt;&gt;(responseObservable);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isBody) &#123;</span><br><span class="line">      observable = <span class="keyword">new</span> BodyObservable&lt;&gt;(responseObservable);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      observable = responseObservable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (scheduler != <span class="keyword">null</span>) &#123;</span><br><span class="line">      observable = observable.subscribeOn(scheduler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isFlowable) &#123;</span><br><span class="line">      <span class="keyword">return</span> observable.toFlowable(BackpressureStrategy.LATEST);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isSingle) &#123;</span><br><span class="line">      <span class="keyword">return</span> observable.singleOrError();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isMaybe) &#123;</span><br><span class="line">      <span class="keyword">return</span> observable.singleElement();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isCompletable) &#123;</span><br><span class="line">      <span class="keyword">return</span> observable.ignoreElements();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(observable);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OkHttp学习</title>
      <link href="/2019/07/13/Android-OkHttp%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/07/13/Android-OkHttp%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="what"><a href="#what" class="headerlink" title="what"></a>what</h2><p>非常好用的请求库，还是附上<a href="https://square.github.io/okhttp/calls/" target="_blank" rel="noopener">官方文档</a></p><h2 id="how"><a href="#how" class="headerlink" title="how"></a>how</h2><p>正常步骤就是</p><ol><li>构建键Client<ol><li>添加header</li><li>拦截器</li><li>缓存</li><li>dns</li><li>代理</li><li>超时</li><li>监听事件</li></ol></li><li>构建请求Request<ol><li>url</li><li>header</li><li>请求方式</li><li>请求体</li></ol></li><li>发送请求Call</li><li>获得响应Response</li><li>处理响应</li></ol><a id="more"></a><h3 id="简单同步请求"><a href="#简单同步请求" class="headerlink" title="简单同步请求"></a>简单同步请求</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">    .url(<span class="string">"https://www.wanandroid.com/article/list/0/json"</span>)</span><br><span class="line">    .build();</span><br><span class="line">Call call = client.newCall(request);</span><br><span class="line"><span class="keyword">try</span>(Response response = call.execute()) &#123;</span><br><span class="line">    System.out.println(response.code());</span><br><span class="line">    System.out.println(response.message());</span><br><span class="line">    System.out.println(response.body().string());</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="number">200</span></span><br><span class="line">OK</span><br><span class="line">(相应体数据)</span><br></pre></td></tr></table></figure><h3 id="简单异步请求"><a href="#简单异步请求" class="headerlink" title="简单异步请求"></a>简单异步请求</h3><p>就是简单的将execute换成了enqueue传入回调，这是异步的哦，会切换线程。但是再Test测试方法中，需要让外面的线程等待下，不然是看不到的结果的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">  OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">        Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">                .url(<span class="string">"https://www.wanandroid.com/article/list/0/json"</span>)</span><br><span class="line">                .build();</span><br><span class="line">        Call call = client.newCall(request);</span><br><span class="line">        call.enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, IOException e)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"onFailure"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(&#123;<span class="string">"in "</span>+Thread.currentThread().getId());</span><br><span class="line">                System.out.println(response.code());</span><br><span class="line">                System.out.println(response.message());</span><br><span class="line">                System.out.println(response.body().string());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println( <span class="string">"out "</span>+ Thread.currentThread().getId());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">out <span class="number">1</span></span><br><span class="line">in <span class="number">13</span></span><br><span class="line"><span class="number">200</span></span><br><span class="line">OK</span><br><span class="line">(相应体数据)</span><br></pre></td></tr></table></figure><h3 id="发送Post请求"><a href="#发送Post请求" class="headerlink" title="发送Post请求"></a>发送Post请求</h3><p>如果不对Request进行设置，默认就是get请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RequestBody requestBody = <span class="keyword">new</span> Request.Builder().addHeader().build();</span><br><span class="line">Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">    .url(<span class="string">"https://www.wanandroid.com/login"</span>)</span><br><span class="line">    .post(requestBody)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>所以主要就是看RequestBody的构建了</p><h4 id="通过静态方法create进行构建"><a href="#通过静态方法create进行构建" class="headerlink" title="通过静态方法create进行构建"></a>通过静态方法create进行构建</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MediaType contentType = MediaType.parse(<span class="string">"text/x-markdown; charset=utf-8"</span>);</span><br><span class="line">RequestBody requestBody = RequestBody.create(contentType, <span class="string">"hello"</span>);</span><br></pre></td></tr></table></figure><p>大概有这么几种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create(<span class="meta">@Nullable</span> MediaType contentType, String content);<span class="comment">//字符串</span></span><br><span class="line">create(<span class="keyword">final</span> <span class="meta">@Nullable</span> MediaType contentType, <span class="keyword">final</span> ByteString content);</span><br><span class="line">create(<span class="keyword">final</span> <span class="meta">@Nullable</span> MediaType contentType, <span class="keyword">final</span> <span class="keyword">byte</span>[] content);<span class="comment">//字节数组</span></span><br><span class="line">create(<span class="keyword">final</span> <span class="meta">@Nullable</span> MediaType contentType, <span class="keyword">final</span> <span class="keyword">byte</span>[] content,<span class="keyword">final</span> <span class="keyword">int</span> offset, <span class="keyword">final</span> <span class="keyword">int</span> byteCount);</span><br><span class="line">create(<span class="keyword">final</span> <span class="meta">@Nullable</span> MediaType contentType, <span class="keyword">final</span> File file);<span class="comment">//文件</span></span><br></pre></td></tr></table></figure><p>所以也可以直接构建提交文件RequestBody的。</p><h4 id="实现RequestBody"><a href="#实现RequestBody" class="headerlink" title="实现RequestBody"></a>实现RequestBody</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RequestBody requestBody1 = <span class="keyword">new</span> RequestBody() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> MediaType <span class="title">contentType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeTo</span><span class="params">(BufferedSink sink)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><h4 id="发送普通表单"><a href="#发送普通表单" class="headerlink" title="发送普通表单"></a>发送普通表单</h4><p>RequestBody有一个实现类FormBody</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FormBody formBody = <span class="keyword">new</span> FormBody.Builder()</span><br><span class="line">               .add(<span class="string">"name"</span>, <span class="string">"zhangsan"</span>)</span><br><span class="line">               .add(<span class="string">"password"</span>, <span class="string">"123"</span>)</span><br><span class="line">               .build();</span><br></pre></td></tr></table></figure><h4 id="发送Multi表单"><a href="#发送Multi表单" class="headerlink" title="发送Multi表单"></a>发送Multi表单</h4><p>RequestBody另一个一个实现类MultipartBody，添加许多Part</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MultipartBody body = <span class="keyword">new</span> MultipartBody.Builder()</span><br><span class="line">               .addFormDataPart(<span class="string">"name"</span>, <span class="string">"zhangsan"</span>)</span><br><span class="line">               .addPart(MultipartBody.Part.create(<span class="keyword">null</span>))</span><br><span class="line">               .build();</span><br></pre></td></tr></table></figure><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>OkHttp的核心可以就在于拦截器，内部通过拦截器链式调用。监听，重写，重试call</p><p>看下官网给的例子，用于测试请求消耗的时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Interceptor.Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Request request = chain.request();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">    logger.info(String.format(<span class="string">"Sending request %s on %s%n%s"</span>,</span><br><span class="line">        request.url(), chain.connection(), request.headers()));</span><br><span class="line"></span><br><span class="line">    Response response = chain.proceed(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> t2 = System.nanoTime();</span><br><span class="line">    logger.info(String.format(<span class="string">"Received response for %s in %.1fms%n%s"</span>,</span><br><span class="line">        response.request().url(), (t2 - t1) / <span class="number">1e6</span>d, response.headers()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拦截分为两种：</p><ul><li><p>全局拦截器 通过<code>OkHttpClient.Builder#addInterceptor(Interceptor)</code>加入</p></li><li><p>网络拦截器 通过 <code>OkHttpClient.Builder#addNetworkInterceptor(Interceptor)</code>加入，真正发起网络请求调用</p></li></ul><p><img src="https://square.github.io/okhttp/images/interceptors@2x.png" alt></p><h4 id="Application-Interceptors"><a href="#Application-Interceptors" class="headerlink" title="Application Interceptors"></a>Application Interceptors</h4><p>全局拦截器：</p><ul><li>不用关心重连，重定向</li><li>总是调用一次，即使http响应是来自缓存。</li><li>可以观察原始请求意图，</li><li>允许短路，不调用<code>Chain.proceed()</code></li><li>允许多次调用<code>Chain.proceed()</code></li></ul><p>一般我们可比如：从本地取出并注入cookie，以及取出cookie持久化到本地</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取并设置cookie</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadCookiesInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReadCookiesInterceptor</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        mContext = context;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Request.Builder builder = chain.request().newBuilder();</span><br><span class="line">        SharedPreferences pref = PreferenceManager.getDefaultSharedPreferences(mContext);</span><br><span class="line">        HashSet&lt;String&gt; cookies = (HashSet&lt;String&gt;) pref.getStringSet(<span class="string">"cookies"</span>, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">        <span class="keyword">for</span> (String cookie : cookies) &#123;</span><br><span class="line">            builder.addHeader(<span class="string">"Cookie"</span>, cookie);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chain.proceed(builder.build());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 保存cookie</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaveCookiesInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SaveCookiesInterceptor</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        mContext = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Response originalResponse = chain.proceed(chain.request());</span><br><span class="line">        <span class="keyword">if</span> (!originalResponse.headers(<span class="string">"Set-Cookie"</span>).isEmpty()) &#123;</span><br><span class="line">            HashSet&lt;String&gt; cookies = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            cookies.addAll(originalResponse.headers(<span class="string">"Set-Cookie"</span>));</span><br><span class="line">            SharedPreferences.Editor editor = PreferenceManager.getDefaultSharedPreferences(mContext).edit();</span><br><span class="line">            editor.putStringSet(<span class="string">"cookies"</span>, cookies).apply();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> originalResponse;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Network-Interceptors"><a href="#Network-Interceptors" class="headerlink" title="Network Interceptors"></a>Network Interceptors</h4><ul><li>能够操纵中间响应，重定向，重试</li><li>缓存中响应不会调用</li><li>可观察网络传输数据</li><li>可以获得具体Connection进行操作，比如IP，TLS等</li></ul><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>首先看下各个类的概念</p><ul><li>OkHttpClient 客户端：维持了线程池，避免重复创键消耗资源，最好使用复用一个</li><li>Dispatcher 线程池抽象聚合：维护一个核心线程为了0，上限Int最大数，存活时间60s的线程池</li><li>Response 请求的封装：包含了请求url，请求头，请求体</li><li>Response 响应的封装：包含了状态码，响应头，响应体</li><li>Call 一次请求的具体对象，分为同步和异步</li><li>Interceptor 拦截器，拦截并处理，交下个拦截器</li><li>Chain 请求链，和拦截器一起构成责任链模式</li></ul><h3 id="构建Client"><a href="#构建Client" class="headerlink" title="构建Client"></a>构建Client</h3><p>Builder模式，构建client，有默认配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">OkHttpClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> Builder());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构建请求"><a href="#构建请求" class="headerlink" title="构建请求"></a>构建请求</h3><p>同样Builder模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Request(Builder builder) &#123;</span><br><span class="line">  <span class="keyword">this</span>.url = builder.url;</span><br><span class="line">  <span class="keyword">this</span>.method = builder.method;</span><br><span class="line">  <span class="keyword">this</span>.headers = builder.headers.build();</span><br><span class="line">  <span class="keyword">this</span>.body = builder.body;</span><br><span class="line">  <span class="keyword">this</span>.tags = Util.immutableMap(builder.tags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="newCall"><a href="#newCall" class="headerlink" title="newCall"></a>newCall</h3><p>实例出RealCall</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Call <span class="title">newCall</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RealCall.newRealCall(<span class="keyword">this</span>, request, <span class="keyword">false</span> <span class="comment">/* for web socket */</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> RealCall <span class="title">newRealCall</span><span class="params">(OkHttpClient client, Request originalRequest, <span class="keyword">boolean</span> forWebSocket)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Safely publish the Call instance to the EventListener.</span></span><br><span class="line">    RealCall call = <span class="keyword">new</span> RealCall(client, originalRequest, forWebSocket);</span><br><span class="line">    call.transmitter = <span class="keyword">new</span> Transmitter(client, call);</span><br><span class="line">    <span class="keyword">return</span> call;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="同步请求"><a href="#同步请求" class="headerlink" title="同步请求"></a>同步请求</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);<span class="comment">//执行过不能执行</span></span><br><span class="line">        executed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    transmitter.timeoutEnter();<span class="comment">//Okio超时，我还没搞懂233</span></span><br><span class="line">    transmitter.callStart();<span class="comment">//触发监听</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        client.dispatcher().executed(<span class="keyword">this</span>);<span class="comment">//RealCall入dispatcher的runningCall队列</span></span><br><span class="line">        <span class="keyword">return</span> getResponseWithInterceptorChain();<span class="comment">//进入</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        client.dispatcher().finished(<span class="keyword">this</span>);<span class="comment">//继续调用其它异步call</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>call入队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">executed</span><span class="params">(RealCall call)</span> </span>&#123;  runningSyncCalls.add(call);&#125;</span><br></pre></td></tr></table></figure><p>进行请求返回响应</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">  List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  interceptors.addAll(client.interceptors());<span class="comment">//全局拦截器</span></span><br><span class="line">  interceptors.add(<span class="keyword">new</span> RetryAndFollowUpInterceptor(client));<span class="comment">//请求重连拦截器</span></span><br><span class="line">  interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar()));<span class="comment">//构建网络请求</span></span><br><span class="line">  interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));<span class="comment">//cache</span></span><br><span class="line">  interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client));<span class="comment">//封装httpCodec</span></span><br><span class="line">  <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">    interceptors.addAll(client.networkInterceptors());</span><br><span class="line">  &#125;</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> CallServerInterceptor(forWebSocket));<span class="comment">//发送具体网络请求</span></span><br><span class="line"></span><br><span class="line">  Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(interceptors, transmitter, <span class="keyword">null</span>, <span class="number">0</span>,</span><br><span class="line">      originalRequest, <span class="keyword">this</span>, client.connectTimeoutMillis(),</span><br><span class="line">      client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> calledNoMoreExchanges = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Response response = chain.proceed(originalRequest);<span class="comment">//进入拦截器链</span></span><br><span class="line">    <span class="keyword">if</span> (transmitter.isCanceled()) &#123;</span><br><span class="line">      closeQuietly(response);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    calledNoMoreExchanges = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">throw</span> transmitter.noMoreExchanges(e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!calledNoMoreExchanges) &#123;</span><br><span class="line">      transmitter.noMoreExchanges(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入拦截器链</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request, Transmitter transmitter, @Nullable Exchange exchange)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= interceptors.size()) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line"></span><br><span class="line">    calls++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we already have a stream, confirm that the incoming request will use it.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.exchange != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.exchange.connection().supportsUrl(request.url())) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptors.get(index - <span class="number">1</span>)</span><br><span class="line">          + <span class="string">" must retain the same host and port"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we already have a stream, confirm that this is the only call to chain.proceed().</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.exchange != <span class="keyword">null</span> &amp;&amp; calls &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptors.get(index - <span class="number">1</span>)</span><br><span class="line">          + <span class="string">" must call proceed() exactly once"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call the next interceptor in the chain.重新构建链</span></span><br><span class="line">    RealInterceptorChain next = <span class="keyword">new</span> RealInterceptorChain(interceptors, transmitter, exchange,</span><br><span class="line">        index + <span class="number">1</span>, request, call, connectTimeout, readTimeout, writeTimeout);</span><br><span class="line">    Interceptor interceptor = interceptors.get(index);</span><br><span class="line">    Response response = interceptor.intercept(next);<span class="comment">//进入下一个拦截器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Confirm that the next interceptor made its required call to chain.proceed().</span></span><br><span class="line">    <span class="keyword">if</span> (exchange != <span class="keyword">null</span> &amp;&amp; index + <span class="number">1</span> &lt; interceptors.size() &amp;&amp; next.calls != <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptor</span><br><span class="line">          + <span class="string">" must call proceed() exactly once"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Confirm that the intercepted response isn't null.</span></span><br><span class="line">    <span class="keyword">if</span> (response == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"interceptor "</span> + interceptor + <span class="string">" returned null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (response.body() == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">          <span class="string">"interceptor "</span> + interceptor + <span class="string">" returned a response with no body"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>经历重重拦截器，通过Okio库进行对Socket进行流的读写，就完成一次请求。</p><h3 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h3><p>和同步请求不一样，具体是AsyncCall，将请求提交给线程池，触发回调。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</span><br><span class="line">        executed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    transmitter.callStart();<span class="comment">//触发事件监听</span></span><br><span class="line">    client.dispatcher().enqueue(<span class="keyword">new</span> AsyncCall(responseCallback));<span class="comment">//入队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        readyAsyncCalls.add(call);<span class="comment">//入队列</span></span><br><span class="line">        <span class="comment">// Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to</span></span><br><span class="line">        <span class="comment">// the same host.</span></span><br><span class="line">        <span class="keyword">if</span> (!call.get().forWebSocket) &#123;</span><br><span class="line">            AsyncCall existingCall = findExistingCallWithHost(call.host());</span><br><span class="line">            <span class="keyword">if</span> (existingCall != <span class="keyword">null</span>) call.reuseCallsPerHostFrom(existingCall);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    promoteAndExecute();<span class="comment">//执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">promoteAndExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> (!Thread.holdsLock(<span class="keyword">this</span>));</span><br><span class="line">    List&lt;AsyncCall&gt; executableCalls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span> isRunning;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;<span class="comment">//遍历准备队列</span></span><br><span class="line">        AsyncCall asyncCall = i.next();</span><br><span class="line">        <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">break</span>; <span class="comment">// Max capacity.运行队列满</span></span><br><span class="line">        <span class="comment">//请求Host的数量超出</span></span><br><span class="line">        <span class="keyword">if</span> (asyncCall.callsPerHost().get() &gt;= maxRequestsPerHost) <span class="keyword">continue</span>; <span class="comment">// Host max capacity.</span></span><br><span class="line">        i.remove();<span class="comment">//出准备队列</span></span><br><span class="line">        asyncCall.callsPerHost().incrementAndGet();</span><br><span class="line">        executableCalls.add(asyncCall);<span class="comment">//入执行队列</span></span><br><span class="line">        runningAsyncCalls.add(asyncCall);<span class="comment">//入运行队列</span></span><br><span class="line">      &#125;</span><br><span class="line">      isRunning = runningCallsCount() &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = executableCalls.size(); i &lt; size; i++) &#123;</span><br><span class="line">      AsyncCall asyncCall = executableCalls.get(i);</span><br><span class="line">      asyncCall.executeOn(executorService());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isRunning;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>AsnycCall是个Runaable实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">executeOn</span><span class="params">(ExecutorService executorService)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">assert</span> (!Thread.holdsLock(client.dispatcher()));</span><br><span class="line">      <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        executorService.execute(<span class="keyword">this</span>);<span class="comment">//提交到线程池</span></span><br><span class="line">        success = <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">        InterruptedIOException ioException = <span class="keyword">new</span> InterruptedIOException(<span class="string">"executor rejected"</span>);</span><br><span class="line">        ioException.initCause(e);</span><br><span class="line">        transmitter.noMoreExchanges(ioException);</span><br><span class="line">        responseCallback.onFailure(RealCall.<span class="keyword">this</span>, ioException);<span class="comment">//触发失败回调</span></span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">          client.dispatcher().finished(<span class="keyword">this</span>); <span class="comment">// This call is no longer running!</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>线程具体执行的地方</p><p>走到这里就和同步请求一致了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> signalledCallback = <span class="keyword">false</span>;</span><br><span class="line">    transmitter.timeoutEnter();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Response response = getResponseWithInterceptorChain();<span class="comment">//请求响应</span></span><br><span class="line">        signalledCallback = <span class="keyword">true</span>;</span><br><span class="line">        responseCallback.onResponse(RealCall.<span class="keyword">this</span>, response);<span class="comment">//成功回调</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (signalledCallback) &#123;</span><br><span class="line">            <span class="comment">// Do not signal the callback twice!</span></span><br><span class="line">            Platform.get().log(INFO, <span class="string">"Callback failure for "</span> + toLoggableString(), e);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            responseCallback.onFailure(RealCall.<span class="keyword">this</span>, e);<span class="comment">//失败回调</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ul><li>Response读取一次内容会关闭，所以只能读取一次</li><li>Response读取byteStream时，需要手动close它</li></ul><p>参考：</p><ul><li><a href="https://square.github.io/okhttp/" target="_blank" rel="noopener">https://square.github.io/okhttp/</a></li><li><a href="https://www.jianshu.com/p/9ed2c2f2a52c" target="_blank" rel="noopener">https://www.jianshu.com/p/9ed2c2f2a52c</a></li><li><a href="https://www.jianshu.com/p/da4a806e599b" target="_blank" rel="noopener">https://www.jianshu.com/p/da4a806e599b</a></li><li><a href="https://www.jianshu.com/p/70dfa335916c" target="_blank" rel="noopener">OkHttp踩坑记：为何 response.body().string() 只能调用一次</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习使用Rxjava</title>
      <link href="/2019/07/10/Android-RxJava%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/07/10/Android-RxJava%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="RxJava"><a href="#RxJava" class="headerlink" title="RxJava"></a>RxJava</h2><h3 id="What"><a href="#What" class="headerlink" title="What:"></a>What:</h3><p>异步</p><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>Observable 通用的被观察者</li><li>Observer  通用的观察者</li><li>Scheduler 线程调度器</li><li>Disposable 一次性的</li></ul><h3 id="how"><a href="#how" class="headerlink" title="how"></a>how</h3><a id="more"></a><h4 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先创建被观察者</span></span><br><span class="line">Observable observable = Observable.create(</span><br><span class="line">                <span class="keyword">new</span> ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;String&gt; observableEmitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        observableEmitter.onNext(<span class="string">"hello"</span>);</span><br><span class="line">                        <span class="keyword">int</span> error = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span> (error == <span class="number">0</span>) &#123;</span><br><span class="line">                            observableEmitter.onError(<span class="keyword">new</span> Exception(<span class="string">"error == 0"</span>));</span><br><span class="line">                        &#125;</span><br><span class="line">                        observableEmitter.onComplete();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"><span class="comment">//创建观察者</span></span><br><span class="line"></span><br><span class="line"> Observer observer = <span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable disposable)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"onSubscribe"</span>);<span class="comment">//产生订阅关系调用，即在调用subscribe线程</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">                System.out.println(str);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"error!!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"onComplete"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//订阅，（注入灵魂233）</span></span><br><span class="line">    observable.subscribe(oberver);</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">onSubscribe</span><br><span class="line">hello</span><br><span class="line">onComplete</span><br></pre></td></tr></table></figure><p>结合使用lambda链式写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(subscribe-&gt; &#123;</span><br><span class="line">            subscribe.onNext(<span class="string">"hello"</span>);</span><br><span class="line">            <span class="keyword">int</span> errorCode = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (errorCode == <span class="number">1</span>) &#123;</span><br><span class="line">                subscribe.onError(<span class="keyword">new</span> Exception(<span class="string">"errorCode = 1"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            subscribe.onComplete();</span><br><span class="line">        &#125;).doOnSubscribe(str -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"onSubscribe"</span>);</span><br><span class="line">        &#125;).subscribe(</span><br><span class="line">                str-&gt; System.out.println(str),</span><br><span class="line">                throwable -&gt; throwable.printStackTrace(),</span><br><span class="line">                ()-&gt; System.out.println(<span class="string">"complete"</span>));</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">onSubscribe</span><br><span class="line">hello</span><br><span class="line">complete</span><br></pre></td></tr></table></figure><h4 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h4><p>Rxjava提供了以下几种线程调度器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Schedulers.single();<span class="comment">//所有任务在单线程</span></span><br><span class="line">Schedulers.newThread();<span class="comment">//使用新线程</span></span><br><span class="line">Schedulers.trampoline();<span class="comment">//</span></span><br><span class="line">Schedulers.io();<span class="comment">//用于IO密集型操作，比如读取文件，数据库，网络</span></span><br><span class="line">Schedulers.computation();<span class="comment">//用于CPU密集型计算，比如xml，json解析，Bitmap压缩取样</span></span><br><span class="line">AndroidSchedulers.mainThread();<span class="comment">//android 主线程</span></span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> Observable.create(emitter -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"observable"</span>);</span><br><span class="line">            emitter.onNext(<span class="string">"hello"</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getId());</span><br><span class="line">        &#125;) .subscribeOn(Schedulers.newThread())<span class="comment">//被观察者执行动作所在线程</span></span><br><span class="line">                .observeOn(Schedulers.newThread())<span class="comment">//观察者执行动作所在线程</span></span><br><span class="line">                .subscribe(str-&gt;&#123;</span><br><span class="line">                    System.out.println(<span class="string">"observer"</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getId());</span><br><span class="line">                    System.out.println(str);</span><br><span class="line">                &#125;);</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">observable</span><br><span class="line"><span class="number">14</span></span><br><span class="line">observer</span><br><span class="line"><span class="number">15</span></span><br><span class="line">hello</span><br></pre></td></tr></table></figure><p>这样就基本上能完成很多线程切换的操作。</p><h4 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h4><p>格式各样的操作符，我就记下我看懂的操作符吧呃呃</p><p>变换</p><ul><li>map</li><li>flatMap</li></ul><p>过滤</p><ul><li>filter</li><li>take</li><li>takeLast</li><li>skip</li><li>skipLast</li><li>elementAt</li><li>debounce</li><li>distinct</li><li>first</li><li>last</li></ul><p>组合</p><ul><li>merge</li><li>startWith</li><li>concat</li><li>zip</li></ul><p>其它</p><ul><li>interval</li><li>compose</li></ul><h5 id="map"><a href="#map" class="headerlink" title="map"></a>map</h5><p>将发射值进行转换成另一种发设值</p><p>map(Func1&lt;? super T, ? extends R&gt; func))</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">                .map(integer -&gt; &#123;</span><br><span class="line">                    <span class="keyword">char</span> tmp = (<span class="keyword">char</span>) (<span class="string">'a'</span> + integer);</span><br><span class="line">                    <span class="keyword">return</span> String.valueOf(integer) + tmp;</span><br><span class="line">                &#125;).subscribe(System.out::println);</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="number">1</span>b</span><br><span class="line"><span class="number">2</span>c</span><br><span class="line"><span class="number">3</span>d</span><br><span class="line"><span class="number">4</span>e</span><br><span class="line"><span class="number">5f</span></span><br></pre></td></tr></table></figure><h5 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h5><p>发射值进行进一步转换成Observable序列，平摊成Observable序列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="string">"1234"</span>, <span class="string">"5678"</span>)</span><br><span class="line">                .flatMap((Function&lt;String, ObservableSource&lt;Character&gt;&gt;) s -&gt; &#123;</span><br><span class="line">                    Character[] characters = <span class="keyword">new</span> Character[s.length()];</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">                        characters[i] = s.charAt(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> Observable.fromArray(characters);</span><br><span class="line">                &#125;).subscribe(System.out::println);</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure><h5 id="scan"><a href="#scan" class="headerlink" title="scan"></a>scan</h5><p>将上一个经过函数处理的发射值作为下一个参数继续处理。</p><p>好比如：第一次处理为1，第二次就是1+2=3，然后第三次3+3=6，依次类推</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">                .scan((integer, integer2) -&gt; integer + integer2)</span><br><span class="line">                .subscribe(System.out::println);</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure><h5 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h5><p>判断式过滤</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">                .filter(integer -&gt; integer % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                .subscribe(System.out::println);</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><h5 id="take"><a href="#take" class="headerlink" title="take"></a>take</h5><p>只取前n个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">                .take(<span class="number">3</span>)</span><br><span class="line">                .subscribe(System.out::println);</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h5 id="takeLast"><a href="#takeLast" class="headerlink" title="takeLast"></a>takeLast</h5><p>只去后n个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">                .takeLast(<span class="number">3</span>)</span><br><span class="line">                .subscribe(System.out::println);</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><h5 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h5><p>跳过前n个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">                .skip(<span class="number">2</span>)</span><br><span class="line">                .subscribe(System.out::println);</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><h5 id="skipLast"><a href="#skipLast" class="headerlink" title="skipLast"></a>skipLast</h5><p>跳过后n个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">                .skipLast(<span class="number">2</span>)</span><br><span class="line">                .subscribe(System.out::println);</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h5 id="elementAt"><a href="#elementAt" class="headerlink" title="elementAt"></a>elementAt</h5><p>只去固定序号元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">                .elementAt(<span class="number">3</span>)</span><br><span class="line">                .subscribe(System.out::println);</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h5 id="debounce"><a href="#debounce" class="headerlink" title="debounce"></a>debounce</h5><p>过滤掉了由Observable发射的速率过快的数据；如果在一个指定的时间间隔过去了仍旧没有发射一个，那么它将发射最后的那个。通常我们用来结合RxBinding(Jake Wharton大神使用RxJava封装的Android UI组件)使用，防止button重复点击。</p><h5 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h5><p>去重</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">                .distinct()</span><br><span class="line">                .subscribe(System.out::println);</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>distinct(Func1) 则需要你给出key作为去重依据</p><p>distinctUntilChanged(Func1)和distinct(Func1)一样，根据Func1中call方法产生一个Key来判断两个相邻的数据项是否相同。</p><h5 id="first"><a href="#first" class="headerlink" title="first"></a>first</h5><p>只发送第一个元素，first参数为，当没有元素发出，则使用参数发出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">                .first(<span class="number">2</span>)</span><br><span class="line">                .subscribe(System.out::println);</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h5 id="last"><a href="#last" class="headerlink" title="last"></a>last</h5><p>类似first，最后一个</p><h5 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h5><p>两个事件序列和一个，合并的数据是无序的。</p><h5 id="startWith"><a href="#startWith" class="headerlink" title="startWith"></a>startWith</h5><p>在某序列前合并</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">startWith(T);</span><br><span class="line">startWith(T...);</span><br><span class="line">startWith(Observable&lt;T&gt;);</span><br><span class="line">startWith(Iterable&lt;T&gt;);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Observable a = Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">Observable b = Observable.just(<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>);</span><br><span class="line">a.startWith(Arrays.asList(<span class="number">0</span>,<span class="number">9</span>,<span class="number">22</span>)).subscribe(System.out::println);</span><br><span class="line">System.out.println(<span class="string">"--------------"</span>);</span><br><span class="line">a.startWith(b).subscribe(System.out::println);</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">22</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">--------------</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h5 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h5><p>严格按照发射顺序组合，上一个没发射完，下一个不会发射。</p><h5 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h5><p>将两个事件序列，通过函数组合新的，数量不匹配的元素丢弃。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Observable a = Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>);</span><br><span class="line">Observable b = Observable.just(<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>);</span><br><span class="line">Observable.zip(a,b,(BiFunction&lt;Integer, Character, String&gt;) </span><br><span class="line">    (integer, character) -&gt; integer + String.valueOf(character))</span><br><span class="line">    .subscribe(System.out::println);</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="number">1</span>a</span><br><span class="line"><span class="number">2</span>b</span><br><span class="line"><span class="number">3</span>c</span><br></pre></td></tr></table></figure><h5 id="interval"><a href="#interval" class="headerlink" title="interval"></a>interval</h5><p>按照间隔执行，但是要产生订阅关系的线程不能立即执行完毕，否则无法执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Observable.interval(<span class="number">300</span>,TimeUnit.MILLISECONDS).subscribe(position -&gt; System.out.println(position));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">20000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">按照间隔<span class="number">300</span>ms打印positon，从<span class="number">0</span>开始，代表次数</span><br></pre></td></tr></table></figure><h5 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h5><p>对事件序列的变换也就是Obervable的变化，之前是mapflatMap是对发射元素的变换，这个可以直接处理事件流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">        Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">                .compose(upstream -&gt; upstream.subscribeOn(Schedulers.io()).observeOn(Schedulers.newThread()))</span><br><span class="line">                .subscribe();</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">  Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">      .subscribeOn(Schedulers.io())</span><br><span class="line">      .observeOn(Schedulers.newThread()))</span><br><span class="line">      .subscribe();</span><br></pre></td></tr></table></figure><p>比如重复代码：线程切换，可以写成通用代码，然后直接传给compose就行了同理有其他的流处理操作也可以复用，然后调用compose</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ObservableTransformer&lt;T, T&gt; <span class="title">rxSchedulerhelper</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> observable -&gt; observable.subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="why"><a href="#why" class="headerlink" title="why"></a>why</h3><p>调用还是挺简单的，内部实现的话可以概括为：</p><p>自上而下生成装饰的Observable，在subscribe时，从下往上订阅上游Observable并且生成装饰的Observer。</p><p>自上而下包装Observable，subscriber自下而上生调用上流的observale，同时消费对应的Observer，即自下而上包装Obserer，在顺序上表现为，下流Obervable不断的调用存储上流的Obervable，在onNext时，上游Oberver依次调用下游Oberver。</p><h4 id="分析最简单的订阅"><a href="#分析最简单的订阅" class="headerlink" title="分析最简单的订阅"></a>分析最简单的订阅</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Observable observable = Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;String&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">               System.out.println(Thread.currentThread().getId());</span><br><span class="line">               System.out.println(<span class="string">"run"</span>);</span><br><span class="line">               emitter.onNext(<span class="string">"test"</span>);</span><br><span class="line">               emitter.onComplete();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       Observer observer = <span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">               System.out.println(Thread.currentThread().getId());</span><br><span class="line">               System.out.println(<span class="string">"onSubscribe"</span>);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String o)</span> </span>&#123;</span><br><span class="line">               System.out.println(Thread.currentThread().getId());</span><br><span class="line">               System.out.println(<span class="string">"onNext"</span> + o);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">               System.out.println(<span class="string">"onError"</span>);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               System.out.println(<span class="string">"onComplete"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">    observable.subscribe(observer);</span><br></pre></td></tr></table></figure><p>首先Observable.create创键出Obervable。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">create</span><span class="params">(ObservableOnSubscribe&lt;T&gt; source)</span> </span>&#123;</span><br><span class="line">        ObjectHelper.requireNonNull(source, <span class="string">"source is null"</span>);</span><br><span class="line">        <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableCreate&lt;T&gt;(source));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>返回了一个ObservableCreate的并且把我们的源储存起来了</p><p>调用subscribe</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">    ObjectHelper.requireNonNull(observer, <span class="string">"observer is null"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        observer = RxJavaPlugins.onSubscribe(<span class="keyword">this</span>, observer);</span><br><span class="line"></span><br><span class="line">        ObjectHelper.requireNonNull(observer, <span class="string">"Plugin returned null Observer"</span>);</span><br><span class="line"></span><br><span class="line">        subscribeActual(observer);/</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException e) &#123; <span class="comment">// NOPMD</span></span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        Exceptions.throwIfFatal(e);</span><br><span class="line">        <span class="comment">// can't call onError because no way to know if a Disposable has been set or not</span></span><br><span class="line">        <span class="comment">// can't call onSubscribe because the call might have set a Subscription already</span></span><br><span class="line">        RxJavaPlugins.onError(e);</span><br><span class="line"></span><br><span class="line">        NullPointerException npe = <span class="keyword">new</span> NullPointerException(<span class="string">"Actually not, but can't throw other exceptions due to RS"</span>);</span><br><span class="line">        npe.initCause(e);</span><br><span class="line">        <span class="keyword">throw</span> npe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着实际调用subscribeActual，这个是抽象方法，所以得看ObservableCreate得实现内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">        CreateEmitter&lt;T&gt; parent = <span class="keyword">new</span> CreateEmitter&lt;T&gt;(observer);<span class="comment">//将observer传入CreateEmitter</span></span><br><span class="line">        observer.onSubscribe(parent);<span class="comment">//触发onSubscribe</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            source.subscribe(parent);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            Exceptions.throwIfFatal(ex);</span><br><span class="line">            parent.onError(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>调用我们源头的source，也就是开始定义得。然后就执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Observable observable = Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;String&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getId());</span><br><span class="line">                System.out.println(<span class="string">"run"</span>);</span><br><span class="line">                emitter.onNext(<span class="string">"test"</span>);<span class="comment">//触发observer的onNext</span></span><br><span class="line">                emitter.onComplete();<span class="comment">//触发observer的onComplete</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>这样就完成一个订阅关系。可以看出每一层Observable和Observer通过subscribe订阅触发，如果调用了线程切换，各种操作符，其实也是在从上层生成新的Observable包裹着上游的Observable，最后在最下层订阅，从下层开始一层一层调用subscribe的最终调到源头的Observable。</p><h4 id="带线程的调度分析"><a href="#带线程的调度分析" class="headerlink" title="带线程的调度分析"></a>带线程的调度分析</h4><p>知道他的触发原理后我们可以直接去看那一层的Observable和Observer</p><h5 id="ObservableSubscribeOn"><a href="#ObservableSubscribeOn" class="headerlink" title="ObservableSubscribeOn"></a>ObservableSubscribeOn</h5><p>这个就是我们使用subscribeOn即在Observable线程调度，看看它实际触发订阅的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(<span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> SubscribeOnObserver&lt;T&gt; parent = <span class="keyword">new</span> SubscribeOnObserver&lt;T&gt;(s);<span class="comment">//新的Observer</span></span><br><span class="line"></span><br><span class="line">        s.onSubscribe(parent);<span class="comment">//onSubscribe总是在订阅触发线程执行</span></span><br><span class="line"></span><br><span class="line">        parent.setDisposable(scheduler.scheduleDirect(<span class="keyword">new</span> SubscribeTask(parent)));<span class="comment">//使用具体的调度器取执行调度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscribeTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> SubscribeOnObserver&lt;T&gt; parent;</span><br><span class="line"></span><br><span class="line">        SubscribeTask(SubscribeOnObserver&lt;T&gt; parent) &#123;</span><br><span class="line">            <span class="keyword">this</span>.parent = parent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            source.subscribe(parent);<span class="comment">//触发上一层的订阅</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>额，scheduler的调度我下次分析把，反正大抵上就是使用线程池啊等来进行线程调度。</p><h5 id="ObservableObserveOn"><a href="#ObservableObserveOn" class="headerlink" title="ObservableObserveOn"></a>ObservableObserveOn</h5><p>这个就是形成obsrverOn的地方，也就是observer的线程调度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (scheduler <span class="keyword">instanceof</span> TrampolineScheduler) &#123;</span><br><span class="line">            source.subscribe(observer);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Scheduler.Worker w = scheduler.createWorker();</span><br><span class="line"></span><br><span class="line">            source.subscribe(<span class="keyword">new</span> ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//这次就没有再subscribe上做手脚，而是再ObserveOnObserver包装类上做了线程切换，下游的onNext进行线程切换处理</span></span><br></pre></td></tr></table></figure><p>因为Obervable是从上到下进行包裹，所以subscribOn多次调用也只会是第一起作用。而Observer是订阅时从下往上包裹，所以observerOn可以变化许多次。</p><p>其它操作符也是如此把。</p><h4 id="RxBus"><a href="#RxBus" class="headerlink" title="RxBus"></a>RxBus</h4><p>RxBus 实现是在一个既为Observable和Observer的实例中内部保存了事件数组，通过触发onNext遍历到对应的事件，进行调用。</p><p>待补充。。。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归纳下广播和内容提供器</title>
      <link href="/2019/07/10/Android-%E5%BD%92%E7%BA%B3%E4%B8%8B%E5%B9%BF%E6%92%AD%E5%92%8C%E5%86%85%E5%AE%B9%E6%8F%90%E4%BE%9B%E5%99%A8/"/>
      <url>/2019/07/10/Android-%E5%BD%92%E7%BA%B3%E4%B8%8B%E5%B9%BF%E6%92%AD%E5%92%8C%E5%86%85%E5%AE%B9%E6%8F%90%E4%BE%9B%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h2><h3 id="what"><a href="#what" class="headerlink" title="what"></a>what</h3><p>android内部封装的一种通信方式，如其名，广播，向注册的接收者广播信息</p><ul><li>标准广播：异步执行，所有接受器几乎同时收到，无法被拦截</li><li>有序广播：同步执行，有先后顺序，按照优先级，可以被拦截</li></ul><h3 id="接受系统广播"><a href="#接受系统广播" class="headerlink" title="接受系统广播"></a>接受系统广播</h3><p>在android系统内部会有巨多的广播，来向向应用扩散重要信息。比如开机，网络，sd卡等等。</p><p>想要接受系统广播首先需要定义<code>广播接收器</code>：</p><ul><li>静态注册：在Manifest中声明关心的广播</li><li>动态注册：通过代码声明</li></ul><a id="more"></a><h4 id="定义广播接收器"><a href="#定义广播接收器" class="headerlink" title="定义广播接收器"></a>定义广播接收器</h4><p>继承<code>BroadcastReceiver</code>重写onReceive即可判断广播</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkChangeRecevier</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        ConnectivityManager connectivityManager = (ConnectivityManager)        getSystemService(Context.CONNECTIVITY_SERVICE);</span><br><span class="line">        NetworkInfo networkInfo = connectivityManager.getActiveNetworkInfo();</span><br><span class="line">        <span class="keyword">if</span> (networkInfo != <span class="keyword">null</span> &amp;&amp; networkInfo.isAvailable()) &#123;</span><br><span class="line">            Toast.makeText(MainActivity.<span class="keyword">this</span>,<span class="string">"网络可用"</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Toast.makeText(MainActivity.<span class="keyword">this</span>,<span class="string">"网络不可用"</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态注册"><a href="#静态注册" class="headerlink" title="静态注册"></a>静态注册</h4><p>直接在Manifest中书写<code>receiver</code>标签，同如activity和service，写好<code>intent-filter</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//1、新建一个BroadcastReceiver</span><br><span class="line">//2、在应用配置文件，设置好权限，以及监听的广播</span><br><span class="line"><span class="tag">&lt;<span class="name">receiver</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">".BootCompleteReceiver"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:enabled</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:exported</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.BOOT_COMPLETED"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line">//enabled表示是否启用</span><br><span class="line">//exproted表示是否接受应用以外的广播</span><br></pre></td></tr></table></figure><h4 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">intentFilter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">intentFilter.addAction(<span class="string">"android.net.conn.CONNECTIVITY_CHANGE"</span>);</span><br><span class="line">recevier = <span class="keyword">new</span> NetworkChangeRecevier();</span><br><span class="line">registerReceiver(recevier,intentFilter);</span><br></pre></td></tr></table></figure><p>只有注册完之后才能监听广播。</p><p>记得在对应的生命周期取消注册。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unregisterReceiver(recevier);</span><br></pre></td></tr></table></figure><h3 id="自定义广播"><a href="#自定义广播" class="headerlink" title="自定义广播"></a>自定义广播</h3><p>需要自行传达某些消息</p><h4 id="发送标准广播"><a href="#发送标准广播" class="headerlink" title="发送标准广播"></a>发送标准广播</h4><p>8.0后自定义广播接受不到解决方案：</p><ul><li>使用动态注册</li><li>静态注册，发送广播时携带ComponentName</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、新建一个自定义的广播接受器</span></span><br><span class="line"><span class="comment">//2、静态注册接受自定义的广播</span></span><br><span class="line"><span class="comment">//3、发送广播</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.example.tt.MY_BROADCAST"</span>);</span><br><span class="line">Log.d(<span class="string">"button"</span>, <span class="string">"onClick: "</span>);</span><br><span class="line">intent.setComponent(<span class="keyword">new</span> ComponentName(<span class="string">"com.example.hujie2.broadcasttest"</span>,</span><br><span class="line">        <span class="string">"com.example.hujie2.broadcasttest.MyBroadcastReceiver"</span>));</span><br><span class="line">sendBroadcast(intent);</span><br></pre></td></tr></table></figure><h4 id="发送有序广播"><a href="#发送有序广播" class="headerlink" title="发送有序广播"></a>发送有序广播</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setOrderBroadcast(intent);</span><br><span class="line">Manifest通过设置android:priority设置优先级</span><br><span class="line">使用 abortBroadcast() 拦截广播</span><br></pre></td></tr></table></figure><h4 id="粘性广播"><a href="#粘性广播" class="headerlink" title="粘性广播"></a>粘性广播</h4><p><strong>需要额外申请权限</strong>在Android系统粘性广播一般用来确保重要的状态改变后的信息被持久保存，并且能随时广播给新的广播接收器使用，使用isInitialStickyBroadcast来判断是否是一个粘性的初始广播值，比如我遇见的耳机插拔的时候就出现的粘性广播。</p><p>声明权限</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.BROADCAST_STICKY"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>发送</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sendStickyBroadcast(intent);<span class="comment">//好像API写了废弃。。</span></span><br></pre></td></tr></table></figure><p>判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isInitialStickyBroadcast()</span><br></pre></td></tr></table></figure><h3 id="本地广播"><a href="#本地广播" class="headerlink" title="本地广播"></a>本地广播</h3><p>只在本地应用实行的广播，如果不需要向外部广播，那就用本地广播咯</p><p>发送和注册方式略有不同，通过获得<code>LocalBroadcastManager</code>实例来管理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">localBroadcastManager = LocalBroadcastManager.getInstance(<span class="keyword">this</span>);<span class="comment">//本地广播管理器</span></span><br><span class="line">Button button = findViewById(R.id.button2);</span><br><span class="line">button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="string">"MY.LocalBroadcast"</span>);<span class="comment">//意图</span></span><br><span class="line">        localBroadcastManager.sendBroadcast(intent);<span class="comment">//发送本地广播</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">intentFilter = <span class="keyword">new</span> IntentFilter();<span class="comment">//意图过滤</span></span><br><span class="line">intentFilter.addAction(<span class="string">"MY.LocalBroadcast"</span>);<span class="comment">//设置监听广播行为</span></span><br><span class="line">localReceiver = <span class="keyword">new</span> LocalReceiver();<span class="comment">//自定义广播接收器</span></span><br><span class="line">localBroadcastManager.registerReceiver(localReceiver,intentFilter);<span class="comment">//注册广播接收器</span></span><br><span class="line">localBroadcastManager.unregisterReceiver(localReceiver);<span class="comment">//注销广播接受器</span></span><br></pre></td></tr></table></figure><h3 id="后续补充"><a href="#后续补充" class="headerlink" title="后续补充"></a>后续补充</h3><h2 id="内容提供器"><a href="#内容提供器" class="headerlink" title="内容提供器"></a>内容提供器</h2><h3 id="what-1"><a href="#what-1" class="headerlink" title="what"></a>what</h3><p>在andorid往往需要访问其它应用的数据共同协作。通过内容提供器的方式安全的提供给其他应用访问修改数据。比如读取通讯录，读取MediaCenter的数据，他们都是暴露除了内容提供器来供其它应用访问数据。其它应用通过内容解析器访问uri，如同访问数据库的方式一样访问修改数据。</p><h3 id="FileContentProvider"><a href="#FileContentProvider" class="headerlink" title="FileContentProvider"></a>FileContentProvider</h3><p>从android 7.0开始直接使用<code>file://Uri</code>这样暴力的传达文件路径进行分享操作将不可用，会报<code>FileUriExposedException</code>异常，必须得用<code>content://Uri</code>这样得形式来解析分享文件的路径</p><h4 id="声明FileContentProvider"><a href="#声明FileContentProvider" class="headerlink" title="声明FileContentProvider"></a>声明FileContentProvider</h4><p>Manifest中配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"android.support.v4.content.FileProvider"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:authorities</span>=<span class="string">"app的包名.fileProvider"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:grantUriPermissions</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"android.support.FILE_PROVIDER_PATHS"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:resource</span>=<span class="string">"@xml/file_paths"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="路径配置文件"><a href="#路径配置文件" class="headerlink" title="路径配置文件"></a>路径配置文件</h4><p>在xml资源文件夹下创键file_paths.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//每个节点都支持两个属性：name+path</span><br><span class="line">//path：需要临时授权访问的路径（.代表所有路径） </span><br><span class="line">//name：就是你给这个访问路径起个名字</span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">paths</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root-path</span> <span class="attr">name</span>=<span class="string">"root"</span> <span class="attr">path</span>=<span class="string">""</span> /&gt;</span> //代表设备的根目录new File("/");</span><br><span class="line">    <span class="tag">&lt;<span class="name">files-path</span> <span class="attr">name</span>=<span class="string">"files"</span> <span class="attr">path</span>=<span class="string">""</span> /&gt;</span> //context.getFilesDir()</span><br><span class="line">    <span class="tag">&lt;<span class="name">cache-path</span> <span class="attr">name</span>=<span class="string">"cache"</span> <span class="attr">path</span>=<span class="string">""</span> /&gt;</span> //context.getCacheDir()</span><br><span class="line">    <span class="tag">&lt;<span class="name">external-path</span> <span class="attr">name</span>=<span class="string">"external"</span> <span class="attr">path</span>=<span class="string">""</span> /&gt;</span> //Environment.getExternalStorageDirectory()</span><br><span class="line">    <span class="tag">&lt;<span class="name">external-files-path</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">path</span>=<span class="string">"path"</span> /&gt;</span> //context.getExternalFilesDirs()</span><br><span class="line">    <span class="tag">&lt;<span class="name">external-cache-path</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">path</span>=<span class="string">"path"</span> /&gt;</span> //getExternalCacheDirs()</span><br><span class="line"><span class="tag">&lt;/<span class="name">paths</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;</span><br><span class="line">    Uri uri = FileProvider.getUriForFile(CameraActivity.<span class="keyword">this</span>, <span class="string">"app的包名.fileProvider"</span>, photoFile);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Uri uri = Uri.fromFile(photoFile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过这样的包装形成uri:<code>content://app的包名/files/path/文件</code> 就可以匹配到具体实际路径了</p><h3 id="访问应用数据"><a href="#访问应用数据" class="headerlink" title="访问应用数据"></a>访问应用数据</h3><p>android 的许多数据都可以获得，但是要申请权限</p><p>比如：通讯录，短信，各种类别的文件</p><h4 id="准备uri"><a href="#准备uri" class="headerlink" title="准备uri"></a>准备uri</h4><p>api的类一般都会暴露uri，比如：<code>MediaStore.Files.getContentUri(&quot;external&quot;)</code> </p><h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">context.getContentResolver().query();</span><br><span class="line">context.getContentResolver().insert();</span><br><span class="line">context.getContentResolver().delete();</span><br><span class="line">context.getContentResolver().update();</span><br></pre></td></tr></table></figure><p>就和操作数据库一样，因为内容提供器本身就是相当于包装了一层数据库访问操作。</p><h3 id="自定义内容提供器"><a href="#自定义内容提供器" class="headerlink" title="自定义内容提供器"></a>自定义内容提供器</h3><h4 id="自然还是要Manifest声明"><a href="#自然还是要Manifest声明" class="headerlink" title="自然还是要Manifest声明"></a>自然还是要Manifest声明</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:name</span>=<span class="string">".provider.MyContentProvider"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:authorities</span>=<span class="string">"com.my.demo.provider"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:enabled</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:exported</span>=<span class="string">"true"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h4 id="继承实现"><a href="#继承实现" class="headerlink" title="继承实现"></a>继承实现</h4><p>感觉是固定代码，内部访问数据库</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.hujie2.filepersistencetest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.ContentProvider;</span><br><span class="line"><span class="keyword">import</span> android.content.ContentValues;</span><br><span class="line"><span class="keyword">import</span> android.content.UriMatcher;</span><br><span class="line"><span class="keyword">import</span> android.database.Cursor;</span><br><span class="line"><span class="keyword">import</span> android.database.sqlite.SQLiteDatabase;</span><br><span class="line"><span class="keyword">import</span> android.net.Uri;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseContentProvider</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BOOK_DIR = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BOOK_ITEM = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CATEGORY_DIR = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CATEGORY_ITEM = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTHORITY = <span class="string">"com.example.hujie2.filepersistencetest.provider"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> UriMatcher uriMatcher;</span><br><span class="line">    <span class="keyword">private</span>  MyDatabaseHelper dbHelper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//uri匹配</span></span><br><span class="line">        uriMatcher = <span class="keyword">new</span> UriMatcher(UriMatcher.NO_MATCH);</span><br><span class="line">        uriMatcher.addURI(AUTHORITY, <span class="string">"book"</span>, BOOK_DIR);</span><br><span class="line">        uriMatcher.addURI(AUTHORITY, <span class="string">"book/#"</span>, BOOK_ITEM);</span><br><span class="line">        uriMatcher.addURI(AUTHORITY, <span class="string">"category"</span>, CATEGORY_DIR);</span><br><span class="line">        uriMatcher.addURI(AUTHORITY, <span class="string">"category/#"</span>, CATEGORY_ITEM);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DatabaseContentProvider</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获得数据库辅助类对象</span></span><br><span class="line">        dbHelper = <span class="keyword">new</span> MyDatabaseHelper(getContext(), <span class="string">"BookStore.db"</span>, <span class="keyword">null</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(Uri uri, String[] projection, String selection,</span></span></span><br><span class="line"><span class="function"><span class="params">                        String[] selectionArgs, String sortOrder)</span> </span>&#123;</span><br><span class="line">        SQLiteDatabase db = dbHelper.getReadableDatabase();</span><br><span class="line">        Cursor cursor = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (uriMatcher.match(uri)) &#123;</span><br><span class="line">            <span class="keyword">case</span> BOOK_DIR:</span><br><span class="line">                cursor = db.query(<span class="string">"book"</span>, projection, selection, selectionArgs, <span class="keyword">null</span>, <span class="keyword">null</span>, sortOrder);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BOOK_ITEM:</span><br><span class="line">                String bookId = uri.getPathSegments().get(<span class="number">1</span>);</span><br><span class="line">                cursor = db.query(<span class="string">"book"</span>, projection, <span class="string">"id = ?"</span>, <span class="keyword">new</span> String[]&#123;bookId&#125;, <span class="keyword">null</span>, <span class="keyword">null</span>, sortOrder);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CATEGORY_DIR:</span><br><span class="line">                cursor = db.query(<span class="string">"category"</span>, projection, selection, selectionArgs, <span class="keyword">null</span>, <span class="keyword">null</span>, sortOrder);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CATEGORY_ITEM:</span><br><span class="line">                String categoryId = uri.getPathSegments().get(<span class="number">1</span>);</span><br><span class="line">                cursor = db.query(<span class="string">"category"</span>, projection, <span class="string">"id = ?"</span>, <span class="keyword">new</span> String[]&#123;categoryId&#125;, <span class="keyword">null</span>, <span class="keyword">null</span>, sortOrder);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cursor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri, ContentValues values)</span> </span>&#123;</span><br><span class="line">        SQLiteDatabase db = dbHelper.getWritableDatabase();</span><br><span class="line">        Uri uriReturn = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (uriMatcher.match(uri)) &#123;</span><br><span class="line">            <span class="keyword">case</span> BOOK_DIR:</span><br><span class="line">            <span class="keyword">case</span> BOOK_ITEM:</span><br><span class="line">                <span class="keyword">long</span> newBookId = db.insert(<span class="string">"book"</span>, <span class="keyword">null</span>, values);</span><br><span class="line">                uriReturn = Uri.parse(<span class="string">"content://"</span> + AUTHORITY + <span class="string">"/book/"</span> + newBookId);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CATEGORY_DIR:</span><br><span class="line">            <span class="keyword">case</span> CATEGORY_ITEM:</span><br><span class="line">                <span class="keyword">long</span> newCategoryId = db.insert(<span class="string">"category"</span>, <span class="keyword">null</span>, values);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uriReturn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Uri uri, ContentValues values, String selection,</span></span></span><br><span class="line"><span class="function"><span class="params">                      String[] selectionArgs)</span> </span>&#123;</span><br><span class="line">        SQLiteDatabase db = dbHelper.getWritableDatabase();</span><br><span class="line">        <span class="keyword">int</span> updatedRows = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span> (uriMatcher.match(uri)) &#123;</span><br><span class="line">            <span class="keyword">case</span> BOOK_DIR:</span><br><span class="line">                updatedRows = db.update(<span class="string">"book"</span>, values, selection, selectionArgs);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BOOK_ITEM:</span><br><span class="line">                String bookId = uri.getPathSegments().get(<span class="number">1</span>);</span><br><span class="line">                updatedRows = db.update(<span class="string">"book"</span>, values, <span class="string">"id = ?"</span>, <span class="keyword">new</span> String[]&#123;bookId&#125;);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CATEGORY_DIR:</span><br><span class="line">                updatedRows = db.update(<span class="string">"category"</span>, values, selection, selectionArgs);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CATEGORY_ITEM:</span><br><span class="line">                String categoryId = uri.getPathSegments().get(<span class="number">1</span>);</span><br><span class="line">                updatedRows = db.update(<span class="string">"category"</span>, values, <span class="string">"id = ?"</span>, <span class="keyword">new</span> String[]&#123;categoryId&#125;);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> updatedRows;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(Uri uri, String selection, String[] selectionArgs)</span> </span>&#123;</span><br><span class="line">        SQLiteDatabase db = dbHelper.getWritableDatabase();</span><br><span class="line">        <span class="keyword">int</span> deletedRows = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span> (uriMatcher.match(uri)) &#123;</span><br><span class="line">            <span class="keyword">case</span> BOOK_DIR:</span><br><span class="line">                deletedRows = db.delete(<span class="string">"book"</span>, selection, selectionArgs);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BOOK_ITEM:</span><br><span class="line">                String bookId = uri.getPathSegments().get(<span class="number">1</span>);</span><br><span class="line">                deletedRows = db.delete(<span class="string">"book"</span>, <span class="string">"id = ?"</span>, <span class="keyword">new</span> String[]&#123;bookId&#125;);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CATEGORY_DIR:</span><br><span class="line">                deletedRows = db.delete(<span class="string">"category"</span>, selection, selectionArgs);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CATEGORY_ITEM:</span><br><span class="line">                String categoryId = uri.getPathSegments().get(<span class="number">1</span>);</span><br><span class="line">                deletedRows = db.delete(<span class="string">"category"</span>, <span class="string">"id = ?"</span>, <span class="keyword">new</span> String[]&#123;categoryId&#125;);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deletedRows;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(Uri uri)</span> </span>&#123;</span><br><span class="line">        String vndDir = <span class="string">"vnd.android.cursor.dir/"</span>;</span><br><span class="line">        String vndItem = <span class="string">"vnd.android.cursor.item/"</span>;</span><br><span class="line">        <span class="keyword">switch</span> (uriMatcher.match(uri)) &#123;</span><br><span class="line">            <span class="keyword">case</span> BOOK_DIR:</span><br><span class="line">                <span class="keyword">return</span> vndDir + <span class="string">"vnd."</span> + AUTHORITY + <span class="string">".book"</span>;</span><br><span class="line">            <span class="keyword">case</span> BOOK_ITEM:</span><br><span class="line">                <span class="keyword">return</span> vndItem + <span class="string">"vnd."</span> + AUTHORITY + <span class="string">".book"</span>;</span><br><span class="line">            <span class="keyword">case</span> CATEGORY_DIR:</span><br><span class="line">                <span class="keyword">return</span> vndDir + <span class="string">"vnd."</span> + AUTHORITY + <span class="string">".category"</span>;</span><br><span class="line">            <span class="keyword">case</span> CATEGORY_ITEM:</span><br><span class="line">                <span class="keyword">return</span> vndItem + <span class="string">"vnd."</span> + AUTHORITY + <span class="string">".category"</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Handler消息机制梳理</title>
      <link href="/2019/07/07/Android-%E5%85%B3%E4%BA%8EHandler%E7%AD%89/"/>
      <url>/2019/07/07/Android-%E5%85%B3%E4%BA%8EHandler%E7%AD%89/</url>
      
        <content type="html"><![CDATA[<h3 id="what"><a href="#what" class="headerlink" title="what"></a>what</h3><p>在Android开发中，Hanldler消息机制可以说无处不在，主线程的调度，View，任务提交，IntentService，Messager中都出现了，可谓无处不在。handler消息发挥作用的包含了：Handler，Looper，Message，MessagerQueue，这四个重要组成。Handler发送消息，Looper开启轮询从MessageQueue中获取消息，交由Handler处理。</p><h3 id="how"><a href="#how" class="headerlink" title="how"></a>how</h3><p>还是从一个使用者角度先了解，具体怎么用Handler吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Handler mHandler = <span class="keyword">new</span> Handler(Looper.getMainLooper())&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    doSomeThing();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    doSomeThing();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mHandler.sendEmptyMessage(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创键Handler对象，传入Looper，发送消息。再Hanlder内部处理消息，当然还可以直接发送Runnable，或者加入延时等。用法就这么简单。下面还是具体介绍吧</p><a id="more"></a><h3 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h3><p>可以发送消息和处理消息，可以有很多个实例，具体根据消息来分辨处理。</p><p>它的成员包括了Looper，MessageQueue，Callback</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常用api，以及加上延时等</span></span><br><span class="line">post(Runnable);<span class="comment">//提交任务</span></span><br><span class="line">sendMessage(Message);<span class="comment">//提交消息</span></span><br><span class="line">handleMessage(Message);<span class="comment">//处理消息</span></span><br></pre></td></tr></table></figure><p>一般使用Handler有两种方法，一般是需要传入Looper，如果不则默认传入当前线程的Looper</p><ul><li>扩展Handler，重写handleMessage</li><li>传入回调，回调也只需要实现handleMessage</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最终被调用的构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper, Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">        mLooper = looper;<span class="comment">//looper</span></span><br><span class="line">        mQueue = looper.mQueue;<span class="comment">//looper的messagequeue</span></span><br><span class="line">        mCallback = callback;<span class="comment">//回调形式处理消息</span></span><br><span class="line">        mAsynchronous = async;<span class="comment">//开启发送异步消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h3><p>这个的话管他叫轮询，反正是有循环的意思。首先它是一个ThreadLocal变量，保证了每个线程间独立运行，再而它的话就是从消息队列中取出消息，转交到Handler处理</p><p>它的成员包括了ThreadLocal，MessageQueue，Thread。</p><p>看下重要api</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">prepare();<span class="comment">//获取线程本地Looper实例</span></span><br><span class="line">loop();<span class="comment">//进入轮询</span></span><br><span class="line">quit();<span class="comment">//退出</span></span><br><span class="line">getMainLooper();<span class="comment">//获得主线程Looper</span></span><br></pre></td></tr></table></figure><h3 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h3><p>封装了消息码，触发时机，runnable，目标handler的消息，内部是一个长度50不断复用的消息池（链表结构），消息分为异步和同步</p><p>看下重要api</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Message.obtain();<span class="comment">//从池里获得消息</span></span><br></pre></td></tr></table></figure><h3 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h3><p>尾插法实现的消息链表，异步消息优先出，称之为消息队列，但是不是那个操作系统的消息队列啊。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">next();<span class="comment">//拿取消息</span></span><br><span class="line">quit();<span class="comment">//退出</span></span><br><span class="line">enqueueMessage();<span class="comment">//入消息</span></span><br></pre></td></tr></table></figure><h3 id="从源码来角度再探析"><a href="#从源码来角度再探析" class="headerlink" title="从源码来角度再探析"></a>从源码来角度再探析</h3><p>本来向从主线程来分析的，但是好像不怎么完整，那就用HandlerTread来分析吧，这个就非常完整了</p><h4 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h4><p>首先这是一个Thread，内部实现了Handler消息机制，即可以通过Handler来进行提交任务和消息到线程中运行。</p><p>先看下是怎么用的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HandlerThread handlerThread = <span class="keyword">new</span> HandlerThread(<span class="string">"test"</span>);<span class="comment">//创键HandlerThread</span></span><br><span class="line">handlerThrad.start();<span class="comment">//开启线程</span></span><br><span class="line">Handler handler = <span class="keyword">new</span> Handler(handlerThread.getLooper());<span class="comment">//关联Handler</span></span><br><span class="line">handler.post(()-&gt; System.out.println(<span class="string">"run1"</span>));<span class="comment">//提交任务或者消息</span></span><br><span class="line">handler.sendEmptyMessage(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>用就是这么用的。原理就是handler提交消息，HandlerThread线程开启轮询，分发消息，处理。</p><p>接下来就可以分析源码了：</p><h4 id="HandlerThread构造"><a href="#HandlerThread构造" class="headerlink" title="HandlerThread构造"></a>HandlerThread构造</h4><p>首先进入HandlerThread构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HandlerThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        mPriority = Process.THREAD_PRIORITY_DEFAULT;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HandlerThread</span><span class="params">(String name, <span class="keyword">int</span> priority)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        mPriority = priority;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//就起了个名字而已</span></span><br></pre></td></tr></table></figure><h4 id="HandlerThread进入run"><a href="#HandlerThread进入run" class="headerlink" title="HandlerThread进入run"></a>HandlerThread进入run</h4><p>接着线程开启进入run方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HandlerThread.run</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mTid = Process.myTid();<span class="comment">//获取进程PID</span></span><br><span class="line">    Looper.prepare();<span class="comment">//Looper准备</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        mLooper = Looper.myLooper();<span class="comment">//获取Looper</span></span><br><span class="line">        notifyAll();<span class="comment">//唤醒</span></span><br><span class="line">    &#125;</span><br><span class="line">    Process.setThreadPriority(mPriority);</span><br><span class="line">    onLooperPrepared();<span class="comment">//回掉</span></span><br><span class="line">    Looper.loop();<span class="comment">//进入Looper轮询</span></span><br><span class="line">    mTid = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在run方法中等于说准备looper，进入轮询</p><h4 id="准备Looper"><a href="#准备Looper" class="headerlink" title="准备Looper"></a>准备Looper</h4><p>接着看下如何准备Looper和获得Looper的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Looper.prepare</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));<span class="comment">//创键本线程的Looper</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里就是入准备本线程的Looper</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Looper.myLooper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sThreadLocal.get();<span class="comment">//获得</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="进入Looper轮询"><a href="#进入Looper轮询" class="headerlink" title="进入Looper轮询"></a>进入Looper轮询</h4><p>接下就是重头戏了，进入轮询，挑关键代码看看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Looper.loop</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Looper me = myLooper();<span class="comment">//获取looper</span></span><br><span class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;<span class="comment">//获取MessageQueue</span></span><br><span class="line">    <span class="comment">//...省略</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Message msg = queue.next(); <span class="comment">// might block，从消息队列中获取消息，也许阻塞</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">            <span class="keyword">return</span>;<span class="comment">//没有消息则代表队列退出了</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//...省略</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            msg.target.dispatchMessage(msg);<span class="comment">//交由给Handler分发消息</span></span><br><span class="line">            dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">                Trace.traceEnd(traceTag);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//...省略</span></span><br><span class="line">        msg.recycleUnchecked();<span class="comment">//回收消息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个过程也还好理解，开启死循环，从消息队列中不断的拿去消息，然后由消息目标 handler进行分发处理。</p><p>接下我先看简单的handler如何分发处理消息的。待会再看如何获取消息的</p><h4 id="消息处理"><a href="#消息处理" class="headerlink" title="消息处理"></a>消息处理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Handler.dispatchMessage</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//看消息本省是否有回掉处理，额，这个callback类型其实是Runnable，其实就是看看这个消息是不是Runnable类型</span></span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;<span class="comment">//交由创键回调handleMessage的处理消息，也就实现的handleMessage</span></span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);<span class="comment">//交由本省的handleMessage处理，也就是扩展的handleMessage</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">    message.callback.run();<span class="comment">//直接调用runnable的run方法，完成提交任务的run</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分发消息比较简单，首先判断这个消息是否是Runnable类型，是则直接调run，不是的在看是由本身的handleMessage处理还是回调的handleMessage处理。</p><h4 id="取出消息"><a href="#取出消息" class="headerlink" title="取出消息"></a>取出消息</h4><p>接着就看如何获取消息的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MessageQueue.next</span></span><br><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Return here if the message loop has already quit and been disposed.</span></span><br><span class="line">    <span class="comment">// This can happen if the application tries to restart a looper after quit</span></span><br><span class="line">    <span class="comment">// which is not supported.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;<span class="comment">//循环去拿出合适时机消息</span></span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line">   <span class="comment">//Linux的管道基础上的，空闲等待nextPollTimeoutMillis，和传统的阻塞不一样，</span></span><br><span class="line">        <span class="comment">//nextPollTimeoutMillis这个时间则是消息延时时间</span></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">            Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">            Message msg = mMessages;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());<span class="comment">//优先出异步消息</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                    <span class="comment">//消息没有准备好运行，设定了延时执行，计算出延时时间，空闲等待</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//消息准备好了，出消息</span></span><br><span class="line">                    <span class="comment">// Got a message.</span></span><br><span class="line">                    mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Returning message: "</span> + msg);</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="keyword">return</span> msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// No more messages.没有消息</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process the quit message now that all pending messages have been handled.</span></span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                dispose();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...省略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MessageQueue中next中进入死循环获取消息，从队列中去拿去消息，遍历队列消息，队列的消息是按照执行时刻从小到大排列的，根据当前时刻取出该执行的消息（优先取异步消息），如果时机未到则会进入空闲等待(基于linux的管道)。等到了时机则会取出消息。</p><p>这一路下来从Looper轮询，消息取出，消息执行的步骤。</p><p>接下看看是如何提交消息的</p><h4 id="构建消息"><a href="#构建消息" class="headerlink" title="构建消息"></a>构建消息</h4><p>构建消息，首先从消息复用池拿去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Message.obtain</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//链表咯</span></span><br><span class="line">            Message m = sPool;</span><br><span class="line">            sPool = m.next;</span><br><span class="line">            m.next = <span class="keyword">null</span>;</span><br><span class="line">            m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></span><br><span class="line">            sPoolSize--;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Message();<span class="comment">//池为空则新建</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="提交消息"><a href="#提交消息" class="headerlink" title="提交消息"></a>提交消息</h4><p>接着Handler提交消息，无论是runnable消息，或者空消息，或者其它的消息，或者带延时的，最终sendMessageAtTime</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Handler.sendMessageAtTime</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">        MessageQueue queue = mQueue;</span><br><span class="line">        <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</span><br><span class="line">            Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);<span class="comment">//入消息队列</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="消息入队列"><a href="#消息入队列" class="headerlink" title="消息入队列"></a>消息入队列</h4><p>接着就是进入消息队列，执行时刻小的在前插入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;<span class="comment">//如果退出</span></span><br><span class="line">            IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</span><br><span class="line">            Log.w(TAG, e.getMessage(), e);</span><br><span class="line">            msg.recycle();<span class="comment">//回收</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">// New head, wake up the event queue if blocked. 新建链表头</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Inserted within the middle of the queue.  Usually we don't have to wake</span></span><br><span class="line">            <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">            <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;<span class="comment">//找到合适的位置，保证时刻顺序</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next 插入</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>差不多流程就是这样了。这个例子使用HandlerThread做示范的，UI主线程同样也是使用这样的实现的。</p><h3 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h3><p>内部实现HandlerThread的Servcie，开启子线程执行，代码比较简单直接截下来了，构建HandlerThread，Handler，在onStartCommand中发送消息，并最终在onHandleIntent响应执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">IntentService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Looper mServiceLooper;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ServiceHandler mServiceHandler;</span><br><span class="line">    <span class="keyword">private</span> String mName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mRedelivery;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ServiceHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(looper);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            onHandleIntent((Intent)msg.obj);<span class="comment">//调用</span></span><br><span class="line">            stopSelf(msg.arg1);<span class="comment">//结束servcie</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IntentService</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        mName = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIntentRedelivery</span><span class="params">(<span class="keyword">boolean</span> enabled)</span> </span>&#123;</span><br><span class="line">        mRedelivery = enabled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        HandlerThread thread = <span class="keyword">new</span> HandlerThread(<span class="string">"IntentService["</span> + mName + <span class="string">"]"</span>);<span class="comment">//构建</span></span><br><span class="line">        thread.start();<span class="comment">//开启</span></span><br><span class="line"></span><br><span class="line">        mServiceLooper = thread.getLooper();</span><br><span class="line">        mServiceHandler = <span class="keyword">new</span> ServiceHandler(mServiceLooper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(@Nullable Intent intent, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">        Message msg = mServiceHandler.obtainMessage();</span><br><span class="line">        msg.arg1 = startId;</span><br><span class="line">        msg.obj = intent;</span><br><span class="line">        mServiceHandler.sendMessage(msg);<span class="comment">//发送</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(@Nullable Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">        onStart(intent, startId);</span><br><span class="line">        <span class="keyword">return</span> mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mServiceLooper.quit();<span class="comment">//退出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@WorkerThread</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(@Nullable Intent intent)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>梳理一波Service</title>
      <link href="/2019/07/06/Android-%E6%A2%B3%E7%90%86%E4%B8%80%E6%B3%A2Service/"/>
      <url>/2019/07/06/Android-%E6%A2%B3%E7%90%86%E4%B8%80%E6%B3%A2Service/</url>
      
        <content type="html"><![CDATA[<h2 id="what"><a href="#what" class="headerlink" title="what"></a>what</h2><p>Android 四大组件之一，名为服务，可见与activity具有同等地位，看名字也只到，服务嘛，一般用于提供进行UI无关的等任务操作。和activity存在不一样，这家伙的存在是可以说是无声无息，甚至在有些流氓的软件中，你关掉了app，那还不一定关掉了服务[捂脸] ，不过这也正突出了service的特点，后台。开始知道是用来进行后台任务就行了，看看怎么用吧。</p><blockquote><p><code>Service</code> 是一个可以在后台执行长时间运行操作而不提供用户界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。 此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信 (IPC)。 例如，服务可以处理网络事务、播放音乐，执行文件 I/O 或与内容提供程序交互，而所有这一切均可在后台进行。</p></blockquote><p>google爸爸说的好条理哦</p><p><code>特别：Service默认也是在主线程进行的。所以也会有ANR风险。</code></p><a id="more"></a><h2 id="how"><a href="#how" class="headerlink" title="how"></a>how</h2><h3 id="定义一个服务"><a href="#定义一个服务" class="headerlink" title="定义一个服务"></a>定义一个服务</h3><h4 id="继承Service"><a href="#继承Service" class="headerlink" title="继承Service"></a>继承Service</h4><p>首先的肯定是要继承一个Service的咯</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span><span class="comment">//服务被第一次创建调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span><span class="comment">//被调用服务调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span><span class="comment">//销毁时调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span><span class="comment">//绑定时调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Manifest声明"><a href="#Manifest声明" class="headerlink" title="Manifest声明"></a>Manifest声明</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">android:enabled</span>=<span class="string">[</span>"<span class="attr">true</span>" | "<span class="attr">false</span>"]</span></span><br><span class="line"><span class="tag">         <span class="attr">android:exported</span>=<span class="string">[</span>"<span class="attr">true</span>" | "<span class="attr">false</span>"]</span></span><br><span class="line"><span class="tag">         <span class="attr">android:icon</span>=<span class="string">"drawable resource"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:isolatedProcess</span>=<span class="string">[</span>"<span class="attr">true</span>" | "<span class="attr">false</span>"]</span></span><br><span class="line"><span class="tag">         <span class="attr">android:label</span>=<span class="string">"string resource"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:name</span>=<span class="string">"string"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:permission</span>=<span class="string">"string"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:process</span>=<span class="string">"string"</span> &gt;</span></span><br><span class="line">    . . .</span><br><span class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="开启服务"><a href="#开启服务" class="headerlink" title="开启服务"></a>开启服务</h3><p>嗯，Intent又来了，哈哈，在持有context的地方调用，既然是用Intent，自然servie的也会有Intent-Filter标签来过滤。不过好像从来没用过类似activity的隐式启动，google发现原来是5.0以上就不允许。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(context, TestService.class);</span><br><span class="line">context.startService(intent);</span><br></pre></td></tr></table></figure><p>首先的话必然先调用onCreate，然后就是onStartCommmand，这个服务就算是开启了，活了。后面再startService也只会调用onStartCommand了。</p><h3 id="停止服务"><a href="#停止服务" class="headerlink" title="停止服务"></a>停止服务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种，通过context关闭</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(context, TestService.class);</span><br><span class="line">context.stopservcie(intent);</span><br><span class="line"><span class="comment">//第二种，在servie内部停止</span></span><br><span class="line">stopSelf();</span><br></pre></td></tr></table></figure><p>停止服务后系统会尽快销毁服务，当然也就会调用onDestroy咯</p><h3 id="服务交互–绑定服务"><a href="#服务交互–绑定服务" class="headerlink" title="服务交互–绑定服务"></a>服务交互–绑定服务</h3><p>好像之前使用开启服务和关闭服务，调用者和服务基本没什么耦合关系。各走各路了呃呃。为了能够保持调用者和服务之间的交互。使用<code>绑定服务</code>，这也是开启服务的另一种方式，话句话说通过绑定的方式来开启服务。这就要用到onBind的方法了。</p><h4 id="绑定本地服务"><a href="#绑定本地服务" class="headerlink" title="绑定本地服务"></a>绑定本地服务</h4><h5 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h5><p>除了基本的使用扩展Binder，或者使用Messenger，AIDL（其实也是Binder，233）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;<span class="comment">//被绑定时调用</span></span><br><span class="line">        <span class="comment">//需要给出一个Binder对象，具体怎么给，都可以，内部类，匿名对象，只要是Binder就行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Binder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyBinder</span> <span class="keyword">extends</span> <span class="title">Binder</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someActionA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"do some action A"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someActionB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"do some actin B"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h5><p>准备ServiceConnection，发起绑定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> MyBinder mMyBinder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServiceConnection mServiceConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"on connected"</span>);</span><br><span class="line">            mMyBinder = (MyBinder) service;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"on disconnected"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">toBindService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(context, TestService.class);</span><br><span class="line">        context.bindService(intent, mServiceConnection, flag);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//过程为toBindService --&gt; onBinder --&gt; onServiceConnected</span></span><br></pre></td></tr></table></figure><p>通过这样的方法我们就能够拿到一个Binder对象，或者其它东西，这样就算和Service建立起了交互</p><h5 id="取消绑定"><a href="#取消绑定" class="headerlink" title="取消绑定"></a>取消绑定</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unBindService(serviceConnection);</span><br></pre></td></tr></table></figure><p><strong>Flag</strong> ： 关于绑定服务的Flag</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BIND_AUTO_CREATE,<span class="comment">//若绑定服务时服务未启动，则会自动启动服务。 注意，这种情况下服务的onStartCommand,仍然未被调用（它只会在显式调用startService时才会被调用）。</span></span><br><span class="line">BIND_DEBUG_UNBIND,<span class="comment">//使用此标志绑定服务之后的unBindService方法会无效。 这种方法会引起内存泄露，只能在调试时使用。</span></span><br><span class="line">BIND_NOT_FOREGROUND,<span class="comment">//被绑定的服务进程优先级不允许被提到FOREGROUND级别</span></span><br><span class="line">BIND_ABOVE_CLIENT,<span class="comment">//服务比app重要，oom移除killer杀死service前杀死app</span></span><br><span class="line">BIND_ALLOW_OOM_MANAGEMENT,</span><br><span class="line">BIND_WAIVE_PRIORITY,<span class="comment">//被绑定的服务进程不会被OOM列入猎杀对象中。</span></span><br><span class="line">BIND_IMPORTANT,<span class="comment">//被绑定的服务进程优先级会被提到FOREGROUND级别</span></span><br><span class="line">BIND_ADJUST_WITH_ACTIVITY<span class="comment">//允许activity调整重要性</span></span><br></pre></td></tr></table></figure><p>一般使用第一个咯，这里我收集到的翻译的不明确，还是具体参看<code>Context.java</code>源码的英文注释</p><h4 id="绑定远程服务"><a href="#绑定远程服务" class="headerlink" title="绑定远程服务"></a>绑定远程服务</h4><p>也就是IPC，在android 系统中很多服务都是可以直接跨进程调用的，而这些服务也都是由某些组件应用提供的。通过绑定远程的服务可以调用其它的功能，比如蓝牙，wifi等等。进程间通信，这个我放在单独的IPC后面详细归纳</p><ul><li>Messenger</li><li>AIDL</li></ul><h3 id="前台服务"><a href="#前台服务" class="headerlink" title="前台服务"></a>前台服务</h3><p>这个算是用户主动意识到的一种服务，<code>即使内存不足，也不会考虑终止</code>，优先级很高，其实说白点了，就是一个普通的服务通过开启通知栏的形式，讲明了服务在运行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创键通知</span></span><br><span class="line">Notification notification = <span class="keyword">new</span> Notification(R.drawable.icon, getText(R.string.ticker_text),</span><br><span class="line">        System.currentTimeMillis());</span><br><span class="line">Intent notificationIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, ExampleActivity.class);</span><br><span class="line">PendingIntent pendingIntent = PendingIntent.getActivity(<span class="keyword">this</span>, <span class="number">0</span>, notificationIntent, <span class="number">0</span>);</span><br><span class="line">notification.setLatestEventInfo(<span class="keyword">this</span>, getText(R.string.notification_title),</span><br><span class="line">        getText(R.string.notification_message), pendingIntent);</span><br><span class="line"><span class="comment">//服务开启前台，并且关联通知</span></span><br><span class="line">startForeground(ONGOING_NOTIFICATION_ID, notification);</span><br></pre></td></tr></table></figure><h3 id="Intent服务"><a href="#Intent服务" class="headerlink" title="Intent服务"></a>Intent服务</h3><h5 id="what-1"><a href="#what-1" class="headerlink" title="what"></a>what</h5><p>类：IntentService，通过扩展这个类实现的服务，里面操作会在子线程中进行。而且不需要手动关闭服务，它自己就会关闭。那么看看怎么用吧</p><h5 id="how-1"><a href="#how-1" class="headerlink" title="how"></a>how</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloIntentService</span> <span class="keyword">extends</span> <span class="title">IntentService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * A constructor is required, and must call the super IntentService(String)</span></span><br><span class="line"><span class="comment">   * constructor with a name for the worker thread.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HelloIntentService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(<span class="string">"HelloIntentService"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The IntentService calls this method from the default worker thread with</span></span><br><span class="line"><span class="comment">   * the intent that started the service. When this method returns, IntentService</span></span><br><span class="line"><span class="comment">   * stops the service, as appropriate.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Normally we would do some work here, like download a file.</span></span><br><span class="line">      <span class="comment">// For our sample, we just sleep for 5 seconds.</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          <span class="comment">// Restore interrupt status.</span></span><br><span class="line">          Thread.currentThread().interrupt();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开启服务还是和普通的没区别，但是所有的操作可以在<code>onHandleIntent</code>中响应。而且此时这个方法内就是子线程了。还不用关心服务停止</p><h5 id="why"><a href="#why" class="headerlink" title="why"></a>why</h5><p>那么为啥IntentService有这么大魔力呢，子线程，自带关闭，其实原理很简单，内部维护了简单的Looper和Handler操作（关于Handler和IntentService原理下次一起详细归纳下），使得所有的从onStartCommand的操作进入了一个HandlerThread中，然后每次调用都向提交任务给线程。最后也会执行完也会停止自己。</p><h3 id="远程服务"><a href="#远程服务" class="headerlink" title="远程服务"></a>远程服务</h3><p>在service配置声明中有一个属性<code>process</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">android:process</span>=<span class="string">":remote"</span> <span class="attr">android:enable</span>=<span class="string">"true"</span> <span class="attr">andorid:exported</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>这样在运行的时候，这个service就和本应用位于不同的进程中了，那么就轮到IPC上场了。对咯，既然是IPC了，原来的开启服务的方式就行不通，那就的用AIDL咯</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><p>小心ANR:常态下Service的代码是运行在主线程滴</p></li><li><p>不要过多的实现代码在这里，要把服务看成一个后台任务调用代理。。</p></li><li><p>关于onStartCommand返回值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//该返回值描述了在杀死事件中如何继续这个服务</span><br><span class="line">START_NOT_STICKY</span><br><span class="line">杀死后不会重启</span><br><span class="line">START_STICKY</span><br><span class="line">杀死后会重启，但是第一次启动的startCommand()的Intent为null</span><br><span class="line">START_REDELIVER_INTENT</span><br><span class="line">杀死后会重启，并且会重传Intent</span><br></pre></td></tr></table></figure></li></ul><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>普通启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">call to start service</span><br><span class="line">|</span><br><span class="line">onCreate</span><br><span class="line">|</span><br><span class="line">onStartCommand</span><br><span class="line">|</span><br><span class="line">service is running</span><br><span class="line">|</span><br><span class="line">onDestory</span><br><span class="line">|</span><br><span class="line">service shut down</span><br></pre></td></tr></table></figure><p>绑定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">call to bind servie</span><br><span class="line">|</span><br><span class="line">onCreate</span><br><span class="line">|</span><br><span class="line">onBind</span><br><span class="line">|</span><br><span class="line">client are bound to servcie</span><br><span class="line">|</span><br><span class="line">onUnbind</span><br><span class="line">|</span><br><span class="line">onDesotry</span><br><span class="line">|</span><br><span class="line">service shut down</span><br></pre></td></tr></table></figure><p>onStartCommand一定是在调用startServie才会调用的。即使是绑定服务，也不会调用它的。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>梳理一波Activity基础使用</title>
      <link href="/2019/07/03/Android-%E6%A2%B3%E7%90%86%E4%B8%80%E6%B3%A2Activity/"/>
      <url>/2019/07/03/Android-%E6%A2%B3%E7%90%86%E4%B8%80%E6%B3%A2Activity/</url>
      
        <content type="html"><![CDATA[<h2 id="what"><a href="#what" class="headerlink" title="what"></a>what</h2><p>首先初学android第一个学的绝逼是Activity，翻译为活动，即看的见，摸得着的玩意。android SDK提供了一套模板类即Activity，开发者需要继承它，并且在对的时间做相应的事情，比如UI初始化，数据加载等等，通过在Manifest文件中声明这个新的Activity就可以了。这次就先不探讨Activity是怎么工作的，从应用的角度来看看它，（AMS还得再学习学习2333）。</p><h2 id="how"><a href="#how" class="headerlink" title="how"></a>how</h2><p>无非就是创建类然后实现Activity，然后注册到Manifest中。可以了。</p><p>主要来看看Activity中重要的API吧。</p><a id="more"></a><h3 id="首先看看Activity继承结构。"><a href="#首先看看Activity继承结构。" class="headerlink" title="首先看看Activity继承结构。"></a>首先看看Activity继承结构。</h3><ul><li><p>AppCompatActivity ：目前来说默认AS创建的Activity继承自AppcompatActivity,直接意思兼容的Activity咯，支持ActionBar,同时对MD控件提供支持。</p></li><li><p>FragmentActivity：支持Fagment使用的Activity，因为3.0之前是没有Fragmnt，所以为了兼容引入。</p></li><li><p>Activity：原汁原味的。。</p></li></ul><h3 id="接着看看日常必须用得到方法"><a href="#接着看看日常必须用得到方法" class="headerlink" title="接着看看日常必须用得到方法"></a>接着看看日常必须用得到方法</h3><ul><li><p>生命周期方法，放在下面好了。</p></li><li><p>setSupportActionBar和getSupportActionBar，进去ToolBar,出来AcionBar,工具栏相关的者两个一定得用</p></li><li><p>onConfigurationChanged，配置发生改变，就会回调这里。再Manifest中activity的配置中要设定关心那些变化</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">""</span> <span class="attr">android:configChanges</span>=<span class="string">"orientation|keyboard"</span>/&gt;</span></span><br><span class="line">横竖屏切换，键盘等等</span><br></pre></td></tr></table></figure></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">onSaveInstanceState 和 onRestoreInstanceState 保存和恢复当前的某些状态和数据</span><br><span class="line">内存回收后重新创建Activty，可以传递Bundle</span><br><span class="line">onCreateOptionsMenu //创建menu的回调</span><br><span class="line">onOptionsItemSelected //设置响应menu事件的回调</span><br><span class="line">getMenuInflater //填充menu的填充器</span><br><span class="line">onRequestPermissionsResult //请求权限后处理结果的回调</span><br><span class="line">onBackPressed //按下返回回调</span><br><span class="line">onLowMemory //低内存回调</span><br><span class="line">onActivityResult //启动其它activity返回结果回调</span><br></pre></td></tr></table></figure></li></ul><p>好像列出来没什么软用。。</p><h3 id="Intent使用"><a href="#Intent使用" class="headerlink" title="Intent使用"></a>Intent使用</h3><p>能够定义Activity后，接着就是利用Intent进行页面的跳转了。Intent意为意图，在四大组件中基本都是利用Intent进行调用和传递。</p><p>Intent分为启动方和接受方，启动方发出Intent，接收方接收。完成跳转或启动，启动方需要给出Intent目标或方向，而接受方需要明确自己能接受什么Intent</p><p>首先Intent很干脆，就是一个Parcelable 和 Cloneable而已，Intent同样对应着Manifest文件intent-filter标签，代表当前组件能够响应什么样的意图</p><p>显式使用Intent进行跳转Activity：明确目标地点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Context from, Class&lt;? extends Activity&gt; to, Bundle bundle)</span> </span>&#123;</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(from, to);</span><br><span class="line">    <span class="keyword">if</span> (bundle != <span class="keyword">null</span>) &#123;</span><br><span class="line">        intent.putExtras(bundle);</span><br><span class="line">    &#125;</span><br><span class="line">    from.startActivity(intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>隐式使用Intent：不明确目标地点，但是能给出大致的方向。通过action，category，data三种隐式过滤，来搜寻目标。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.addCategory(String);<span class="comment">//可以多个</span></span><br><span class="line">intent.setAction(String);<span class="comment">//单个</span></span><br><span class="line">intent.setData(Uri);<span class="comment">//单个</span></span><br></pre></td></tr></table></figure><p>响应的一方可以设置多个Intent-filter</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.VIEW"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:host</span>=<span class="string">""</span> <span class="attr">android:mimeType</span>=<span class="string">""</span> <span class="attr">android:port</span>=<span class="string">""</span> <span class="attr">android:scheme</span>=<span class="string">""</span> <span class="attr">android:path</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure><p>携带数据</p><p>Intent可以携带基本数据类型，数组，Parcelable，Serializable，不爽的话直接Bundle打包。不过内部实现也是一起打包在Bundle中。</p><p>startActivityForResult 这则是启动activity后返回可以读取返回的数据，需要重写onActivityResult来读取Intent</p><p>到了这里其实也能够做听过事了，不光能够自己应用内跳转，以及开启相机啊，相册，很多很多。</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="返回栈"><a href="#返回栈" class="headerlink" title="返回栈"></a>返回栈</h3><p>用于管理任务栈，新Activity入栈，finish出栈。</p><h3 id="活动状态"><a href="#活动状态" class="headerlink" title="活动状态"></a>活动状态</h3><ul><li>运行状态：activity位于栈顶</li><li>暂停状态：可见，不位于栈顶</li><li>停止状态：不可见，不位于栈顶</li><li>销毁状态：出栈</li></ul><h3 id="生命周期方法"><a href="#生命周期方法" class="headerlink" title="生命周期方法"></a>生命周期方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">onCreate<span class="comment">//设置Layout</span></span><br><span class="line">onStart<span class="comment">//可见</span></span><br><span class="line">onResume<span class="comment">//可见可交互</span></span><br><span class="line">onPause<span class="comment">//可见不可交互</span></span><br><span class="line">onStop<span class="comment">//不可见</span></span><br><span class="line">onDesotry<span class="comment">//销毁</span></span><br><span class="line">onRestart<span class="comment">//onStop恢复后会走</span></span><br></pre></td></tr></table></figure><p>生命周期方法对应了活动状态时的回调</p><h2 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a>启动模式</h2><p>指定Activity的启动模式，对应着<strong>android:launchMode</strong>属性</p><ul><li>Standard 标准模式，无论站内是否存在实例，都会创建新的</li><li>SingleTop 栈顶存在则不创建新的</li><li>SingleTask 栈内存在则不创建新的，并且把上面的全都出栈</li><li>SingleInstance 用一个单独的栈来管理</li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 泛型</title>
      <link href="/2019/07/02/Java-%E6%B3%9B%E5%9E%8B/"/>
      <url>/2019/07/02/Java-%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="what"><a href="#what" class="headerlink" title="what"></a>what</h3><p>泛型我通俗的认为就是参数化类型，即传入类型提示。告诉它我即将要在这个类型的版本上使用你了。并且在写出大量代码时使用泛型可以写出一套模板代码。而且使用了泛型后，在编译期间泛型这个是能够检测你的代码有没有使用不规范类型的对象，在编译期间有点不好理解，但是当我们用IDE的时候，一旦你使用泛型，产生的对象，在IDE看来所给出的代码提示等检查也都是基于传入的泛型参数。但是呢，编译通过后在jvm中运行表现看来，所有用于参数类型的对象表现为Object， 这也俗称类型擦除。<strong>泛型参数不能时基本类型</strong></p><a id="more"></a><h3 id="how"><a href="#how" class="headerlink" title="how"></a>how</h3><h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><p>首先列举下我们经常用到一些关于泛型的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><p>如何自行定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class Person&lt;T&gt; &#123;</span><br><span class="line">    T t;</span><br><span class="line">    <span class="function">T <span class="title">getT</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setT</span><span class="params">(T t)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person&lt;String&gt; person = <span class="keyword">new</span> Person&lt;&gt;();</span><br><span class="line">        person.setT(<span class="string">"ffff"</span>);</span><br><span class="line">        Person&lt;Integer&gt; person1 = <span class="keyword">new</span> Person&lt;&gt;();</span><br><span class="line">        person1.setT(<span class="number">9</span>);</span><br><span class="line">        System.out.println(person.getT().getClass());</span><br><span class="line">        System.out.println(person1.getT().getClass());</span><br><span class="line">        System.out.println(person.getClass());<span class="comment">//class learn2.GenericTest$Person</span></span><br><span class="line">        System.out.println(person1.getClass());<span class="comment">//class learn2.GenericTest$Person</span></span><br><span class="line">        GenericTest test = <span class="keyword">new</span> GenericTest();</span><br><span class="line">        test.getArray(<span class="number">1</span>,<span class="number">23</span>,<span class="number">4</span>);</span><br><span class="line">        test.getArray(<span class="string">"f"</span>, <span class="string">"f"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> &lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> T t;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setT</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.t = t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">getT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后你就能发挥想象创造代码了呀，别看它加了尖括号和类型，其实看穿了还是一个普通类。通过Class比较你都看不到关于泛型的东西</p><p>以及后续的继承</p><h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Presenter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">attachView</span><span class="params">(T t)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dettachView</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实和泛型类没啥不同</p><h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; T[] getArray(T ...ts) &#123;</span><br><span class="line">        <span class="keyword">return</span> ts;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">static</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="keyword">int</span>[] nums = test.getArray(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">        String[] strs = test.getArray(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子是我比较喜欢的，通过变长的参数返回数组。看在你传入参数一刹那，其实就是相当于把类型参数弄进入了。</p><h4 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h4><p>在jdk的代码中以及框架呀大量使用关于泛型的东西，说明了这玩意很好使。通过接口实现，或者类的继承中加入泛型，又能够写出可复用的代码。以及配合通配符，配合多态呀，那简直爽的不要不要的。</p><p><code>extends</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IPresenter</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">IView</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//说明了传入的参数类型，得要是IView子类</span></span><br></pre></td></tr></table></figure><p>好吧我老是把&lt;? extends T&gt; 和 <t extends sometype>搞混。。</t></p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><p>泛型参数不能是基本类型</p></li><li><p>不能带泛型用于<code>instancof</code>关键字</p></li><li><p>不可以用于泛型数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] lists = <span class="keyword">new</span> ArrayList&lt;String&gt;[<span class="number">10</span>];<span class="comment">//无法这样不行的</span></span><br><span class="line">List&lt;String&gt;[] lists = <span class="keyword">new</span> ArrayList[<span class="number">10</span>];<span class="comment">//这样却是可以的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//唯一的方式就是创建类型擦出的数组，然后再转型</span></span><br><span class="line">List&lt;String&gt;[] lists = <span class="keyword">new</span> ArrayList[<span class="number">10</span>];</span><br><span class="line">lists[<span class="number">0</span>] = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">lists[<span class="number">0</span>].add(<span class="string">"aa"</span>);</span><br><span class="line">System.out.println(lists.getClass());</span><br></pre></td></tr></table></figure></li><li><p>类型捕获</p><p>通同getClass来获取真实的类型咯</p></li><li><p>泛型和重载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span>,<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//因为泛型擦初，所以二者有相同的方法签名</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(List&lt;E&gt; list)</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//同样</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(T t)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(E e)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>自限定的类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">C</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">//这自限定的例子比较简单，即限定比较对象为自己，其实仔细研究还是泛型的事</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(C o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">A</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;&#125; <span class="comment">//这个有点抽象，但是仔细看好像陷入一个无限循环样子</span></span><br><span class="line"><span class="comment">//首先我们继承它看看</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span>&lt;<span class="title">B</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//这样写是否合理，就看B是否能套入&lt;T extentd A&lt;T&gt;&gt; 中，呃呃，看了好久，是可以</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//那么到底有什么用呢，这个通常用于继承关系中的限定。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">A</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">         <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span>&lt;<span class="title">B</span>&gt; </span>&#123;<span class="comment">//这个泛型参数只能事继承链上的，换了其它的不可以，就是这是妙用啊</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(B b)</span> </span>&#123;<span class="comment">//由于限定了这个实现的方法就必须为自己。其它不行。有意思呵呵</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>异常处理中catch是不能捕获泛型类型的异常，因为再运行期间必须知道异常的确切类型</p></li></ul><h3 id="why"><a href="#why" class="headerlink" title="why"></a>why</h3><p>编写用于多种类型的代码。</p><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>前面的其实都还好理解，到了这里就有点要想想了，不然傻傻分不清楚。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?&gt;</span><br><span class="line">&lt;? extends E&gt; <span class="comment">//这个E一般就代表声明出来的类型参数。指代你声明&lt;E&gt;</span></span><br><span class="line">&lt;? <span class="keyword">super</span> E&gt;</span><br></pre></td></tr></table></figure><h4 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h4><p>还是看栗子把2333</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> learn2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericTest2 test2 = <span class="keyword">new</span> GenericTest2();</span><br><span class="line">        List&lt;String&gt; stringList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        stringList.add(<span class="string">"aaa"</span>);</span><br><span class="line">        stringList.add(<span class="string">"bbb"</span>);</span><br><span class="line">        stringList.add(<span class="string">"ccc"</span>);</span><br><span class="line">        List&lt;Integer&gt; integerList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        integerList.add(<span class="number">1</span>);</span><br><span class="line">        integerList.add(<span class="number">2</span>);</span><br><span class="line">        integerList.add(<span class="number">3</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ?任意</span></span><br><span class="line">        test2.runTest(stringList);</span><br><span class="line">        test2.runTest(integerList);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//上界为Number</span></span><br><span class="line">        List&lt;Long&gt; longList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        test2.runTest2(longList, <span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//下界Number</span></span><br><span class="line">        List&lt;Object&gt; objectList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        test2.runTest3(objectList, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runTest</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;<span class="comment">//可以接受任意泛型参数的List</span></span><br><span class="line">        list.add(<span class="keyword">null</span>);<span class="comment">//只能写null</span></span><br><span class="line"><span class="comment">//        list.add(new Object());// error</span></span><br><span class="line">        System.out.println(list.get(<span class="number">3</span>).getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runTest2</span><span class="params">(List&lt;? extends Number&gt; list, Number number2)</span> </span>&#123;<span class="comment">//只能接受泛型参数继承Number的List</span></span><br><span class="line">        Number number = list.get(<span class="number">0</span>);<span class="comment">// 只可以读Number类型</span></span><br><span class="line">        <span class="comment">//list.add(new Object());//写不了</span></span><br><span class="line">        <span class="comment">//list.add(number2);//编译不通过</span></span><br><span class="line">        <span class="comment">//list.add(number);//编译不通过</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runTest3</span><span class="params">(List&lt;? <span class="keyword">super</span> Number&gt; list, Number number)</span> </span>&#123;<span class="comment">//只能接受泛型参数为Number父类的List</span></span><br><span class="line">        list.add(number);<span class="comment">//可以写Number类型</span></span><br><span class="line">        <span class="comment">//list.add(new Object()); 不行</span></span><br><span class="line">        Object object = list.get(<span class="number">0</span>);<span class="comment">//只能捕获为Object</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分析一波"><a href="#分析一波" class="headerlink" title="分析一波"></a>分析一波</h4><ul><li><p><code>&lt;?&gt;</code>这个统配符代表，可以接受任意泛型参数，与之同时，对应的<code>List&lt;?&gt; list</code> 可以接受<code>List&lt;Number&gt;</code> <code>List&lt;String&gt;</code>对象等等，所以嘞，它也就根本不知道实际对象会是带什么泛型参数，所以只能<strong>写<code>null</code></strong>，我没想到的是居然<strong>写Object</strong>也不行，读还是的啊，但是只能为Object，没事啊，你可动态的<code>instance of</code>判断下嘛，写死转换肯定是不行的，因为它压根啥也不知道，咱也不敢问是吧。</p></li><li><p><code>&lt;? extends E&gt;</code>这个通配符代表了，可以接受带上界为E泛型参数。即你的泛型参数得是E或E的子类才行</p><p>List&lt;? extends Number&gt; list这个能能接受<code>List&lt;Int&gt;</code> <code>List&lt;Long&gt;</code>等等为Number的子类泛型参数 。可能有人会觉得有了上界那不为所欲为。我以前也是这么觉得的哈哈。上述实践得知，只<code>能写为E</code>，<code>不能读为E</code>，当然能读为Object。因为它知道你传进来的肯定是带E后代泛型，所以呢，我里面的元素肯定能表现为E，所以读是没问题。但是写E就有问题了，比如我某一次识别的到是Long，然后你要写一个Number，你说怎么能写。</p></li><li><p><code>&lt;? super E&gt;</code> 这个就刚好了上面那个相反，E为下界，可以接受E父类等泛型参数。对于这个而言，就只<code>能写E</code>，<code>不能读E</code> ，你的泛型参数为超类，你压根不知到内容表现为具体是个啥东西，所以读就别想了。但是E可以表现为超类，所以写E就没问题咯。</p></li></ul><p>总结下来就是：</p><p>&lt;?&gt; 可以匹配任何泛型参数，但是只能写null</p><p>&lt;? extends E&gt; 可以匹配E的子类泛型参数，只能读E，不能写E</p><p>&lt;? super E&gt; 可以匹配E的超类泛型参数，不能读E，只能写E</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>其实泛型这个东西呢，以前我想的太简单了，传个类型参数就完事了，以前我也是这么认为的，但是看了《Java编程思想》，卧槽还有这么多东西，而且稍稍不深入就会被带跑偏呃呃。目前还是归纳的不够详细，以后学到再补充！✌，对了想不通的地方，没事一定要敲一敲，比瞎想强，总有好处的。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 并发梳理</title>
      <link href="/2019/07/01/Java-%E5%B9%B6%E5%8F%91/"/>
      <url>/2019/07/01/Java-%E5%B9%B6%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<p>Java 并发</p><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>what：cpu调度的最小单位</p><p>创建方式：</p><ul><li>继承Thread，实现重写run方法，创建Thread对象，调用start方法。</li><li>实现Runnable，实现run方法，创建Runnable对象，传入Thread对象，调用start方法</li><li>后文的中Callable</li></ul><p>线程的状态：新建，可执行，执行，阻塞，死亡</p><p><img src="/images/1561517414845.png" alt="1561517414845"></p><p>yield只是让出cpu的使用权，下次还有可能抢占cpu</p><p>调用其它线程的join，当前线程会阻塞，知道那个线程执行完毕。</p><h5 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h5><p>多线程访并发访问共享资源，会导致数据安全问题。</p><h6 id="synchronized-加悲观锁"><a href="#synchronized-加悲观锁" class="headerlink" title="synchronized 加悲观锁"></a>synchronized 加悲观锁</h6><p>通过synchronized添加锁，可以加载方法上和代码块上。在被锁起来的地方只会又一个线程进入，直到该代码执行完毕。该实现为jvm内置实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span>(obj)&#123;&#125;</span><br></pre></td></tr></table></figure><p>线程8锁问题：</p><p>synchronized锁需要看锁的对象是谁，线程需要锁对象为同一个的情况下，进入了锁区域另外的线程就必须等待。</p><ul><li>锁对象为普通对象</li><li>所对象为class对象，即在静态方法上加锁</li></ul><p>要根据具体锁对象来判断执行效果。持有同一锁对象，操作即为互斥。</p><h6 id="Lock-乐观锁"><a href="#Lock-乐观锁" class="headerlink" title="Lock 乐观锁"></a>Lock 乐观锁</h6><p>代码实现，需要手动释放锁，不然会造成死锁，需要在finally释放锁</p><p>有三个实现类</p><ul><li>ReentrantLock  可重入锁</li><li>ReadLock 读锁，通过new ReentrantReadWriteLock .readLock()获得</li><li>WriteLock写锁，通过new ReentrantReadWriteLock .writeLock()获得</li></ul><p>读写锁：读写互斥，写写互斥，读读共享</p><p><strong>Condition</strong></p><p>在synchronized锁下面，jvm提供了obect.wait,和notify，这两个通信是依赖synchronized关键字的，从等待池到锁池。而在Lock锁下与之对应线程通信的则是Condition对象，condition.await()进入等待和condition.sigal()唤醒</p><h6 id="Lock和synchronized的选择"><a href="#Lock和synchronized的选择" class="headerlink" title="Lock和synchronized的选择"></a>Lock和synchronized的选择</h6><p>　　总结来说，Lock和synchronized有以下几点不同：</p><p>　　1）Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；</p><p>　　2）synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；</p><p>　　3）Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；</p><p>　　4）通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。</p><p>　　5）Lock可以提高多个线程进行读操作的效率。</p><p>　　在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。</p><h6 id="锁的概念"><a href="#锁的概念" class="headerlink" title="锁的概念"></a>锁的概念</h6><p>　　<strong>1.可重入锁</strong></p><p>如果锁具备可重入性，则称作为可重入锁。像synchronized和ReentrantLock都是可重入锁，可重入性在我看来实际上表明了锁的分配机制：基于线程的分配，而不是基于方法调用的分配。举个简单的例子，当一个线程执行到某个synchronized方法时，比如说method1，而在method1中会调用另外一个synchronized方法method2，此时线程不必重新去申请锁，而是可以直接执行方法method2。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>synchronized和Lock都具备可重入性</p><p>​        <strong>2.可中断锁</strong></p><p>　　可中断锁：顾名思义，就是可以相应中断的锁。</p><p>　　在Java中，synchronized就不是可中断锁，而Lock是可中断锁。</p><p>　　如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，这种就是可中断锁。</p><p>　　在前面演示lockInterruptibly()的用法时已经体现了Lock的可中断性。</p><p>​        <strong>3.公平锁</strong></p><p>　　公平锁即尽量以请求锁的顺序来获取锁。比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该所，这种就是公平锁。</p><p>　　非公平锁即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或者一些线程永远获取不到锁。</p><p>　　在Java中，synchronized就是非公平锁，它无法保证等待的线程获取锁的顺序。</p><p>　　而对于ReentrantLock和ReentrantReadWriteLock，它默认情况下是非公平锁，但是可以设置为公平锁。</p><p><code>ReentrantLock lock = new</code> <code>ReentrantLock(true);</code></p><p>true 为公平，false为不公平</p><p>另外在ReentrantLock类中定义了很多方法，比如：</p><p>　　isFair()        //判断锁是否是公平锁</p><p>　　isLocked()    //判断锁是否被任何线程获取了</p><p>　　isHeldByCurrentThread()   //判断锁是否被当前线程获取了</p><p>　　hasQueuedThreads()   //判断是否有线程在等待该锁</p><p>　　在ReentrantReadWriteLock中也有类似的方法，同样也可以设置为公平锁和非公平锁。不过要记住，ReentrantReadWriteLock并未实现Lock接口，它实现的是ReadWriteLock接口。</p><p>​        <strong>4.读写锁</strong></p><h6 id="Volatile关键字"><a href="#Volatile关键字" class="headerlink" title="Volatile关键字"></a><strong>Volatile关键字</strong></h6><p>内存可见性是指当某个线程正在使用对象状态而另一个线程在同时修改该状态，需要确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。当多个线程进行操作共享数据时，可以保证内存中的数据可见。相较于 synchronized 是一种较为轻量级的同步策略</p><ol><li><p>volatile 不具备“互斥性”</p></li><li><p>volatile 不能保证变量的“原子性”</p></li></ol><h6 id="CAS算法-无锁算法"><a href="#CAS算法-无锁算法" class="headerlink" title="CAS算法 无锁算法"></a>CAS算法 无锁算法</h6><p>原子性操作问题，CAS是一种硬件对并发的支持，用于管理对共享数据的访问，CAS是一种无锁的非阻塞算法实现</p><p>1、原子变量：在java.util.concurrent.atomic包下提供了基本的原子变量</p><p>​    【1】Volatile保证内存可见性</p><p>​    【2】CAS算法保证数据变量的原子性</p><p>2、CAS算法实现CAS包含了三个操作变量：</p><p>​    【1】内存值V</p><p>​    【2】内存预估值A</p><p>​    【3】内存更新值B当且仅当V==A时，V=B；否则不会执行任何操作模拟CAS算法</p><h5 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h5><h6 id="基于synchronized-锁"><a href="#基于synchronized-锁" class="headerlink" title="基于synchronized 锁"></a>基于synchronized 锁</h6><p>wait：中断方法的执行，使本线程等待，暂时让出 cpu 的使用权，并允许其他线程使用这个同步方法。</p><p>notify：唤醒由于使用这个同步方法而处于等待线程的 某一个结束等待</p><p>notifyall：唤醒所有由于使用这个同步方法而处于等待的线程结束等待</p><p>锁池:假设线程A已经拥有了某个对象(注意:不是类)的锁，而其它的线程想要调用这个对象的某个synchronized方法(或者synchronized块)，由于这些线程在进入对象的synchronized方法之前必须先获得该对象的锁的拥有权，但是该对象的锁目前正被线程A拥有，所以这些线程就进入了该对象的锁池中。</p><p>等待池:假设一个线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁后，进入到了该对象的等待池中<br>所谓唤醒线程，另一种解释可以说是将线程由等待池移动到锁池，notifyAll调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而notify只会唤醒一个线程。</p><h6 id="基于Lock锁"><a href="#基于Lock锁" class="headerlink" title="基于Lock锁"></a>基于Lock锁</h6><p>从Lock中获得Condition，类似于上面的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> var1)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> var1, TimeUnit var3)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date var1)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><h5 id="what"><a href="#what" class="headerlink" title="what"></a>what</h5><p>维护了一些线程的队列，线程创建和销毁是非常消耗资源的。利用线程池来重用这些线程，提高了响应速度</p><p>降低 资源消耗</p><p>提高响应速度</p><p>提高线程的 可管理性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 一、线程池：提供了一个线程队列，队列中保存着所有等待状态的线程。避免了创建与销毁额外开销，提高了响应的速度。</span><br><span class="line"> * </span><br><span class="line"> * 二、线程池的体系结构：</span><br><span class="line"> * java.util.concurrent.Executor : 负责线程的使用与调度的根接口</span><br><span class="line"> * |--**ExecutorService 子接口: 线程池的主要接口</span><br><span class="line"> * |--ThreadPoolExecutor 线程池的实现类</span><br><span class="line"> * |--ScheduledExecutorService 子接口：负责线程的调度</span><br><span class="line"> * |--ScheduledThreadPoolExecutor ：继承 ThreadPoolExecutor， 实现 ScheduledExecutorService</span><br><span class="line"> * </span><br><span class="line"> * 三、工具类 : Executors </span><br><span class="line"> * ExecutorService newFixedThreadPool() : 创建固定大小的线程池</span><br><span class="line"> * ExecutorService newCachedThreadPool() : 缓存线程池，线程池的数量不固定，可以根据需求自动的更改数量。</span><br><span class="line"> * ExecutorService newSingleThreadExecutor() : 创建单个线程池。线程池中只有一个线程</span><br><span class="line"> * </span><br><span class="line"> * ScheduledExecutorService newScheduledThreadPool() : 创建固定大小的线程，可以延迟或定时的执行任务。</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h5 id="how"><a href="#how" class="headerlink" title="how"></a>how</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">execute 执行任务</span><br><span class="line">submit 提交任务，并且返回Future</span><br><span class="line">shutDown 中止线程池，设置线程池状态为SHUTDOWN，中断没有运行的线程</span><br><span class="line">shtDownNow 中止线程池，设置线程池状态为SHUTDOWN， 尝试停止所有线程，并返回等待任务队列</span><br><span class="line">不同应用场景使用不同的配置线程</span><br><span class="line">任务的性质：CPU密集型任务、IO密集型任务和混合型任务</span><br><span class="line">任务的优先级：高、中和低</span><br><span class="line">任务的执行时间：长、中和短</span><br><span class="line">任务的依赖性：是否依赖其他系统资源，如数据库连接。</span><br><span class="line">CPU密集型任务</span><br><span class="line">应配置尽可能小的线程,配置</span><br><span class="line">N(CPU)+<span class="number">1</span>或者 N(CPU) * <span class="number">2</span></span><br><span class="line">I/O密集型任务</span><br><span class="line">业务读取较多,线程并不是一直在执行任务,则应配置尽可能多的线程</span><br><span class="line">N(CPU)/<span class="number">1</span> - 阻塞系数(<span class="number">0.8</span>~<span class="number">0.9</span>)</span><br><span class="line">混合型的任务,如果可以拆分,将其拆分成一个CPU密集型任务和一个IO密集型任务,只要这两个任务执行的时间相差不是太大,那么分解后执行的吞吐量将高于串行执行的吞吐量.如果这两个任务执行时间相差太大,则没必要进行分解.</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>关于线程池构造方法参数说明：</p><p>corePoolSize 核心线程数量</p><p>maximumPoolSize 最大线程数量</p><p>keepAliveTime 存活时间</p><p>TimeUnit 时间单位</p><p>workQueue 等待队列</p><h5 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h5><ul><li>AbortPolicy：丢弃任务，抛出 RejectedExecutionException</li><li>CallerRunsPolicy:只用调用者所在线程来运行任务,有反馈机制，使任务提交的速度变慢）。</li><li>DiscardOldestPolicy<br>若没有发生shutdown,尝试丢弃队列里最近的一个任务,并执行当前任务, 丢弃任务缓存队列中最老的任务，并且尝试重新提交新的任务</li><li>DiscardPolicy:不处理,丢弃掉, 拒绝执行，不抛异常<br>当然,也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略.如记录日志或持久化存储不能处理的任务  </li></ul><p>一个任务被提交到线程池中，首先会去检查核心线程是否达最大，如果没有则创建新线执行任务，如果核心线程达最大且都在执行任务，下一步将会去判断任务队列是否满，如果没有满则入队列等待，如果满了则创建新的线程，此时线程池最大能达到的线程数量即为最大线程数，当任务执行完毕，线程空闲之后等待存活时间后就会杀死线程。知道线程数量维持在核心线程数量。</p><p>这样就好比如一个工厂本来又四个人在工作，但是订单增加了，但是能工厂负责人认为工人还能承受住，于是就将累计的订单来排队，时间一长还是能完成，但是随着订单的增加，工厂的排队已经排不下了。工厂负责人招了了一些了临时工参与工作，随着时间推移订单还在增加，此时排队满了，工人工作的位置也满了。此时工厂负责人就要考虑使用那种策略来对待新的订单。当订单减少了，临时工没事做了，此时工厂负责人为了成本考虑，就要撤下临时工了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c = ctl.get();</span><br><span class="line"><span class="comment">//工作任务小于核心线程数</span></span><br><span class="line"><span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">    <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))<span class="comment">//创建线程</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    c = ctl.get();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//大于核心线程数，尝试入工作队列</span></span><br><span class="line"><span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">    <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">        reject(command);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;<span class="comment">//入队列失败，尝试新增线程，此时线程数即将大于核心线程，但是要小于最大线程数</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">    reject(command);<span class="comment">//达到最大线程数，采取拒绝策略</span></span><br></pre></td></tr></table></figure><h5 id="关于获取Worker"><a href="#关于获取Worker" class="headerlink" title="关于获取Worker"></a>关于获取Worker</h5><p>线程池维持一个Worker的HashSet，Work本身也是一个Runnable，内部包含了一个第一个任务，和一个Thread对象（线程），也就是一个work持有一个线程。这个线程在addWorker成功时，会去开启线程。也就是调用线程池外围的runWorker方法。从这里就开始进入worker的线程任务了，在线程中开启while循环去获得Task，Task的获得同样时循环去阻塞队列拿runnable。如果工作队列空了，拿取超时，则会去减少Worker数量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.....</span><br><span class="line">//Worker类</span><br><span class="line">Worker(Runnable firstTask) &#123;</span><br><span class="line">            setState(-1); // inhibit interrupts until runWorker</span><br><span class="line">            this.firstTask = firstTask;</span><br><span class="line">            this.thread = getThreadFactory().newThread(this);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /** Delegates main run loop to outer runWorker. */</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            runWorker(this);</span><br><span class="line">        &#125;</span><br><span class="line">....</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//addWorke方法 </span></span><br><span class="line">w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">            <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">                mainLock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                    <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                    <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                    <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                        (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                        workers.add(w);</span><br><span class="line">                        <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                        <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                            largestPoolSize = s;</span><br><span class="line">                        workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    mainLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                    t.start();</span><br><span class="line">                    workerStarted = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//runThis方法</span></span><br><span class="line"><span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                w.lock();</span><br><span class="line">                <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">                <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">                <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">                <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">                <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                     (Thread.interrupted() &amp;&amp;</span><br><span class="line">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                    !wt.isInterrupted())</span><br><span class="line">                    wt.interrupt();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    beforeExecute(wt, task);</span><br><span class="line">                    Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        task.run();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        afterExecute(task, thrown);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="keyword">null</span>;</span><br><span class="line">                    w.completedTasks++;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">               decrementWorkerCount();</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">           <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">               &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">               <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://www.nowcoder.com/discuss/152050?type=0&amp;order=0&amp;pos=6&amp;page=0" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/152050?type=0&amp;order=0&amp;pos=6&amp;page=0</a></p><h4 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h4><h5 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h5><p>参考：<a href="https://blog.csdn.net/yudiandemingzi/article/details/82318390" target="_blank" rel="noopener">https://blog.csdn.net/yudiandemingzi/article/details/82318390</a></p><p>内部基于Lock锁的通信实现等待阻塞。</p><h5 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h5><p>ConcurrentMap</p><p>CopyOnWriteList</p><h5 id="原子变量"><a href="#原子变量" class="headerlink" title="原子变量"></a>原子变量</h5><p>硬件级别实现，普通变量int进行自增时，在jvm表现看来，这不是一个原子操作，所以线程就有可能打断，从而造成数据安全问题。</p><p>而原子变量通过使用volatile来保证内存可见性以及通过cas算法保证原子性。</p><h5 id="CountDownLatch-闭锁"><a href="#CountDownLatch-闭锁" class="headerlink" title="CountDownLatch 闭锁"></a>CountDownLatch 闭锁</h5><p>也可以叫倒计数器</p><p>what:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建计数为10的闭锁</span></span><br><span class="line">CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//计数减一</span></span><br><span class="line">countDownLath.countDown();</span><br><span class="line"><span class="comment">//线程等待,直到计数为0</span></span><br><span class="line">countDownLath.await();</span><br></pre></td></tr></table></figure><p>在线程完成某项操作之前它允许让一个或多个线程进行等待。倒计数，在内部计数到零之前，所调用countDownLatch.await的线程会等待，直到计数到达0为止。 </p><p>how:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> learn2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CountDownLatchTest test = <span class="keyword">new</span> CountDownLatchTest();</span><br><span class="line">        test.runTest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Main is waiting."</span>);</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Main is over"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CountDownLatch countDownLatch;</span><br><span class="line"></span><br><span class="line">    Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Current Thred is "</span> + Thread.currentThread().getId() + <span class="string">",print : "</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">Main is waiting.</span><br><span class="line">Current Thred is <span class="number">12</span>,print : <span class="number">0</span></span><br><span class="line">Current Thred is <span class="number">13</span>,print : <span class="number">0</span></span><br><span class="line">Current Thred is <span class="number">12</span>,print : <span class="number">1</span></span><br><span class="line">Current Thred is <span class="number">13</span>,print : <span class="number">1</span></span><br><span class="line">Current Thred is <span class="number">12</span>,print : <span class="number">2</span></span><br><span class="line">Current Thred is <span class="number">12</span>,print : <span class="number">3</span></span><br><span class="line">Current Thred is <span class="number">12</span>,print : <span class="number">4</span></span><br><span class="line">Current Thred is <span class="number">12</span>,print : <span class="number">5</span></span><br><span class="line">Current Thred is <span class="number">13</span>,print : <span class="number">2</span></span><br><span class="line">Current Thred is <span class="number">12</span>,print : <span class="number">6</span></span><br><span class="line">Current Thred is <span class="number">13</span>,print : <span class="number">3</span></span><br><span class="line">Current Thred is <span class="number">12</span>,print : <span class="number">7</span></span><br><span class="line">Current Thred is <span class="number">13</span>,print : <span class="number">4</span></span><br><span class="line">Current Thred is <span class="number">12</span>,print : <span class="number">8</span></span><br><span class="line">Current Thred is <span class="number">13</span>,print : <span class="number">5</span></span><br><span class="line">Current Thred is <span class="number">13</span>,print : <span class="number">6</span></span><br><span class="line">Current Thred is <span class="number">12</span>,print : <span class="number">9</span></span><br><span class="line">Current Thred is <span class="number">13</span>,print : <span class="number">7</span></span><br><span class="line">Current Thred is <span class="number">13</span>,print : <span class="number">8</span></span><br><span class="line">Current Thred is <span class="number">13</span>,print : <span class="number">9</span></span><br><span class="line">Main is over</span><br></pre></td></tr></table></figure><h5 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h5><p>What：栅栏，类似于闭锁，但是呢，闭锁是等待事件，即线程等待到countDown数量为0为止。而栅栏则是，线程到达栅栏开始等待，知道所有线程都达到栅栏了，就不在等待。而且闭锁使用一次，栅栏可以重置，继续使用。</p><blockquote><p>书上是这么说的：你希望创建一组任务，使他们并行执行，然后下一个步骤之前等待，直到所有任务完成，它使得所有并行任务在栅栏处排队，因此可以一致的向前移动。</p></blockquote><p>How：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line">CyclicBarrier(<span class="keyword">int</span> parties);<span class="comment">//parties 表示会有多少到达的栅栏的线程</span></span><br><span class="line">CyclicBarrier(<span class="keyword">int</span> parties, Runnable barrierAction);<span class="comment">//barrierAction 所有线程到达栅栏，会触发</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//关键方法</span></span><br><span class="line">await();<span class="comment">//某线程到达栅栏，并且等待，知道所有线程都到达栅栏</span></span><br><span class="line">reset();<span class="comment">//重置栅栏到初始状态</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> learn2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CyclicBarrierTest test = <span class="keyword">new</span> CyclicBarrierTest();</span><br><span class="line">        test.runTest();</span><br><span class="line">    &#125;</span><br><span class="line">    CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(runnable, <span class="string">"thread "</span> + i);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"for is over"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Runnable runnable = () -&gt; &#123;</span><br><span class="line">        System.out.println( Thread.currentThread().getName() + <span class="string">" waited"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cyclicBarrier.await();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" wake up"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//outputs 大概就是这个效果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> is over</span><br><span class="line">thread <span class="number">2</span> waited</span><br><span class="line">thread <span class="number">1</span> waited</span><br><span class="line">thread <span class="number">3</span> waited</span><br><span class="line">thread <span class="number">0</span> waited</span><br><span class="line">thread <span class="number">4</span> waited</span><br><span class="line">thread <span class="number">4</span> wake up</span><br><span class="line">thread <span class="number">1</span> wake up</span><br><span class="line">thread <span class="number">0</span> wake up</span><br><span class="line">thread <span class="number">3</span> wake up</span><br><span class="line">thread <span class="number">2</span> wake up</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h5 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h5><p>What：目前的Runnable执行方式是无法返回数据的。使用Callable创建线程以及配合FutureTask使用</p><p>FurtureTask.get时会所在线程锁等FurtureTask执行完毕</p><p>How：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 一、创建执行线程的方式三：实现 Callable 接口。 相较于实现 Runnable 接口的方式，方法可以有返回值，并且可以抛出异常。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 二、执行 Callable 方式，需要 FutureTask 实现类的支持，用于接收运算结果。  FutureTask 是  Future 接口的实现类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCallable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadDemo td = <span class="keyword">new</span> ThreadDemo();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.执行 Callable 方式，需要 FutureTask 实现类的支持，用于接收运算结果。</span></span><br><span class="line">        FutureTask&lt;Integer&gt; result = <span class="keyword">new</span> FutureTask&lt;&gt;(td);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(result).start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.接收线程运算后的结果</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Integer sum = result.get();  <span class="comment">//FutureTask 可用于 闭锁</span></span><br><span class="line">            System.out.println(sum);</span><br><span class="line">            System.out.println(<span class="string">"------------------------------------"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h5><h5 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h5><h5 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h5><p>What：继承自AbstractExecutorService，是一种特殊的线程池，通过分治法来分拆合并任务，使用有限的线程进行处理任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"><span class="keyword">import</span> java.time.Instant;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinTask;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.LongStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestForkJoinPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Instant start = Instant.now();</span><br><span class="line"></span><br><span class="line">ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line"></span><br><span class="line">ForkJoinTask&lt;Long&gt; task = <span class="keyword">new</span> ForkJoinSumCalculate(<span class="number">0L</span>, <span class="number">50000000000L</span>);</span><br><span class="line"></span><br><span class="line">Long sum = pool.invoke(task);</span><br><span class="line"></span><br><span class="line">System.out.println(sum);</span><br><span class="line"></span><br><span class="line">Instant end = Instant.now();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"耗费时间为："</span> + Duration.between(start, end).toMillis());<span class="comment">//166-1996-10590</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">Instant start = Instant.now();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> sum = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0L</span>; i &lt;= <span class="number">50000000000L</span>; i++) &#123;</span><br><span class="line">sum += i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(sum);</span><br><span class="line"></span><br><span class="line">Instant end = Instant.now();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"耗费时间为："</span> + Duration.between(start, end).toMillis());<span class="comment">//35-3142-15704</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//java8 新特性</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">Instant start = Instant.now();</span><br><span class="line"></span><br><span class="line">Long sum = LongStream.rangeClosed(<span class="number">0L</span>, <span class="number">50000000000L</span>)</span><br><span class="line"> .parallel()</span><br><span class="line"> .reduce(<span class="number">0L</span>, Long::sum);</span><br><span class="line"></span><br><span class="line">System.out.println(sum);</span><br><span class="line"></span><br><span class="line">Instant end = Instant.now();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"耗费时间为："</span> + Duration.between(start, end).toMillis());<span class="comment">//1536-8118</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ForkJoinSumCalculate</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">259195479995561737L</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> start;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> end;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> THURSHOLD = <span class="number">10000L</span>;  <span class="comment">//临界值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ForkJoinSumCalculate</span><span class="params">(<span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.start = start;</span><br><span class="line"><span class="keyword">this</span>.end = end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> length = end - start;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(length &lt;= THURSHOLD)&#123;</span><br><span class="line"><span class="keyword">long</span> sum = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">sum += i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">long</span> middle = (start + end) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">ForkJoinSumCalculate left = <span class="keyword">new</span> ForkJoinSumCalculate(start, middle); </span><br><span class="line">left.fork(); <span class="comment">//进行拆分，同时压入线程队列</span></span><br><span class="line"></span><br><span class="line">ForkJoinSumCalculate right = <span class="keyword">new</span> ForkJoinSumCalculate(middle+<span class="number">1</span>, end);</span><br><span class="line">right.fork(); <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> left.join() + right.join();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 反射</title>
      <link href="/2019/07/01/Java-%E5%8F%8D%E5%B0%84/"/>
      <url>/2019/07/01/Java-%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<p>Java 反射</p><ul><li>类加载器</li><li>反射</li><li>动态代理</li></ul><p>what：在运行时加载某个类，获得某个类的相关信息，以及进行操作。</p><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>what:用于将节字码文件加载到JVM</p><ul><li>启动类加载器：bootstrap，c++编写，jvm自带，负责加载rt.jar（runtime），无法直接获取，它是所有类加载器的父加载器</li><li>扩展类加载器：extension ，jdk_home/lib/ext目录下的jar包或者 -D java.ext.dirs指定目录下的jar包装入工作库</li><li>System ClassLoader ：负责java -classpath或者-D java.class.path所指目录 下的类和jar包装入</li></ul><p>委托、可见性以及单一性原理</p><p>委托:即子加载器会请求父加载器是否加载,并且加载,如果不能加载就交会子加载器,即自下而上请求,自上而下加载.</p><p>可见性: 子类加载器可以看到父类加载器加载的类，而反之则不行</p><p>单一性: 父加载器加载过的类不能被子加载器加载第二次</p><h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><p>what：<strong>运行</strong>时获得类信息，注意是运行时。</p><p>Class：字节码在jvm存在形式即为Class的对象，是由jvm创建的。</p><ul><li><p>运行时构造任意一个对象</p></li><li><p>运行取得任意一个类所拥有成员变量和方法</p></li><li><p>运行时获得任意对象的方法属性</p></li><li><p>动态代理</p></li></ul><p>how：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"全类名"</span>);</span><br><span class="line">Class clazz = SomeClass.class;</span><br><span class="line">Class clazz = someClassObj.getClass();</span><br></pre></td></tr></table></figure><p>相关操作：可以拿到以下的信息</p><p>Constructor：getConstructor， getContructors</p><p>Method：getMethods（继承链上public的），getDeclareMethods（当前类声明的所有）</p><p>Field：getFields（继承链上public），getDeclareFields（当前类声明所有）</p><p>Annotation：getAnnotation，getDeclareAnnotaions(),getParameterAnnotations() </p><p>以及newInstance去创建对象</p><p>invoke去调用方法</p><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Boy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Boy</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打印"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Boy boy = <span class="keyword">new</span> Student();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boy <span class="title">getProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Boy) Proxy.newProxyInstance(boy.getClass().getClassLoader(), boy.getClass().getInterfaces(), <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"我是代理"</span>);</span><br><span class="line">                <span class="keyword">return</span> method.invoke(boy,args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 注解</title>
      <link href="/2019/07/01/Java-%E6%B3%A8%E8%A7%A3/"/>
      <url>/2019/07/01/Java-%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><strong>注解</strong></p><p>what：用于描述数据，并且可以被编译期以及jvm捕获的信息</p><ul><li>注解基本使用</li><li>运行时处理注解</li><li>编译处理注解</li><li>其它用处</li></ul><h3 id="注解基本使用"><a href="#注解基本使用" class="headerlink" title="注解基本使用"></a>注解基本使用</h3><p>how：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="meta">@interface</span> One&#123;</span><br><span class="line">    <span class="comment">//类似方法声明的方式来声明属性</span></span><br><span class="line">     <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="meta">@One</span>(name = <span class="string">"fdaf"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//基本注解</span></span><br><span class="line"><span class="meta">@Overrider</span> 描述限定重现父类方法</span><br><span class="line"><span class="meta">@Deprecated</span> 描述某个类或方法过时</span><br><span class="line"><span class="meta">@SupressWarnings</span> 抑制编译期警告</span><br></pre></td></tr></table></figure><p>元注解：描述注解的注解，用于限定注解的行为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span> 描述注解将注解的位置。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ElementType &#123;</span><br><span class="line">    TYPE, <span class="comment">//类，接口，注解，枚举</span></span><br><span class="line">    FIELD,<span class="comment">//属性</span></span><br><span class="line">    METHOD,<span class="comment">//方法</span></span><br><span class="line">    PARAMETER,<span class="comment">//参数</span></span><br><span class="line">    CONSTRUCTOR,<span class="comment">//构造方法</span></span><br><span class="line">    LOCAL_VARIABLE,<span class="comment">//局部变量</span></span><br><span class="line">    ANNOTATION_TYPE,<span class="comment">//注解</span></span><br><span class="line">    PACKAGE,<span class="comment">//包</span></span><br><span class="line">    TYPE_PARAMETER,<span class="comment">//Type parameter declaration</span></span><br><span class="line">    TYPE_USE<span class="comment">//Use of a type</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Retention</span> </span><br><span class="line">以下三种</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RetentionPolicy &#123;</span><br><span class="line">    SOURCE,</span><br><span class="line">    CLASS,</span><br><span class="line">    RUNTIME</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Documented</span> 表示可以被javadoc工具提取成文档</span><br><span class="line"><span class="meta">@Inherited</span> 表示继承性，如果某个使用了该注解修饰的注解，那么其子类会自动具有该注解</span><br></pre></td></tr></table></figure><p>通过注解在相应的位置，我们可以在下面的注解处理器，或者反射处理，获得到我们想要的得到的数据。这就是注解的任务啦。</p><h3 id="运行处理注解"><a href="#运行处理注解" class="headerlink" title="运行处理注解"></a>运行处理注解</h3><p>通过反射获得Class对象，Method等等，从而通过getAnnotation继而获得值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> learn2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationTest test = <span class="keyword">new</span> AnnotationTest();</span><br><span class="line">        test.test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TestAnnotation</span>(msg = <span class="string">"test"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> someOne;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Class clazz = getClass();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field field = clazz.getField(<span class="string">"someOne"</span>);</span><br><span class="line">            String msg = field.getAnnotation(TestAnnotation.class).msg();</span><br><span class="line">            System.out.println(field.getAnnotation(TestAnnotation.class));</span><br><span class="line">            System.out.println(msg);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line">    <span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line">    <span class="meta">@interface</span> TestAnnotation&#123;</span><br><span class="line">        <span class="function">String <span class="title">msg</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编译处理注解"><a href="#编译处理注解" class="headerlink" title="编译处理注解"></a>编译处理注解</h3><p>编译时处理注解，生成java文件</p><h3 id="处理注解时的相关类和API"><a href="#处理注解时的相关类和API" class="headerlink" title="处理注解时的相关类和API"></a>处理注解时的相关类和API</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//接口</span><br><span class="line">AnnotatedElement // 被注解的元素，这个接口声明的方法包含了一些获得注解注解对象的方法</span><br><span class="line">AnnotatedType //被注解的类型，有一个getType的方法//这些接口都从1.8开始的，感觉和泛型相关</span><br><span class="line">AnnotatedArrayType //被注解的数组类型</span><br><span class="line">AnnotatedParameterizedType//被注解的参数化类型 </span><br><span class="line">AnnotatedTypeVariable//被注解的类型变量</span><br><span class="line">AnnotatedWildcardType//被注解的统配符类型 获取上界和下界的AnnotatedType</span><br><span class="line">//类</span><br><span class="line">Filed</span><br><span class="line">Class</span><br><span class="line">Method</span><br><span class="line">Package</span><br><span class="line">Construcotr</span><br><span class="line">Paramter</span><br><span class="line">Executable</span><br><span class="line">AccessibleObject</span><br><span class="line"></span><br><span class="line">注解一个普通的int产生的AnnotatedType对象是sun.reflect.annotation.AnnotatedTypeFactory$AnnotatedTypeBaseImpl@1d44bcfa</span><br><span class="line">而注解List&lt;String&gt; list类型产生的的AnnotatedType对象是sun.reflect.annotation.AnnotatedTypeFactory$AnnotatedParameterizedTypeImpl@1d44bcfa</span><br><span class="line">而对int[] list 产生的是</span><br><span class="line">sun.reflect.annotation.AnnotatedTypeFactory$AnnotatedArrayTypeImpl@1d44bcfa</span><br><span class="line">与之对应的是那几个接口的实现类，虽然我没搞懂有啥用。。</span><br></pre></td></tr></table></figure><h3 id="其它用处"><a href="#其它用处" class="headerlink" title="其它用处"></a>其它用处</h3><p>用于设定常量</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 容器</title>
      <link href="/2019/06/30/Java-%E5%AE%B9%E5%99%A8/"/>
      <url>/2019/06/30/Java-%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="Java-容器"><a href="#Java-容器" class="headerlink" title="Java  容器"></a>Java  容器</h3><ul><li>List</li><li>Set</li><li>Map</li><li>Queue</li><li>Iterator</li><li>工具类</li><li>并发容器</li><li>android中的特殊集合</li></ul><h4 id="相关接口"><a href="#相关接口" class="headerlink" title="相关接口"></a>相关接口</h4><ul><li><p>Iterable 代表可迭代，实现的方法需要产出一个迭代器</p></li><li><p>Collection 除了Map外的祖先集合接口</p></li><li><p>List</p></li><li><p>Set</p></li><li><p>Map</p><p>Set 和 List都是一路继承Collection下来</p><p>Map则是单独的</p></li></ul><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p>定义了以套通过索引进行获取，和添加的集合</p><ul><li>ArrayList     内部是一个动态扩容的数组实现。</li><li>LinkedList   内部是一个双向链表实现</li><li>Vector 内部也是动态扩容的数组实现，不过大部分方法通过synchronized进行锁住方法，是线程安全的，但是效率不高。</li><li>Stack Vector的子类</li></ul><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>定义了一组不可重复的集合，通过哈希值来判断</p><ul><li>HashSet 内部是通过一个HashMap来实现，等同于HashMap的键，值恒为同一个Object</li><li>TreeSet 内部是通过一个TreeMap来实现</li></ul><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>定义了通过键值映射的集合</p><ul><li>HashMap 内部通过 数组 + 链表 + 红黑树进行实现的Map</li><li>TreeMap  内部通过红黑树进行实现，保持内部排序顺序</li><li>HashTable 古老实现，线程安全，效率不高</li><li>Properties key和value都是String类型</li></ul><h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><p>队列</p><h4 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h4><p>生成器，用于foreach循环</p><h4 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h4><ul><li>Arrays包含了许多对数组进行排序，复制等操作的工具类</li><li>Collections包含许多对集合进行操作</li><li>Comparators包含对比较器的工具</li></ul><h4 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h4><p>以上中只有Vectoer和HashTable是线程安全的，但是它是将整个集合都锁住了，效率不高。</p><ul><li>CopyOnWriteArryList</li><li>CopyOnWriteArraySet 写时复制，在写入的时候创建一个副本进行写入，当迭代多于修改，应该使用写时复制容器</li><li>ConcurrentHashMap </li><li>ConcurrentSkipListSet </li><li>阻塞队列</li></ul><p>ConcurrentMap容器:1.8以前采用锁分段技术，1.8开始使用CAS无锁技术。</p><h4 id="android中特殊容器"><a href="#android中特殊容器" class="headerlink" title="android中特殊容器"></a>android中特殊容器</h4><p>SparseArray 使用稀疏数组实现的一个key为int，value为Object的集合</p><p>LongSparseArray key为long value为object</p><p>SparseLongArray key为int value为long</p><p>SparseBooleanArray key为int value为boolean</p><p>SparseIntArray key为int value为int</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 基础知识梳理</title>
      <link href="/2019/06/30/Java-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"/>
      <url>/2019/06/30/Java-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="Java-基础内容"><a href="#Java-基础内容" class="headerlink" title="Java  基础内容"></a>Java  基础内容</h3><ul><li>数据类型</li><li>运算符</li><li>流程控制</li><li>面向对象</li><li>重要关键字</li><li>异常</li><li>编码</li><li>Object类</li></ul><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>计算机中最小的单位是bit，一个位0/1表示</p><h5 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h5><ul><li><p>byte  1字节 </p></li><li><p>short 2字节 </p></li><li><p>int  4字节</p></li><li><p>long 8字节</p></li><li><p>float 4字节</p></li><li><p>double 8字节</p></li><li><p>boolean 1字节</p></li><li><p>char 2字节 可以为unicode编码，位于栈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a = <span class="string">'\u1233'</span>;<span class="comment">//unicode编码表达</span></span><br></pre></td></tr></table></figure></li></ul><p>引用数据类型：引用位于栈，引用的对象位于堆</p><p>高精度向低精度可能丢失，表达式中默认转换为当前表达式的最大精度进行计算</p><h5 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h5><ul><li>基础运算符</li><li>instanceof 用于判断对象是否是某类型</li></ul><h4 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h4><ul><li><p>if else</p></li><li><p>if elseif </p></li><li><p>while</p></li><li><p>do while</p></li><li><p>for</p></li><li><p>foreach 需要容器实现Iterable接口和Iterator接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(SomeType obj: objList) &#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><p>关键字extends，类的继承和接口的继承</p><h5 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h5><p>访问控制private，default，protected，public</p><h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h5><p>通过父类或者接口引用访问实际对象的方法，称为动态绑定，实在运行时才能决定的。</p><h5 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h5><p>静态绑定，即同名方法存在不同的参数列表（类型，数量）</p><h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><p>成员和方法修饰为public ，实现的类需要实现方法，与接口间可以继承。只有声明，但是新版jdk可以存在默认方法，使用default定义</p><h5 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h5><p>匿名内部类，默认持有外部类this引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只是将匿名内部类复制给了一个引用，其实再参数传递中的内部类，同样也是将匿名内部类对象传递给了，临时的引用。</span></span><br><span class="line">   <span class="comment">//方法实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    B b = <span class="keyword">new</span> B()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成员内部类，默认持有外部类this引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        B b = a.new B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态内部类，不会持有外部引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class A&#123;</span><br><span class="line"><span class="keyword">static</span> B&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">B b = <span class="keyword">new</span> A.B();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部类可以和成员一样访问外部类的成员。</p><p>匿名内部类对象在访问方法参数，参数需要定义为final，因为在方法中一旦一开，参数的生命周期也就结束了，但是匿名内部类对象还引用着，通过使用final来拷贝一份使用，间接的延长了生命周期，也就可以正常访问了。</p><h5 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h5><ul><li>强引用 只要持有强引用，JVM宁可抛出内存泄漏也不愿意去回收</li><li>软引用 在没有强引用的情况下且内存不足情况下会去回收对象</li><li>弱引用 在没有强引用的情况下回去回收对象</li><li>虚引用 形同虚设，常用于jvm内部跟踪垃圾回收过程</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你好, Hexo</title>
      <link href="/2019/06/29/%E4%BD%A0%E5%A5%BD-Hexo/"/>
      <url>/2019/06/29/%E4%BD%A0%E5%A5%BD-Hexo/</url>
      
        <content type="html"><![CDATA[<h3 id="你好，Hexo"><a href="#你好，Hexo" class="headerlink" title="你好，Hexo"></a>你好，Hexo</h3><h4 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h4><p>首先用hexo搭建博客还是蛮爽的，基本只需要配置加上写md文件即可，颜值高的我都想学前端了2333。最近我是想着准备找新工作了，但是呢，得复习知识，而我基本上又不怎么喜欢归纳知识，即使是归纳也只用印象笔记做做速记，所以我感觉自己很虚，太浮躁了。但是看别人得博客，他们怎么能写这么多呀！于是我觉得我得认真对待做笔记这件事了，写的博客不能像以前写速记似的。</p><p>抛开关于工作学习上事情，其实用博客来记录生活也很必要。</p><a id="more"></a><p>第一、我表达能力不过关，有时候后脑子可以想很多话语，但是落实到口头综合起来就不是一回事了，想法千奇百怪，转瞬即逝，综合到嘴巴说出来的就更少了。究其原因是我的语文水平驾驭不住这些意识，呃呃（比如现在2333），也就是俗称的看书看少了，写东西写少了。对于文字掌控能力，我感觉是其它很多技能的基础，所以咯，得做！</p><p>第二、 记忆对抗，现在我闭上眼睛，一周平平淡淡，竟然回忆不到太多事情，随着时间的推移，能留在我记忆中东西更是少之又少，甚至我得拼命回忆才能回想到曾今得同学以及生活得情。尽可能得通过博客来记录生活的轨迹。我不想过的虚无缥缈。</p><p>第三、写博客，是一次和自己对话的机会，试问有多久没有静下心来和自己对话了（其实就是反省2333）。</p><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><ul><li>坚持写</li><li>认真总结并写出技术类文章 （虽然目前写的东西是真的水，我会改善的！！）</li><li>有什么想法以及能记录一定要记录</li><li>待完善。。。</li></ul><p>明明在路上的时候还想了待会要写啥的，结果呃呃，这个字数和水平还不到一篇作文。shit，看吧，有多重要了。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/06/29/hello-world/"/>
      <url>/2019/06/29/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
