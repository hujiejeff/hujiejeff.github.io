<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>梳理一波Activity基础使用</title>
      <link href="/2019/07/03/Android-%E6%A2%B3%E7%90%86%E4%B8%80%E6%B3%A2Activity/"/>
      <url>/2019/07/03/Android-%E6%A2%B3%E7%90%86%E4%B8%80%E6%B3%A2Activity/</url>
      
        <content type="html"><![CDATA[<h2 id="what"><a href="#what" class="headerlink" title="what"></a>what</h2><p>首先初学android第一个学的绝逼是Activity，翻译为活动，即看的见，摸得着的玩意。android SDK提供了一套模板类即Activity，开发者需要继承它，并且在对的时间做相应的事情，比如UI初始化，数据加载等等，通过在Manifest文件中声明这个新的Activity就可以了。这次就先不探讨Activity是怎么工作的，从应用的角度来看看它，（AMS还得再学习学习2333）。</p><h2 id="how"><a href="#how" class="headerlink" title="how"></a>how</h2><p>无非就是创建类然后实现Activity，然后注册到Manifest中。可以了。</p><p>主要来看看Activity中重要的API吧。</p><h3 id="首先看看Activity继承结构。"><a href="#首先看看Activity继承结构。" class="headerlink" title="首先看看Activity继承结构。"></a>首先看看Activity继承结构。</h3><ul><li><p>AppCompatActivity ：目前来说默认AS创建的Activity继承自AppcompatActivity,直接意思兼容的Activity咯，支持ActionBar,同时对MD控件提供支持。</p></li><li><p>FragmentActivity：支持Fagment使用的Activity，因为3.0之前是没有Fragmnt，所以为了兼容引入。</p></li><li><p>Activity：原汁原味的。。</p></li></ul><h3 id="接着看看日常必须用得到方法"><a href="#接着看看日常必须用得到方法" class="headerlink" title="接着看看日常必须用得到方法"></a>接着看看日常必须用得到方法</h3><ul><li><p>生命周期方法，放在下面好了。</p></li><li><p>setSupportActionBar和getSupportActionBar，进去ToolBar,出来AcionBar,工具栏相关的者两个一定得用</p></li><li><p>onConfigurationChanged，配置发生改变，就会回调这里。再Manifest中activity的配置中要设定关心那些变化</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">""</span> <span class="attr">android:configChanges</span>=<span class="string">"orientation|keyboard"</span>/&gt;</span></span><br><span class="line">横竖屏切换，键盘等等</span><br></pre></td></tr></table></figure></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">onSaveInstanceState 和 onRestoreInstanceState 保存和恢复当前的某些状态和数据</span><br><span class="line">内存回收后重新创建Activty，可以传递Bundle</span><br><span class="line">onCreateOptionsMenu //创建menu的回调</span><br><span class="line">onOptionsItemSelected //设置响应menu事件的回调</span><br><span class="line">getMenuInflater //填充menu的填充器</span><br><span class="line">onRequestPermissionsResult //请求权限后处理结果的回调</span><br><span class="line">onBackPressed //按下返回回调</span><br><span class="line">onLowMemory //低内存回调</span><br><span class="line">onActivityResult //启动其它activity返回结果回调</span><br></pre></td></tr></table></figure></li></ul><p>好像列出来没什么软用。。</p><h3 id="Intent使用"><a href="#Intent使用" class="headerlink" title="Intent使用"></a>Intent使用</h3><p>能够定义Activity后，接着就是利用Intent进行页面的跳转了。Intent意为意图，在四大组件中基本都是利用Intent进行调用和传递。</p><p>Intent分为启动方和接受方，启动方发出Intent，接收方接收。完成跳转或启动，启动方需要给出Intent目标或方向，而接受方需要明确自己能接受什么Intent</p><p>首先Intent很干脆，就是一个Parcelable 和 Cloneable而已，Intent同样对应着Manifest文件intent-filter标签，代表当前组件能够响应什么样的意图</p><p>显式使用Intent进行跳转Activity：明确目标地点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Context from, Class&lt;? extends Activity&gt; to, Bundle bundle)</span> </span>&#123;</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(from, to);</span><br><span class="line">    <span class="keyword">if</span> (bundle != <span class="keyword">null</span>) &#123;</span><br><span class="line">        intent.putExtras(bundle);</span><br><span class="line">    &#125;</span><br><span class="line">    from.startActivity(intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>隐式使用Intent：不明确目标地点，但是能给出大致的方向。通过action，category，data三种隐式过滤，来搜寻目标。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.addCategory(String);<span class="comment">//可以多个</span></span><br><span class="line">intent.setAction(String);<span class="comment">//单个</span></span><br><span class="line">intent.setData(Uri);<span class="comment">//单个</span></span><br></pre></td></tr></table></figure><p>响应的一方可以设置多个Intent-filter</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.VIEW"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:host</span>=<span class="string">""</span> <span class="attr">android:mimeType</span>=<span class="string">""</span> <span class="attr">android:port</span>=<span class="string">""</span> <span class="attr">android:scheme</span>=<span class="string">""</span> <span class="attr">android:path</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure><p>携带数据</p><p>Intent可以携带基本数据类型，数组，Parcelable，Serializable，不爽的话直接Bundle打包。不过内部实现也是一起打包在Bundle中。</p><p>到了这里其实也能够做听过事了，不光能够自己应用内跳转，以及开启相机啊，相册，很多很多。</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="返回栈"><a href="#返回栈" class="headerlink" title="返回栈"></a>返回栈</h3><p>用于管理任务栈，新Activity入栈，finish出栈。</p><h3 id="活动状态"><a href="#活动状态" class="headerlink" title="活动状态"></a>活动状态</h3><ul><li>运行状态：activity位于栈顶</li><li>暂停状态：可见，不位于栈顶</li><li>停止状态：不可见，不位于栈顶</li><li>销毁状态：出栈</li></ul><h3 id="生命周期方法"><a href="#生命周期方法" class="headerlink" title="生命周期方法"></a>生命周期方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">onCreate<span class="comment">//设置Layout</span></span><br><span class="line">onStart<span class="comment">//可见</span></span><br><span class="line">onResume<span class="comment">//可见可交互</span></span><br><span class="line">onPause<span class="comment">//可见不可交互</span></span><br><span class="line">onStop<span class="comment">//不可见</span></span><br><span class="line">onDesotry<span class="comment">//销毁</span></span><br><span class="line">onRestart<span class="comment">//onStop恢复后会走</span></span><br></pre></td></tr></table></figure><p>生命周期方法对应了活动状态时的回调</p><h2 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a>启动模式</h2><p>指定Activity的启动模式，对应着<strong>android:launchMode</strong>属性</p><ul><li>Standard 标准模式，无论站内是否存在实例，都会创建新的</li><li>SingleTop 栈顶存在则不创建新的</li><li>SingleTask 栈内存在则不创建新的，并且把上面的全都出栈</li><li>SingleInstance 用一个单独的栈来管理</li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 泛型</title>
      <link href="/2019/07/02/Java-%E6%B3%9B%E5%9E%8B/"/>
      <url>/2019/07/02/Java-%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="what"><a href="#what" class="headerlink" title="what"></a>what</h3><p>泛型我通俗的认为就是参数化类型，即传入类型提示。告诉它我即将要在这个类型的版本上使用你了。并且在写出大量代码时使用泛型可以写出一套模板代码。而且使用了泛型后，在编译期间泛型这个是能够检测你的代码有没有使用不规范类型的对象，在编译期间有点不好理解，但是当我们用IDE的时候，一旦你使用泛型，产生的对象，在IDE看来所给出的代码提示等检查也都是基于传入的泛型参数。但是呢，编译通过后在jvm中运行表现看来，所有用于参数类型的对象表现为Object， 这也俗称类型擦除。<strong>泛型参数不能时基本类型</strong></p><a id="more"></a><h3 id="how"><a href="#how" class="headerlink" title="how"></a>how</h3><h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><p>首先列举下我们经常用到一些关于泛型的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><p>如何自行定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class Person&lt;T&gt; &#123;</span><br><span class="line">    T t;</span><br><span class="line">    <span class="function">T <span class="title">getT</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setT</span><span class="params">(T t)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person&lt;String&gt; person = <span class="keyword">new</span> Person&lt;&gt;();</span><br><span class="line">        person.setT(<span class="string">"ffff"</span>);</span><br><span class="line">        Person&lt;Integer&gt; person1 = <span class="keyword">new</span> Person&lt;&gt;();</span><br><span class="line">        person1.setT(<span class="number">9</span>);</span><br><span class="line">        System.out.println(person.getT().getClass());</span><br><span class="line">        System.out.println(person1.getT().getClass());</span><br><span class="line">        System.out.println(person.getClass());<span class="comment">//class learn2.GenericTest$Person</span></span><br><span class="line">        System.out.println(person1.getClass());<span class="comment">//class learn2.GenericTest$Person</span></span><br><span class="line">        GenericTest test = <span class="keyword">new</span> GenericTest();</span><br><span class="line">        test.getArray(<span class="number">1</span>,<span class="number">23</span>,<span class="number">4</span>);</span><br><span class="line">        test.getArray(<span class="string">"f"</span>, <span class="string">"f"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> &lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> T t;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setT</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.t = t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">getT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后你就能发挥想象创造代码了呀，别看它加了尖括号和类型，其实看穿了还是一个普通类。通过Class比较你都看不到关于泛型的东西</p><p>以及后续的继承</p><h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Presenter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">attachView</span><span class="params">(T t)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dettachView</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实和泛型类没啥不同</p><h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; T[] getArray(T ...ts) &#123;</span><br><span class="line">        <span class="keyword">return</span> ts;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">static</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="keyword">int</span>[] nums = test.getArray(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">        String[] strs = test.getArray(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子是我比较喜欢的，通过变长的参数返回数组。看在你传入参数一刹那，其实就是相当于把类型参数弄进入了。</p><h4 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h4><p>在jdk的代码中以及框架呀大量使用关于泛型的东西，说明了这玩意很好使。通过接口实现，或者类的继承中加入泛型，又能够写出可复用的代码。以及配合通配符，配合多态呀，那简直爽的不要不要的。</p><p><code>extends</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IPresenter</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">IView</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//说明了传入的参数类型，得要是IView子类</span></span><br></pre></td></tr></table></figure><p>好吧我老是把&lt;? extends T&gt; 和 <t extends sometype>搞混。。</t></p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><p>泛型参数不能是基本类型</p></li><li><p>不能带泛型用于<code>instancof</code>关键字</p></li><li><p>不可以用于泛型数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] lists = <span class="keyword">new</span> ArrayList&lt;String&gt;[<span class="number">10</span>];<span class="comment">//无法这样不行的</span></span><br><span class="line">List&lt;String&gt;[] lists = <span class="keyword">new</span> ArrayList[<span class="number">10</span>];<span class="comment">//这样却是可以的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//唯一的方式就是创建类型擦出的数组，然后再转型</span></span><br><span class="line">List&lt;String&gt;[] lists = <span class="keyword">new</span> ArrayList[<span class="number">10</span>];</span><br><span class="line">lists[<span class="number">0</span>] = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">lists[<span class="number">0</span>].add(<span class="string">"aa"</span>);</span><br><span class="line">System.out.println(lists.getClass());</span><br></pre></td></tr></table></figure></li><li><p>类型捕获</p><p>通同getClass来获取真实的类型咯</p></li><li><p>泛型和重载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span>,<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//因为泛型擦初，所以二者有相同的方法签名</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(List&lt;E&gt; list)</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//同样</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(T t)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(E e)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>自限定的类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">C</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">//这自限定的例子比较简单，即限定比较对象为自己，其实仔细研究还是泛型的事</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(C o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">A</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;&#125; <span class="comment">//这个有点抽象，但是仔细看好像陷入一个无限循环样子</span></span><br><span class="line"><span class="comment">//首先我们继承它看看</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span>&lt;<span class="title">B</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//这样写是否合理，就看B是否能套入&lt;T extentd A&lt;T&gt;&gt; 中，呃呃，看了好久，是可以</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//那么到底有什么用呢，这个通常用于继承关系中的限定。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">A</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">         <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span>&lt;<span class="title">B</span>&gt; </span>&#123;<span class="comment">//这个泛型参数只能事继承链上的，换了其它的不可以，就是这是妙用啊</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(B b)</span> </span>&#123;<span class="comment">//由于限定了这个实现的方法就必须为自己。其它不行。有意思呵呵</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>异常处理中catch是不能捕获泛型类型的异常，因为再运行期间必须知道异常的确切类型</p></li></ul><h3 id="why"><a href="#why" class="headerlink" title="why"></a>why</h3><p>编写用于多种类型的代码。</p><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>前面的其实都还好理解，到了这里就有点要想想了，不然傻傻分不清楚。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?&gt;</span><br><span class="line">&lt;? extends E&gt; <span class="comment">//这个E一般就代表声明出来的类型参数。指代你声明&lt;E&gt;</span></span><br><span class="line">&lt;? <span class="keyword">super</span> E&gt;</span><br></pre></td></tr></table></figure><h4 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h4><p>还是看栗子把2333</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> learn2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericTest2 test2 = <span class="keyword">new</span> GenericTest2();</span><br><span class="line">        List&lt;String&gt; stringList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        stringList.add(<span class="string">"aaa"</span>);</span><br><span class="line">        stringList.add(<span class="string">"bbb"</span>);</span><br><span class="line">        stringList.add(<span class="string">"ccc"</span>);</span><br><span class="line">        List&lt;Integer&gt; integerList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        integerList.add(<span class="number">1</span>);</span><br><span class="line">        integerList.add(<span class="number">2</span>);</span><br><span class="line">        integerList.add(<span class="number">3</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ?任意</span></span><br><span class="line">        test2.runTest(stringList);</span><br><span class="line">        test2.runTest(integerList);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//上界为Number</span></span><br><span class="line">        List&lt;Long&gt; longList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        test2.runTest2(longList, <span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//下界Number</span></span><br><span class="line">        List&lt;Object&gt; objectList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        test2.runTest3(objectList, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runTest</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;<span class="comment">//可以接受任意泛型参数的List</span></span><br><span class="line">        list.add(<span class="keyword">null</span>);<span class="comment">//只能写null</span></span><br><span class="line"><span class="comment">//        list.add(new Object());// error</span></span><br><span class="line">        System.out.println(list.get(<span class="number">3</span>).getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runTest2</span><span class="params">(List&lt;? extends Number&gt; list, Number number2)</span> </span>&#123;<span class="comment">//只能接受泛型参数继承Number的List</span></span><br><span class="line">        Number number = list.get(<span class="number">0</span>);<span class="comment">// 只可以读Number类型</span></span><br><span class="line">        <span class="comment">//list.add(new Object());//写不了</span></span><br><span class="line">        <span class="comment">//list.add(number2);//编译不通过</span></span><br><span class="line">        <span class="comment">//list.add(number);//编译不通过</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runTest3</span><span class="params">(List&lt;? <span class="keyword">super</span> Number&gt; list, Number number)</span> </span>&#123;<span class="comment">//只能接受泛型参数为Number父类的List</span></span><br><span class="line">        list.add(number);<span class="comment">//可以写Number类型</span></span><br><span class="line">        <span class="comment">//list.add(new Object()); 不行</span></span><br><span class="line">        Object object = list.get(<span class="number">0</span>);<span class="comment">//只能捕获为Object</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分析一波"><a href="#分析一波" class="headerlink" title="分析一波"></a>分析一波</h4><ul><li><p><code>&lt;?&gt;</code>这个统配符代表，可以接受任意泛型参数，与之同时，对应的<code>List&lt;?&gt; list</code> 可以接受<code>List&lt;Number&gt;</code> <code>List&lt;String&gt;</code>对象等等，所以嘞，它也就根本不知道实际对象会是带什么泛型参数，所以只能<strong>写<code>null</code></strong>，我没想到的是居然<strong>写Object</strong>也不行，读还是的啊，但是只能为Object，没事啊，你可动态的<code>instance of</code>判断下嘛，写死转换肯定是不行的，因为它压根啥也不知道，咱也不敢问是吧。</p></li><li><p><code>&lt;? extends E&gt;</code>这个通配符代表了，可以接受带上界为E泛型参数。即你的泛型参数得是E或E的子类才行</p><p>List&lt;? extends Number&gt; list这个能能接受<code>List&lt;Int&gt;</code> <code>List&lt;Long&gt;</code>等等为Number的子类泛型参数 。可能有人会觉得有了上界那不为所欲为。我以前也是这么觉得的哈哈。上述实践得知，只<code>能写为E</code>，<code>不能读为E</code>，当然能读为Object。因为它知道你传进来的肯定是带E后代泛型，所以呢，我里面的元素肯定能表现为E，所以读是没问题。但是写E就有问题了，比如我某一次识别的到是Long，然后你要写一个Number，你说怎么能写。</p></li><li><p><code>&lt;? super E&gt;</code> 这个就刚好了上面那个相反，E为下界，可以接受E父类等泛型参数。对于这个而言，就只<code>能写E</code>，<code>不能读E</code> ，你的泛型参数为超类，你压根不知到内容表现为具体是个啥东西，所以读就别想了。但是E可以表现为超类，所以写E就没问题咯。</p></li></ul><p>总结下来就是：</p><p>&lt;?&gt; 可以匹配任何泛型参数，但是只能写null</p><p>&lt;? extends E&gt; 可以匹配E的子类泛型参数，只能读E，不能写E</p><p>&lt;? super E&gt; 可以匹配E的超类泛型参数，不能读E，只能写E</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>其实泛型这个东西呢，以前我想的太简单了，传个类型参数就完事了，以前我也是这么认为的，但是看了《Java编程思想》，卧槽还有这么多东西，而且稍稍不深入就会被带跑偏呃呃。目前还是归纳的不够详细，以后学到再补充！✌，对了想不通的地方，没事一定要敲一敲，比瞎想强，总有好处的。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 并发梳理</title>
      <link href="/2019/07/01/Java-%E5%B9%B6%E5%8F%91/"/>
      <url>/2019/07/01/Java-%E5%B9%B6%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<p>Java 并发</p><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>what：cpu调度的最小单位</p><p>创建方式：</p><ul><li>继承Thread，实现重写run方法，创建Thread对象，调用start方法。</li><li>实现Runnable，实现run方法，创建Runnable对象，传入Thread对象，调用start方法</li><li>后文的中Callable</li></ul><p>线程的状态：新建，可执行，执行，阻塞，死亡</p><p><img src="/images/1561517414845.png" alt="1561517414845"></p><p>yield只是让出cpu的使用权，下次还有可能抢占cpu</p><p>调用其它线程的join，当前线程会阻塞，知道那个线程执行完毕。</p><h5 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h5><p>多线程访并发访问共享资源，会导致数据安全问题。</p><h6 id="synchronized-加悲观锁"><a href="#synchronized-加悲观锁" class="headerlink" title="synchronized 加悲观锁"></a>synchronized 加悲观锁</h6><p>通过synchronized添加锁，可以加载方法上和代码块上。在被锁起来的地方只会又一个线程进入，直到该代码执行完毕。该实现为jvm内置实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span>(obj)&#123;&#125;</span><br></pre></td></tr></table></figure><p>线程8锁问题：</p><p>synchronized锁需要看锁的对象是谁，线程需要锁对象为同一个的情况下，进入了锁区域另外的线程就必须等待。</p><ul><li>锁对象为普通对象</li><li>所对象为class对象，即在静态方法上加锁</li></ul><p>要根据具体锁对象来判断执行效果。持有同一锁对象，操作即为互斥。</p><h6 id="Lock-乐观锁"><a href="#Lock-乐观锁" class="headerlink" title="Lock 乐观锁"></a>Lock 乐观锁</h6><p>代码实现，需要手动释放锁，不然会造成死锁，需要在finally释放锁</p><p>有三个实现类</p><ul><li>ReentrantLock  可重入锁</li><li>ReadLock 读锁，通过new ReentrantReadWriteLock .readLock()获得</li><li>WriteLock写锁，通过new ReentrantReadWriteLock .writeLock()获得</li></ul><p>读写锁：读写互斥，写写互斥，读读共享</p><p><strong>Condition</strong></p><p>在synchronized锁下面，jvm提供了obect.wait,和notify，这两个通信是依赖synchronized关键字的，从等待池到锁池。而在Lock锁下与之对应线程通信的则是Condition对象，condition.await()进入等待和condition.sigal()唤醒</p><h6 id="Lock和synchronized的选择"><a href="#Lock和synchronized的选择" class="headerlink" title="Lock和synchronized的选择"></a>Lock和synchronized的选择</h6><p>　　总结来说，Lock和synchronized有以下几点不同：</p><p>　　1）Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；</p><p>　　2）synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；</p><p>　　3）Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；</p><p>　　4）通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。</p><p>　　5）Lock可以提高多个线程进行读操作的效率。</p><p>　　在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。</p><h6 id="锁的概念"><a href="#锁的概念" class="headerlink" title="锁的概念"></a>锁的概念</h6><p>　　<strong>1.可重入锁</strong></p><p>如果锁具备可重入性，则称作为可重入锁。像synchronized和ReentrantLock都是可重入锁，可重入性在我看来实际上表明了锁的分配机制：基于线程的分配，而不是基于方法调用的分配。举个简单的例子，当一个线程执行到某个synchronized方法时，比如说method1，而在method1中会调用另外一个synchronized方法method2，此时线程不必重新去申请锁，而是可以直接执行方法method2。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>synchronized和Lock都具备可重入性</p><p>​        <strong>2.可中断锁</strong></p><p>　　可中断锁：顾名思义，就是可以相应中断的锁。</p><p>　　在Java中，synchronized就不是可中断锁，而Lock是可中断锁。</p><p>　　如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，这种就是可中断锁。</p><p>　　在前面演示lockInterruptibly()的用法时已经体现了Lock的可中断性。</p><p>​        <strong>3.公平锁</strong></p><p>　　公平锁即尽量以请求锁的顺序来获取锁。比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该所，这种就是公平锁。</p><p>　　非公平锁即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或者一些线程永远获取不到锁。</p><p>　　在Java中，synchronized就是非公平锁，它无法保证等待的线程获取锁的顺序。</p><p>　　而对于ReentrantLock和ReentrantReadWriteLock，它默认情况下是非公平锁，但是可以设置为公平锁。</p><p><code>ReentrantLock lock = new</code> <code>ReentrantLock(true);</code></p><p>true 为公平，false为不公平</p><p>另外在ReentrantLock类中定义了很多方法，比如：</p><p>　　isFair()        //判断锁是否是公平锁</p><p>　　isLocked()    //判断锁是否被任何线程获取了</p><p>　　isHeldByCurrentThread()   //判断锁是否被当前线程获取了</p><p>　　hasQueuedThreads()   //判断是否有线程在等待该锁</p><p>　　在ReentrantReadWriteLock中也有类似的方法，同样也可以设置为公平锁和非公平锁。不过要记住，ReentrantReadWriteLock并未实现Lock接口，它实现的是ReadWriteLock接口。</p><p>​        <strong>4.读写锁</strong></p><h6 id="Volatile关键字"><a href="#Volatile关键字" class="headerlink" title="Volatile关键字"></a><strong>Volatile关键字</strong></h6><p>内存可见性是指当某个线程正在使用对象状态而另一个线程在同时修改该状态，需要确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。当多个线程进行操作共享数据时，可以保证内存中的数据可见。相较于 synchronized 是一种较为轻量级的同步策略</p><ol><li><p>volatile 不具备“互斥性”</p></li><li><p>volatile 不能保证变量的“原子性”</p></li></ol><h6 id="CAS算法-无锁算法"><a href="#CAS算法-无锁算法" class="headerlink" title="CAS算法 无锁算法"></a>CAS算法 无锁算法</h6><p>原子性操作问题，CAS是一种硬件对并发的支持，用于管理对共享数据的访问，CAS是一种无锁的非阻塞算法实现</p><p>1、原子变量：在java.util.concurrent.atomic包下提供了基本的原子变量</p><p>​    【1】Volatile保证内存可见性</p><p>​    【2】CAS算法保证数据变量的原子性</p><p>2、CAS算法实现CAS包含了三个操作变量：</p><p>​    【1】内存值V</p><p>​    【2】内存预估值A</p><p>​    【3】内存更新值B当且仅当V==A时，V=B；否则不会执行任何操作模拟CAS算法</p><h5 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h5><h6 id="基于synchronized-锁"><a href="#基于synchronized-锁" class="headerlink" title="基于synchronized 锁"></a>基于synchronized 锁</h6><p>wait：中断方法的执行，使本线程等待，暂时让出 cpu 的使用权，并允许其他线程使用这个同步方法。</p><p>notify：唤醒由于使用这个同步方法而处于等待线程的 某一个结束等待</p><p>notifyall：唤醒所有由于使用这个同步方法而处于等待的线程结束等待</p><p>锁池:假设线程A已经拥有了某个对象(注意:不是类)的锁，而其它的线程想要调用这个对象的某个synchronized方法(或者synchronized块)，由于这些线程在进入对象的synchronized方法之前必须先获得该对象的锁的拥有权，但是该对象的锁目前正被线程A拥有，所以这些线程就进入了该对象的锁池中。</p><p>等待池:假设一个线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁后，进入到了该对象的等待池中<br>所谓唤醒线程，另一种解释可以说是将线程由等待池移动到锁池，notifyAll调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而notify只会唤醒一个线程。</p><h6 id="基于Lock锁"><a href="#基于Lock锁" class="headerlink" title="基于Lock锁"></a>基于Lock锁</h6><p>从Lock中获得Condition，类似于上面的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> var1)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> var1, TimeUnit var3)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date var1)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><h5 id="what"><a href="#what" class="headerlink" title="what"></a>what</h5><p>维护了一些线程的队列，线程创建和销毁是非常消耗资源的。利用线程池来重用这些线程，提高了响应速度</p><p>降低 资源消耗</p><p>提高响应速度</p><p>提高线程的 可管理性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 一、线程池：提供了一个线程队列，队列中保存着所有等待状态的线程。避免了创建与销毁额外开销，提高了响应的速度。</span><br><span class="line"> * </span><br><span class="line"> * 二、线程池的体系结构：</span><br><span class="line"> * java.util.concurrent.Executor : 负责线程的使用与调度的根接口</span><br><span class="line"> * |--**ExecutorService 子接口: 线程池的主要接口</span><br><span class="line"> * |--ThreadPoolExecutor 线程池的实现类</span><br><span class="line"> * |--ScheduledExecutorService 子接口：负责线程的调度</span><br><span class="line"> * |--ScheduledThreadPoolExecutor ：继承 ThreadPoolExecutor， 实现 ScheduledExecutorService</span><br><span class="line"> * </span><br><span class="line"> * 三、工具类 : Executors </span><br><span class="line"> * ExecutorService newFixedThreadPool() : 创建固定大小的线程池</span><br><span class="line"> * ExecutorService newCachedThreadPool() : 缓存线程池，线程池的数量不固定，可以根据需求自动的更改数量。</span><br><span class="line"> * ExecutorService newSingleThreadExecutor() : 创建单个线程池。线程池中只有一个线程</span><br><span class="line"> * </span><br><span class="line"> * ScheduledExecutorService newScheduledThreadPool() : 创建固定大小的线程，可以延迟或定时的执行任务。</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h5 id="how"><a href="#how" class="headerlink" title="how"></a>how</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">execute 执行任务</span><br><span class="line">submit 提交任务，并且返回Future</span><br><span class="line">shutDown 中止线程池，设置线程池状态为SHUTDOWN，中断没有运行的线程</span><br><span class="line">shtDownNow 中止线程池，设置线程池状态为SHUTDOWN， 尝试停止所有线程，并返回等待任务队列</span><br><span class="line">不同应用场景使用不同的配置线程</span><br><span class="line">任务的性质：CPU密集型任务、IO密集型任务和混合型任务</span><br><span class="line">任务的优先级：高、中和低</span><br><span class="line">任务的执行时间：长、中和短</span><br><span class="line">任务的依赖性：是否依赖其他系统资源，如数据库连接。</span><br><span class="line">CPU密集型任务</span><br><span class="line">应配置尽可能小的线程,配置</span><br><span class="line">N(CPU)+<span class="number">1</span>或者 N(CPU) * <span class="number">2</span></span><br><span class="line">I/O密集型任务</span><br><span class="line">业务读取较多,线程并不是一直在执行任务,则应配置尽可能多的线程</span><br><span class="line">N(CPU)/<span class="number">1</span> - 阻塞系数(<span class="number">0.8</span>~<span class="number">0.9</span>)</span><br><span class="line">混合型的任务,如果可以拆分,将其拆分成一个CPU密集型任务和一个IO密集型任务,只要这两个任务执行的时间相差不是太大,那么分解后执行的吞吐量将高于串行执行的吞吐量.如果这两个任务执行时间相差太大,则没必要进行分解.</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>关于线程池构造方法参数说明：</p><p>corePoolSize 核心线程数量</p><p>maximumPoolSize 最大线程数量</p><p>keepAliveTime 存活时间</p><p>TimeUnit 时间单位</p><p>workQueue 等待队列</p><h5 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h5><ul><li>AbortPolicy：丢弃任务，抛出 RejectedExecutionException</li><li>CallerRunsPolicy:只用调用者所在线程来运行任务,有反馈机制，使任务提交的速度变慢）。</li><li>DiscardOldestPolicy<br>若没有发生shutdown,尝试丢弃队列里最近的一个任务,并执行当前任务, 丢弃任务缓存队列中最老的任务，并且尝试重新提交新的任务</li><li>DiscardPolicy:不处理,丢弃掉, 拒绝执行，不抛异常<br>当然,也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略.如记录日志或持久化存储不能处理的任务  </li></ul><p>一个任务被提交到线程池中，首先会去检查核心线程是否达最大，如果没有则创建新线执行任务，如果核心线程达最大且都在执行任务，下一步将会去判断任务队列是否满，如果没有满则入队列等待，如果满了则创建新的线程，此时线程池最大能达到的线程数量即为最大线程数，当任务执行完毕，线程空闲之后等待存活时间后就会杀死线程。知道线程数量维持在核心线程数量。</p><p>这样就好比如一个工厂本来又四个人在工作，但是订单增加了，但是能工厂负责人认为工人还能承受住，于是就将累计的订单来排队，时间一长还是能完成，但是随着订单的增加，工厂的排队已经排不下了。工厂负责人招了了一些了临时工参与工作，随着时间推移订单还在增加，此时排队满了，工人工作的位置也满了。此时工厂负责人就要考虑使用那种策略来对待新的订单。当订单减少了，临时工没事做了，此时工厂负责人为了成本考虑，就要撤下临时工了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c = ctl.get();</span><br><span class="line"><span class="comment">//工作任务小于核心线程数</span></span><br><span class="line"><span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">    <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))<span class="comment">//创建线程</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    c = ctl.get();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//大于核心线程数，尝试入工作队列</span></span><br><span class="line"><span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">    <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">        reject(command);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;<span class="comment">//入队列失败，尝试新增线程，此时线程数即将大于核心线程，但是要小于最大线程数</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">    reject(command);<span class="comment">//达到最大线程数，采取拒绝策略</span></span><br></pre></td></tr></table></figure><h5 id="关于获取Worker"><a href="#关于获取Worker" class="headerlink" title="关于获取Worker"></a>关于获取Worker</h5><p>线程池维持一个Worker的HashSet，Work本身也是一个Runnable，内部包含了一个第一个任务，和一个Thread对象（线程），也就是一个work持有一个线程。这个线程在addWorker成功时，会去开启线程。也就是调用线程池外围的runWorker方法。从这里就开始进入worker的线程任务了，在线程中开启while循环去获得Task，Task的获得同样时循环去阻塞队列拿runnable。如果工作队列空了，拿取超时，则会去减少Worker数量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.....</span><br><span class="line">//Worker类</span><br><span class="line">Worker(Runnable firstTask) &#123;</span><br><span class="line">            setState(-1); // inhibit interrupts until runWorker</span><br><span class="line">            this.firstTask = firstTask;</span><br><span class="line">            this.thread = getThreadFactory().newThread(this);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /** Delegates main run loop to outer runWorker. */</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            runWorker(this);</span><br><span class="line">        &#125;</span><br><span class="line">....</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//addWorke方法 </span></span><br><span class="line">w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">            <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">                mainLock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                    <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                    <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                    <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                        (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                        workers.add(w);</span><br><span class="line">                        <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                        <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                            largestPoolSize = s;</span><br><span class="line">                        workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    mainLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                    t.start();</span><br><span class="line">                    workerStarted = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//runThis方法</span></span><br><span class="line"><span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                w.lock();</span><br><span class="line">                <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">                <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">                <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">                <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">                <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                     (Thread.interrupted() &amp;&amp;</span><br><span class="line">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                    !wt.isInterrupted())</span><br><span class="line">                    wt.interrupt();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    beforeExecute(wt, task);</span><br><span class="line">                    Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        task.run();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        afterExecute(task, thrown);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="keyword">null</span>;</span><br><span class="line">                    w.completedTasks++;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">               decrementWorkerCount();</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">           <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">               &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">               <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://www.nowcoder.com/discuss/152050?type=0&amp;order=0&amp;pos=6&amp;page=0" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/152050?type=0&amp;order=0&amp;pos=6&amp;page=0</a></p><h4 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h4><h5 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h5><p>参考：<a href="https://blog.csdn.net/yudiandemingzi/article/details/82318390" target="_blank" rel="noopener">https://blog.csdn.net/yudiandemingzi/article/details/82318390</a></p><p>内部基于Lock锁的通信实现等待阻塞。</p><h5 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h5><p>ConcurrentMap</p><p>CopyOnWriteList</p><h5 id="原子变量"><a href="#原子变量" class="headerlink" title="原子变量"></a>原子变量</h5><p>硬件级别实现，普通变量int进行自增时，在jvm表现看来，这不是一个原子操作，所以线程就有可能打断，从而造成数据安全问题。</p><p>而原子变量通过使用volatile来保证内存可见性以及通过cas算法保证原子性。</p><h5 id="CountDownLatch-闭锁"><a href="#CountDownLatch-闭锁" class="headerlink" title="CountDownLatch 闭锁"></a>CountDownLatch 闭锁</h5><p>也可以叫倒计数器</p><p>what:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建计数为10的闭锁</span></span><br><span class="line">CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//计数减一</span></span><br><span class="line">countDownLath.countDown();</span><br><span class="line"><span class="comment">//线程等待,直到计数为0</span></span><br><span class="line">countDownLath.await();</span><br></pre></td></tr></table></figure><p>在线程完成某项操作之前它允许让一个或多个线程进行等待。倒计数，在内部计数到零之前，所调用countDownLatch.await的线程会等待，直到计数到达0为止。 </p><p>how:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> learn2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CountDownLatchTest test = <span class="keyword">new</span> CountDownLatchTest();</span><br><span class="line">        test.runTest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Main is waiting."</span>);</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Main is over"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CountDownLatch countDownLatch;</span><br><span class="line"></span><br><span class="line">    Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Current Thred is "</span> + Thread.currentThread().getId() + <span class="string">",print : "</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">Main is waiting.</span><br><span class="line">Current Thred is <span class="number">12</span>,print : <span class="number">0</span></span><br><span class="line">Current Thred is <span class="number">13</span>,print : <span class="number">0</span></span><br><span class="line">Current Thred is <span class="number">12</span>,print : <span class="number">1</span></span><br><span class="line">Current Thred is <span class="number">13</span>,print : <span class="number">1</span></span><br><span class="line">Current Thred is <span class="number">12</span>,print : <span class="number">2</span></span><br><span class="line">Current Thred is <span class="number">12</span>,print : <span class="number">3</span></span><br><span class="line">Current Thred is <span class="number">12</span>,print : <span class="number">4</span></span><br><span class="line">Current Thred is <span class="number">12</span>,print : <span class="number">5</span></span><br><span class="line">Current Thred is <span class="number">13</span>,print : <span class="number">2</span></span><br><span class="line">Current Thred is <span class="number">12</span>,print : <span class="number">6</span></span><br><span class="line">Current Thred is <span class="number">13</span>,print : <span class="number">3</span></span><br><span class="line">Current Thred is <span class="number">12</span>,print : <span class="number">7</span></span><br><span class="line">Current Thred is <span class="number">13</span>,print : <span class="number">4</span></span><br><span class="line">Current Thred is <span class="number">12</span>,print : <span class="number">8</span></span><br><span class="line">Current Thred is <span class="number">13</span>,print : <span class="number">5</span></span><br><span class="line">Current Thred is <span class="number">13</span>,print : <span class="number">6</span></span><br><span class="line">Current Thred is <span class="number">12</span>,print : <span class="number">9</span></span><br><span class="line">Current Thred is <span class="number">13</span>,print : <span class="number">7</span></span><br><span class="line">Current Thred is <span class="number">13</span>,print : <span class="number">8</span></span><br><span class="line">Current Thred is <span class="number">13</span>,print : <span class="number">9</span></span><br><span class="line">Main is over</span><br></pre></td></tr></table></figure><h5 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h5><p>What：栅栏，类似于闭锁，但是呢，闭锁是等待事件，即线程等待到countDown数量为0为止。而栅栏则是，线程到达栅栏开始等待，知道所有线程都达到栅栏了，就不在等待。而且闭锁使用一次，栅栏可以重置，继续使用。</p><blockquote><p>书上是这么说的：你希望创建一组任务，使他们并行执行，然后下一个步骤之前等待，直到所有任务完成，它使得所有并行任务在栅栏处排队，因此可以一致的向前移动。</p></blockquote><p>How：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line">CyclicBarrier(<span class="keyword">int</span> parties);<span class="comment">//parties 表示会有多少到达的栅栏的线程</span></span><br><span class="line">CyclicBarrier(<span class="keyword">int</span> parties, Runnable barrierAction);<span class="comment">//barrierAction 所有线程到达栅栏，会触发</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//关键方法</span></span><br><span class="line">await();<span class="comment">//某线程到达栅栏，并且等待，知道所有线程都到达栅栏</span></span><br><span class="line">reset();<span class="comment">//重置栅栏到初始状态</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> learn2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CyclicBarrierTest test = <span class="keyword">new</span> CyclicBarrierTest();</span><br><span class="line">        test.runTest();</span><br><span class="line">    &#125;</span><br><span class="line">    CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(runnable, <span class="string">"thread "</span> + i);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"for is over"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Runnable runnable = () -&gt; &#123;</span><br><span class="line">        System.out.println( Thread.currentThread().getName() + <span class="string">" waited"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cyclicBarrier.await();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" wake up"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//outputs 大概就是这个效果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> is over</span><br><span class="line">thread <span class="number">2</span> waited</span><br><span class="line">thread <span class="number">1</span> waited</span><br><span class="line">thread <span class="number">3</span> waited</span><br><span class="line">thread <span class="number">0</span> waited</span><br><span class="line">thread <span class="number">4</span> waited</span><br><span class="line">thread <span class="number">4</span> wake up</span><br><span class="line">thread <span class="number">1</span> wake up</span><br><span class="line">thread <span class="number">0</span> wake up</span><br><span class="line">thread <span class="number">3</span> wake up</span><br><span class="line">thread <span class="number">2</span> wake up</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h5 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h5><p>What：目前的Runnable执行方式是无法返回数据的。使用Callable创建线程以及配合FutureTask使用</p><p>FurtureTask.get时会所在线程锁等FurtureTask执行完毕</p><p>How：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 一、创建执行线程的方式三：实现 Callable 接口。 相较于实现 Runnable 接口的方式，方法可以有返回值，并且可以抛出异常。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 二、执行 Callable 方式，需要 FutureTask 实现类的支持，用于接收运算结果。  FutureTask 是  Future 接口的实现类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCallable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadDemo td = <span class="keyword">new</span> ThreadDemo();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.执行 Callable 方式，需要 FutureTask 实现类的支持，用于接收运算结果。</span></span><br><span class="line">        FutureTask&lt;Integer&gt; result = <span class="keyword">new</span> FutureTask&lt;&gt;(td);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(result).start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.接收线程运算后的结果</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Integer sum = result.get();  <span class="comment">//FutureTask 可用于 闭锁</span></span><br><span class="line">            System.out.println(sum);</span><br><span class="line">            System.out.println(<span class="string">"------------------------------------"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h5><h5 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h5><h5 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h5><p>What：继承自AbstractExecutorService，是一种特殊的线程池，通过分治法来分拆合并任务，使用有限的线程进行处理任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"><span class="keyword">import</span> java.time.Instant;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinTask;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.LongStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestForkJoinPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Instant start = Instant.now();</span><br><span class="line"></span><br><span class="line">ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line"></span><br><span class="line">ForkJoinTask&lt;Long&gt; task = <span class="keyword">new</span> ForkJoinSumCalculate(<span class="number">0L</span>, <span class="number">50000000000L</span>);</span><br><span class="line"></span><br><span class="line">Long sum = pool.invoke(task);</span><br><span class="line"></span><br><span class="line">System.out.println(sum);</span><br><span class="line"></span><br><span class="line">Instant end = Instant.now();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"耗费时间为："</span> + Duration.between(start, end).toMillis());<span class="comment">//166-1996-10590</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">Instant start = Instant.now();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> sum = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0L</span>; i &lt;= <span class="number">50000000000L</span>; i++) &#123;</span><br><span class="line">sum += i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(sum);</span><br><span class="line"></span><br><span class="line">Instant end = Instant.now();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"耗费时间为："</span> + Duration.between(start, end).toMillis());<span class="comment">//35-3142-15704</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//java8 新特性</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">Instant start = Instant.now();</span><br><span class="line"></span><br><span class="line">Long sum = LongStream.rangeClosed(<span class="number">0L</span>, <span class="number">50000000000L</span>)</span><br><span class="line"> .parallel()</span><br><span class="line"> .reduce(<span class="number">0L</span>, Long::sum);</span><br><span class="line"></span><br><span class="line">System.out.println(sum);</span><br><span class="line"></span><br><span class="line">Instant end = Instant.now();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"耗费时间为："</span> + Duration.between(start, end).toMillis());<span class="comment">//1536-8118</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ForkJoinSumCalculate</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">259195479995561737L</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> start;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> end;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> THURSHOLD = <span class="number">10000L</span>;  <span class="comment">//临界值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ForkJoinSumCalculate</span><span class="params">(<span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.start = start;</span><br><span class="line"><span class="keyword">this</span>.end = end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> length = end - start;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(length &lt;= THURSHOLD)&#123;</span><br><span class="line"><span class="keyword">long</span> sum = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">sum += i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">long</span> middle = (start + end) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">ForkJoinSumCalculate left = <span class="keyword">new</span> ForkJoinSumCalculate(start, middle); </span><br><span class="line">left.fork(); <span class="comment">//进行拆分，同时压入线程队列</span></span><br><span class="line"></span><br><span class="line">ForkJoinSumCalculate right = <span class="keyword">new</span> ForkJoinSumCalculate(middle+<span class="number">1</span>, end);</span><br><span class="line">right.fork(); <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> left.join() + right.join();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 反射</title>
      <link href="/2019/07/01/Java-%E5%8F%8D%E5%B0%84/"/>
      <url>/2019/07/01/Java-%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<p>Java 反射</p><ul><li>类加载器</li><li>反射</li><li>动态代理</li></ul><p>what：在运行时加载某个类，获得某个类的相关信息，以及进行操作。</p><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>what:用于将节字码文件加载到JVM</p><ul><li>启动类加载器：bootstrap，c++编写，jvm自带，负责加载rt.jar（runtime），无法直接获取，它是所有类加载器的父加载器</li><li>扩展类加载器：extension ，jdk_home/lib/ext目录下的jar包或者 -D java.ext.dirs指定目录下的jar包装入工作库</li><li>System ClassLoader ：负责java -classpath或者-D java.class.path所指目录 下的类和jar包装入</li></ul><p>委托、可见性以及单一性原理</p><p>委托:即子加载器会请求父加载器是否加载,并且加载,如果不能加载就交会子加载器,即自下而上请求,自上而下加载.</p><p>可见性: 子类加载器可以看到父类加载器加载的类，而反之则不行</p><p>单一性: 父加载器加载过的类不能被子加载器加载第二次</p><h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><p>what：<strong>运行</strong>时获得类信息，注意是运行时。</p><p>Class：字节码在jvm存在形式即为Class的对象，是由jvm创建的。</p><ul><li><p>运行时构造任意一个对象</p></li><li><p>运行取得任意一个类所拥有成员变量和方法</p></li><li><p>运行时获得任意对象的方法属性</p></li><li><p>动态代理</p></li></ul><p>how：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"全类名"</span>);</span><br><span class="line">Class clazz = SomeClass.class;</span><br><span class="line">Class clazz = someClassObj.getClass();</span><br></pre></td></tr></table></figure><p>相关操作：可以拿到以下的信息</p><p>Constructor：getConstructor， getContructors</p><p>Method：getMethods（继承链上public的），getDeclareMethods（当前类声明的所有）</p><p>Field：getFields（继承链上public），getDeclareFields（当前类声明所有）</p><p>Annotation：getAnnotation，getDeclareAnnotaions(),getParameterAnnotations() </p><p>以及newInstance去创建对象</p><p>invoke去调用方法</p><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Boy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Boy</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打印"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Boy boy = <span class="keyword">new</span> Student();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boy <span class="title">getProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Boy) Proxy.newProxyInstance(boy.getClass().getClassLoader(), boy.getClass().getInterfaces(), <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"我是代理"</span>);</span><br><span class="line">                <span class="keyword">return</span> method.invoke(boy,args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 注解</title>
      <link href="/2019/07/01/Java-%E6%B3%A8%E8%A7%A3/"/>
      <url>/2019/07/01/Java-%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><strong>注解</strong></p><p>what：用于描述数据，并且可以被编译期以及jvm捕获的信息</p><ul><li>注解基本使用</li><li>运行时处理注解</li><li>编译处理注解</li><li>其它用处</li></ul><h3 id="注解基本使用"><a href="#注解基本使用" class="headerlink" title="注解基本使用"></a>注解基本使用</h3><p>how：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="meta">@interface</span> One&#123;</span><br><span class="line">    <span class="comment">//类似方法声明的方式来声明属性</span></span><br><span class="line">     <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="meta">@One</span>(name = <span class="string">"fdaf"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//基本注解</span></span><br><span class="line"><span class="meta">@Overrider</span> 描述限定重现父类方法</span><br><span class="line"><span class="meta">@Deprecated</span> 描述某个类或方法过时</span><br><span class="line"><span class="meta">@SupressWarnings</span> 抑制编译期警告</span><br></pre></td></tr></table></figure><p>元注解：描述注解的注解，用于限定注解的行为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span> 描述注解将注解的位置。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ElementType &#123;</span><br><span class="line">    TYPE, <span class="comment">//类，接口，注解，枚举</span></span><br><span class="line">    FIELD,<span class="comment">//属性</span></span><br><span class="line">    METHOD,<span class="comment">//方法</span></span><br><span class="line">    PARAMETER,<span class="comment">//参数</span></span><br><span class="line">    CONSTRUCTOR,<span class="comment">//构造方法</span></span><br><span class="line">    LOCAL_VARIABLE,<span class="comment">//局部变量</span></span><br><span class="line">    ANNOTATION_TYPE,<span class="comment">//注解</span></span><br><span class="line">    PACKAGE,<span class="comment">//包</span></span><br><span class="line">    TYPE_PARAMETER,<span class="comment">//Type parameter declaration</span></span><br><span class="line">    TYPE_USE<span class="comment">//Use of a type</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Retention</span> </span><br><span class="line">以下三种</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RetentionPolicy &#123;</span><br><span class="line">    SOURCE,</span><br><span class="line">    CLASS,</span><br><span class="line">    RUNTIME</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Documented</span> 表示可以被javadoc工具提取成文档</span><br><span class="line"><span class="meta">@Inherited</span> 表示继承性，如果某个使用了该注解修饰的注解，那么其子类会自动具有该注解</span><br></pre></td></tr></table></figure><p>通过注解在相应的位置，我们可以在下面的注解处理器，或者反射处理，获得到我们想要的得到的数据。这就是注解的任务啦。</p><h3 id="运行处理注解"><a href="#运行处理注解" class="headerlink" title="运行处理注解"></a>运行处理注解</h3><p>通过反射获得Class对象，Method等等，从而通过getAnnotation继而获得值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> learn2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationTest test = <span class="keyword">new</span> AnnotationTest();</span><br><span class="line">        test.test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TestAnnotation</span>(msg = <span class="string">"test"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> someOne;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Class clazz = getClass();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field field = clazz.getField(<span class="string">"someOne"</span>);</span><br><span class="line">            String msg = field.getAnnotation(TestAnnotation.class).msg();</span><br><span class="line">            System.out.println(field.getAnnotation(TestAnnotation.class));</span><br><span class="line">            System.out.println(msg);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line">    <span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line">    <span class="meta">@interface</span> TestAnnotation&#123;</span><br><span class="line">        <span class="function">String <span class="title">msg</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编译处理注解"><a href="#编译处理注解" class="headerlink" title="编译处理注解"></a>编译处理注解</h3><p>编译时处理注解，生成java文件</p><h3 id="处理注解时的相关类和API"><a href="#处理注解时的相关类和API" class="headerlink" title="处理注解时的相关类和API"></a>处理注解时的相关类和API</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//接口</span><br><span class="line">AnnotatedElement // 被注解的元素，这个接口声明的方法包含了一些获得注解注解对象的方法</span><br><span class="line">AnnotatedType //被注解的类型，有一个getType的方法//这些接口都从1.8开始的，感觉和泛型相关</span><br><span class="line">AnnotatedArrayType //被注解的数组类型</span><br><span class="line">AnnotatedParameterizedType//被注解的参数化类型 </span><br><span class="line">AnnotatedTypeVariable//被注解的类型变量</span><br><span class="line">AnnotatedWildcardType//被注解的统配符类型 获取上界和下界的AnnotatedType</span><br><span class="line">//类</span><br><span class="line">Filed</span><br><span class="line">Class</span><br><span class="line">Method</span><br><span class="line">Package</span><br><span class="line">Construcotr</span><br><span class="line">Paramter</span><br><span class="line">Executable</span><br><span class="line">AccessibleObject</span><br><span class="line"></span><br><span class="line">注解一个普通的int产生的AnnotatedType对象是sun.reflect.annotation.AnnotatedTypeFactory$AnnotatedTypeBaseImpl@1d44bcfa</span><br><span class="line">而注解List&lt;String&gt; list类型产生的的AnnotatedType对象是sun.reflect.annotation.AnnotatedTypeFactory$AnnotatedParameterizedTypeImpl@1d44bcfa</span><br><span class="line">而对int[] list 产生的是</span><br><span class="line">sun.reflect.annotation.AnnotatedTypeFactory$AnnotatedArrayTypeImpl@1d44bcfa</span><br><span class="line">与之对应的是那几个接口的实现类，虽然我没搞懂有啥用。。</span><br></pre></td></tr></table></figure><h3 id="其它用处"><a href="#其它用处" class="headerlink" title="其它用处"></a>其它用处</h3><p>用于设定常量</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 容器</title>
      <link href="/2019/06/30/Java-%E5%AE%B9%E5%99%A8/"/>
      <url>/2019/06/30/Java-%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="Java-容器"><a href="#Java-容器" class="headerlink" title="Java  容器"></a>Java  容器</h3><ul><li>List</li><li>Set</li><li>Map</li><li>Queue</li><li>Iterator</li><li>工具类</li><li>并发容器</li><li>android中的特殊集合</li></ul><h4 id="相关接口"><a href="#相关接口" class="headerlink" title="相关接口"></a>相关接口</h4><ul><li><p>Iterable 代表可迭代，实现的方法需要产出一个迭代器</p></li><li><p>Collection 除了Map外的祖先集合接口</p></li><li><p>List</p></li><li><p>Set</p></li><li><p>Map</p><p>Set 和 List都是一路继承Collection下来</p><p>Map则是单独的</p></li></ul><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p>定义了以套通过索引进行获取，和添加的集合</p><ul><li>ArrayList     内部是一个动态扩容的数组实现。</li><li>LinkedList   内部是一个双向链表实现</li><li>Vector 内部也是动态扩容的数组实现，不过大部分方法通过synchronized进行锁住方法，是线程安全的，但是效率不高。</li><li>Stack Vector的子类</li></ul><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>定义了一组不可重复的集合，通过哈希值来判断</p><ul><li>HashSet 内部是通过一个HashMap来实现，等同于HashMap的键，值恒为同一个Object</li><li>TreeSet 内部是通过一个TreeMap来实现</li></ul><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>定义了通过键值映射的集合</p><ul><li>HashMap 内部通过 数组 + 链表 + 红黑树进行实现的Map</li><li>TreeMap  内部通过红黑树进行实现，保持内部排序顺序</li><li>HashTable 古老实现，线程安全，效率不高</li><li>Properties key和value都是String类型</li></ul><h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><p>队列</p><h4 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h4><p>生成器，用于foreach循环</p><h4 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h4><ul><li>Arrays包含了许多对数组进行排序，复制等操作的工具类</li><li>Collections包含许多对集合进行操作</li><li>Comparators包含对比较器的工具</li></ul><h4 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h4><p>以上中只有Vectoer和HashTable是线程安全的，但是它是将整个集合都锁住了，效率不高。</p><ul><li>CopyOnWriteArryList</li><li>CopyOnWriteArraySet 写时复制，在写入的时候创建一个副本进行写入，当迭代多于修改，应该使用写时复制容器</li><li>ConcurrentHashMap </li><li>ConcurrentSkipListSet </li><li>阻塞队列</li></ul><p>ConcurrentMap容器:1.8以前采用锁分段技术，1.8开始使用CAS无锁技术。</p><h4 id="android中特殊容器"><a href="#android中特殊容器" class="headerlink" title="android中特殊容器"></a>android中特殊容器</h4><p>SparseArray 使用稀疏数组实现的一个key为int，value为Object的集合</p><p>LongSparseArray key为long value为object</p><p>SparseLongArray key为int value为long</p><p>SparseBooleanArray key为int value为boolean</p><p>SparseIntArray key为int value为int</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 基础知识梳理</title>
      <link href="/2019/06/30/Java-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"/>
      <url>/2019/06/30/Java-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="Java-基础内容"><a href="#Java-基础内容" class="headerlink" title="Java  基础内容"></a>Java  基础内容</h3><ul><li>数据类型</li><li>运算符</li><li>流程控制</li><li>面向对象</li><li>重要关键字</li><li>异常</li><li>编码</li><li>Object类</li></ul><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>计算机中最小的单位是bit，一个位0/1表示</p><h5 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h5><ul><li><p>byte  1字节 </p></li><li><p>short 2字节 </p></li><li><p>int  4字节</p></li><li><p>long 8字节</p></li><li><p>float 4字节</p></li><li><p>double 8字节</p></li><li><p>boolean 1字节</p></li><li><p>char 2字节 可以为unicode编码，位于栈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a = <span class="string">'\u1233'</span>;<span class="comment">//unicode编码表达</span></span><br></pre></td></tr></table></figure></li></ul><p>引用数据类型：引用位于栈，引用的对象位于堆</p><p>高精度向低精度可能丢失，表达式中默认转换为当前表达式的最大精度进行计算</p><h5 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h5><ul><li>基础运算符</li><li>instanceof 用于判断对象是否是某类型</li></ul><h4 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h4><ul><li><p>if else</p></li><li><p>if elseif </p></li><li><p>while</p></li><li><p>do while</p></li><li><p>for</p></li><li><p>foreach 需要容器实现Iterable接口和Iterator接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(SomeType obj: objList) &#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><p>关键字extends，类的继承和接口的继承</p><h5 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h5><p>访问控制private，default，protected，public</p><h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h5><p>通过父类或者接口引用访问实际对象的方法，称为动态绑定，实在运行时才能决定的。</p><h5 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h5><p>静态绑定，即同名方法存在不同的参数列表（类型，数量）</p><h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><p>成员和方法修饰为public ，实现的类需要实现方法，与接口间可以继承。只有声明，但是新版jdk可以存在默认方法，使用default定义</p><h5 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h5><p>匿名内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只是将匿名内部类复制给了一个引用，其实再参数传递中的内部类，同样也是将匿名内部类对象传递给了，临时的引用。</span></span><br><span class="line">   <span class="comment">//方法实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    B b = <span class="keyword">new</span> B()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成员内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        B b = a.new B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class A&#123;</span><br><span class="line"><span class="keyword">static</span> B&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">B b = <span class="keyword">new</span> A.B();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部类可以和成员一样访问外部类的成员。</p><p>匿名内部类对象在访问方法参数，参数需要定义为final，因为在方法中一旦一开，参数的生命周期也就结束了，但是匿名内部类对象还引用着，通过使用final来拷贝一份使用，间接的延长了生命周期，也就可以正常访问了。</p><h5 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h5><ul><li>强引用 只要持有强引用，JVM宁可抛出内存泄漏也不愿意去回收</li><li>软引用 在没有强引用的情况下且内存不足情况下会去回收对象</li><li>弱引用 在没有强引用的情况下回去回收对象</li><li>虚引用 形同虚设，常用于jvm内部跟踪垃圾回收过程</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你好, Hexo</title>
      <link href="/2019/06/29/%E4%BD%A0%E5%A5%BD-Hexo/"/>
      <url>/2019/06/29/%E4%BD%A0%E5%A5%BD-Hexo/</url>
      
        <content type="html"><![CDATA[<h3 id="你好，Hexo"><a href="#你好，Hexo" class="headerlink" title="你好，Hexo"></a>你好，Hexo</h3><h4 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h4><p>首先用hexo搭建博客还是蛮爽的，基本只需要配置加上写md文件即可，颜值高的我都想学前端了2333。最近我是想着准备找新工作了，但是呢，得复习知识，而我基本上又不怎么喜欢归纳知识，即使是归纳也只用印象笔记做做速记，所以我感觉自己很虚，太浮躁了。但是看别人得博客，他们怎么能写这么多呀！于是我觉得我得认真对待做笔记这件事了，写的博客不能像以前写速记似的。</p><p>抛开关于工作学习上事情，其实用博客来记录生活也很必要。</p><a id="more"></a><p>第一、我表达能力不过关，有时候后脑子可以想很多话语，但是落实到口头综合起来就不是一回事了，想法千奇百怪，转瞬即逝，综合到嘴巴说出来的就更少了。究其原因是我的语文水平驾驭不住这些意识，呃呃（比如现在2333），也就是俗称的看书看少了，写东西写少了。对于文字掌控能力，我感觉是其它很多技能的基础，所以咯，得做！</p><p>第二、 记忆对抗，现在我闭上眼睛，一周平平淡淡，竟然回忆不到太多事情，随着时间的推移，能留在我记忆中东西更是少之又少，甚至我得拼命回忆才能回想到曾今得同学以及生活得情。尽可能得通过博客来记录生活的轨迹。我不想过的虚无缥缈。</p><p>第三、写博客，是一次和自己对话的机会，试问有多久没有静下心来和自己对话了（其实就是反省2333）。</p><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><ul><li>坚持写</li><li>认真总结并写出技术类文章 （虽然目前写的东西是真的水，我会改善的！！）</li><li>有什么想法以及能记录一定要记录</li><li>待完善。。。</li></ul><p>明明在路上的时候还想了待会要写啥的，结果呃呃，这个字数和水平还不到一篇作文。shit，看吧，有多重要了。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/06/29/hello-world/"/>
      <url>/2019/06/29/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
