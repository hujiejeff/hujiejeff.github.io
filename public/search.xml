<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Kotlin-函数与lambda</title>
      <link href="/2020/02/10/Kotlin-%E5%87%BD%E6%95%B0%E4%B8%8Elambda/"/>
      <url>/2020/02/10/Kotlin-%E5%87%BD%E6%95%B0%E4%B8%8Elambda/</url>
      
        <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>函数应该市不陌生了。在kotlin中使用<code>fun</code>标志函数。标准格式如下，返回值为<code>Unit</code>即空时，省略不写返回类型</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">funName</span><span class="params">(param: <span class="type">ParamType</span>)</span></span>: ReturnType&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说说和java中不一样的。也是其他现代语言基本有的特点</p><h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p>允许默认参数值，减少重载函数的数量。调用时后项可以省略</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(name: <span class="type">String</span>, age: <span class="type">Int</span> = <span class="number">10</span>)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="具名参数"><a href="#具名参数" class="headerlink" title="具名参数"></a>具名参数</h2><p>像php那样，不需要关注参数位置，通过按照按照参数名进行传递参数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(name: <span class="type">String</span>, age: <span class="type">Int</span>, mes: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test(age = <span class="number">10</span>, mes = <span class="string">"hello"</span>, name =<span class="string">"jack"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在参数比较多时，使用具名参数，代码可读性大大提高</p><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>可变长参数，java中也有，相当于一个变长的数组</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(<span class="keyword">vararg</span> strings: <span class="type">String</span>)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test(<span class="string">"hello"</span>)</span><br><span class="line">    test(<span class="string">"aa"</span>, <span class="string">"bb"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单表达式函数"><a href="#单表达式函数" class="headerlink" title="单表达式函数"></a>单表达式函数</h2><p>在某些比较简单的函数体，可能是一个表达，此时函数可以进行简写，不需要写括号之类。虽然返回类型可以进行推断，但是为了可读性尽量描述返回类型。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getMes</span><span class="params">(a: <span class="type">Int</span>)</span></span>: String = <span class="keyword">if</span>(a &gt; <span class="number">3</span>) <span class="string">"a &gt; 3"</span> <span class="keyword">else</span> <span class="string">"a &lt;= 3"</span></span><br></pre></td></tr></table></figure><h2 id="中缀表示法"><a href="#中缀表示法" class="headerlink" title="中缀表示法"></a>中缀表示法</h2><p>标志使用<code>infix</code>的函数是中缀函数</p><ul><li>它们必须是成员函数或扩展函数；</li><li>它们必须只有一个参数；</li><li>其参数不得接受可变数量的参数且不能有默认值。</li></ul><p>通过中缀表示可以写出类似自然语言的代码。比如kotlin内部的位操作，</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="built_in">Int</span>.<span class="title">shl</span><span class="params">(x: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123; …… &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用中缀表示法调用该函数</span></span><br><span class="line"><span class="number">1</span> shl <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于这样</span></span><br><span class="line"><span class="number">1</span>.shl(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h2 id="局部函数"><a href="#局部函数" class="headerlink" title="局部函数"></a>局部函数</h2><p>局部作用域也是可以声明函数的。局部函数可以访问外部函数的变量</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(graph: <span class="type">Graph</span>)</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(current: <span class="type">Vertex</span>, visited: <span class="type">MutableSet</span>&lt;<span class="type">Vertex</span>&gt;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited.add(current)) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> (v <span class="keyword">in</span> current.neighbors)</span><br><span class="line">            dfs(v, visited)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(graph.vertices[<span class="number">0</span>], HashSet())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h1><p>在kotln的世界，函数使用非常频繁。函数可以作为一个个体进行传递，这就促生了一种用来描述函数类型的语言结构。而根据这个函数类型而描述的语言结构，除了函数，还有lambda。其实二者几乎可以等同。</p><h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><p>函数类型通常描述为<code>(A,B) -&gt; C</code>这样的结构，即参数加返回值。为了方便阅读，括号尽量加上。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> action: ((String) -&gt; String) = &#123; string -&gt;</span><br><span class="line">    println(<span class="string">"string"</span>)</span><br><span class="line">    string + <span class="string">"ff"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就是一个简单的函数类型声明的函数变量，而对于函数变量的赋值的就是括号后面的lambda表达式，第一行用于书写参数，最后一行用于书写返回值。不需要return</p><p>而函数和lambda也是可以赋值的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> action: ((String) -&gt; String) = &#123; string -&gt;</span><br><span class="line">    println(<span class="string">"string"</span>)</span><br><span class="line">    string + <span class="string">"ff"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> action2: (String) -&gt; String = action</span><br><span class="line"><span class="keyword">val</span> action3: (String) -&gt; String = ::test<span class="comment">//引用传递</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(string: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>充分的说明了在kotlin，函数可以像一个变量一样传递使用。这样称之为函数字面值</p><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>函数字面值除了lambda可以实例，同样使用匿名函数也是可以实例的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> action4: (String) -&gt; String = <span class="function"><span class="title">fun</span> <span class="params">(string: <span class="type">String</span>)</span></span>:String &#123;</span><br><span class="line">   <span class="keyword">return</span> string + <span class="string">"匿名函数"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结来说，匿名函数和lambda都属于为声明的函数。匿名函数可读较好，lambda较为简洁。</p><p>lambda内部存在一个<code>it</code>参数，指代单参数。即在lambda的第一行可以不写参数名，内部使用<code>it</code>代替</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> action: ((String) -&gt; String) = &#123;</span><br><span class="line">    println(<span class="string">"string"</span>)</span><br><span class="line">    it + <span class="string">"ff"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结合扩展"><a href="#结合扩展" class="headerlink" title="结合扩展"></a>结合扩展</h2><p>既然lambda是一种特殊的函数，当然也是可以使用扩展的，于是也能够获取到<code>this</code></p><p>而且当函数的最后一个参数为函数类型时，可以将lambda写到括号外，如下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(name: <span class="type">String</span>, action: (<span class="type">String</span> -&gt; <span class="type">Unit</span>)</span></span>) &#123;</span><br><span class="line">    println(<span class="string">"action before"</span>)</span><br><span class="line">    action(name)</span><br><span class="line">    println(<span class="string">"action after"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test(<span class="string">"jack"</span>, &#123;string -&gt; prinln(string + <span class="string">"test action"</span>)&#125;)<span class="comment">//普通写法</span></span><br><span class="line">    test(<span class="string">"jack"</span>) &#123;string -&gt;     </span><br><span class="line">        prinln(string + <span class="string">"test action"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是就出现了以代码方式书写UI代码。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HTML</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">body</span><span class="params">()</span></span> &#123; …… &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">html</span><span class="params">(<span class="keyword">init</span>: <span class="type">HTML</span>.()</span></span> -&gt; <span class="built_in">Unit</span>): HTML &#123;</span><br><span class="line">    <span class="keyword">val</span> html = HTML()  <span class="comment">// 创建接收者对象</span></span><br><span class="line">    html.<span class="keyword">init</span>()        <span class="comment">// 将该接收者对象传给该 lambda</span></span><br><span class="line">    <span class="keyword">return</span> html</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">html &#123;       <span class="comment">// 带接收者的 lambda 由此开始</span></span><br><span class="line">    body()   <span class="comment">// 调用该接收者对象的一个方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h1>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin-类与对象</title>
      <link href="/2020/02/07/Kotlin-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
      <url>/2020/02/07/Kotlin-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="类与继承"><a href="#类与继承" class="headerlink" title="类与继承"></a>类与继承</h1><h2 id="类的基本结构"><a href="#类的基本结构" class="headerlink" title="类的基本结构"></a>类的基本结构</h2><p>一个普通类应当包含属性、函数，构造函数，基本的样子</p><p>以下三种都是合规的申明。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>() &#123;</span><br><span class="line">    <span class="keyword">val</span> name: String</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"hello my namnis <span class="variable">$name</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="主构造函数"><a href="#主构造函数" class="headerlink" title="主构造函数"></a>主构造函数</h3><p>一个对象产生必定经过类的构造函数进行构造。在类名后面使用<code>constructor</code>进行标志，并且添加构造参数。这就是主构造函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">constructor</span></span>(name: String) &#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时<code>constructor</code>前面是可以写入访问控制符和注解的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(name: String) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有注解或者是访问修饰符。则就是可以略去<code>constructor</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>(name: String) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主构造函数看出来是只有申明的构造参数，那么在哪里进行使用这些构造参数呢，Kotlin为我们准备了一个init初始块。就相当于init就是<strong>主构造函数的函数体</strong>了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>(name: String) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _name: String</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _name2: String = name</span><br><span class="line"><span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">"constructor param is <span class="variable">$name</span>"</span>)</span><br><span class="line">        _name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以在<code>init</code>块进行初始参数的初始化操作。或者直接赋值到属性。如果是赋值到属性的话可以继续简写</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> name: String) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等同于</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>(name: String) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> name = name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就相当于直接将属性直接写到构造函数里了</p><h3 id="次构造函数"><a href="#次构造函数" class="headerlink" title="次构造函数"></a>次构造函数</h3><p>次构造函数则相对与在类名主构造函数而言的。同样也是使用<code>constructor</code>来申明，同时次构造函数必须委托给主构造函数，也即是要调用主构造函数，使用后面加上<code>:this()</code>来进行委托。同样次构造函数之间存在重载，允许有多个</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name: String, age: <span class="built_in">Int</span>): <span class="keyword">this</span>(name) &#123;</span><br><span class="line">        println(<span class="string">"次构造函数"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a = A(<span class="string">"jack"</span>)</span><br></pre></td></tr></table></figure><h3 id="类的成员"><a href="#类的成员" class="headerlink" title="类的成员"></a>类的成员</h3><ul><li>函数<ul><li>成员函数</li><li>构造函数</li></ul></li><li>属性<ul><li>普通属性</li><li>对象声明即匿名类对象</li><li>伴生对象</li></ul></li><li>类<ul><li>嵌套类</li><li>内部类</li></ul></li><li><code>init</code>块</li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>kotlin的继承是单继承的</p><p>所有的类都是Any的子类，这个和Java的Object很相似，但是只包含了<code>equals()</code>、<code>hashCode()</code>、<code>toString()</code>这三个函数。</p><p>默认情况下使用<code>class</code>进行声明的类都是不可被继承，相对与final类。若想被继承需要加上<code>open</code>关键字</p><p>使用冒号语法在类名后加上继承或者要实现的类或接口，如果父类的有主构造函数，需要显示调用。如下所示</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>(firstName: String) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">son</span></span>(firstName: String, lastName: String): Parent(firstName),I &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="覆盖函数"><a href="#覆盖函数" class="headerlink" title="覆盖函数"></a>覆盖函数</h4><p>在继承中就会涉及到覆盖重写的问题。一个方法需要配重写，则也是使用<code>open</code>进行修饰。而覆盖的函数需要加上<code>override</code>修饰。而<code>override</code>本身是继续开放的，需要关闭继承加上<code>final</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//开放继承</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span>: <span class="type">A &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//重写，继续开放继承</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>: <span class="type">B &#123;</span></span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//重写，不开放继承</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="覆盖属性"><a href="#覆盖属性" class="headerlink" title="覆盖属性"></a>覆盖属性</h4><p>类似覆盖函数，同样使用open和override进行。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">val</span> name: String = <span class="string">"jack"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>: <span class="type">A &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> name: String = <span class="string">"jackie"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意var可以覆盖val，反之不行</p></blockquote><h4 id="调用超类"><a href="#调用超类" class="headerlink" title="调用超类"></a>调用超类</h4><p>使用<code>super</code>关键字</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>: <span class="type">A &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.test()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及父类或者接口具有同名覆盖方法时</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>: <span class="type">A</span>, <span class="type">B&#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>&lt;A&gt;.test()<span class="comment">//调用A的实现</span></span><br><span class="line">        <span class="keyword">super</span>&lt;B&gt;.test()<span class="comment">//调用B的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及当环境不同时，比如在内部类中要访问外部类的超类实现。通过@限定来实现。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">super@</span>Outer.func()</span><br></pre></td></tr></table></figure><p>this也有同样的使用方式。调用外部类实现</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span><span class="symbol">@Outer</span>.func()</span><br></pre></td></tr></table></figure><h2 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h2><p>注意：接口方法是和Java8一样是可以存在默认实现的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//可以存在默认实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="属性与字段"><a href="#属性与字段" class="headerlink" title="属性与字段"></a>属性与字段</h1><p>其实本来这两者是作为方便使用，可以看成是对应着Java里的字段和get/set方法。只不过这里的话通过声明属性，可以不需要手动写get/set函数了。</p><h2 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h2><p>首先字段其实就是类中的一个量。通过<code>var</code>和<code>val</code>，因为默认下kotlin的非空元素，所以必须要声明时指定值，或设置懒初始化。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> name: String = <span class="string">"jack"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>其实属性和字段的区别就是，属性 = 字段 + get / set 函数。而此时这个属性在内部使用存储标志就是<code>field</code>关键字标志的幕后字段。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: String = <span class="string">"jack"</span></span><br><span class="line">    <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            println(<span class="string">"set"</span>)</span><br><span class="line">            field = value</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">            println(<span class="string">"get"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样我们可以不用幕后字段，使用我们自己的字段，即用<code>private</code>声明的量</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> _name: String = <span class="string">"jack"</span></span><br><span class="line">    <span class="keyword">val</span> name: String</span><br><span class="line">    <span class="keyword">get</span>() = _name</span><br><span class="line">    <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            _name = value</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实说白了就是将get/set和变量放到了一起，在不自定义时，使用默认的的get/set实现以消除模板代码。对于属性的访问也是通过get/set函数进行访问获取修改的。</p><p>如果还是糊涂的可以，将上述的例子进行反编译，看看java，会发现特别简单。就是帮助写模板的get/set函数的。</p><h2 id="延迟初始化"><a href="#延迟初始化" class="headerlink" title="延迟初始化"></a>延迟初始化</h2><p><code>val</code>的量一定要一开始初始化，要么直接赋值，要么在<code>init</code>块中初始化</p><p><code>var</code>的量要么一开始初始化赋值，要么在前面加上<code>lateinit</code>指定随后在某个地方延迟初始化。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> name: String</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> age: String<span class="comment">//随后在某个地方初始化</span></span><br><span class="line">    <span class="keyword">init</span>&#123;</span><br><span class="line">        name = <span class="string">"jack"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断是否初始化，通过获得字段的引用对象判断。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> name: String</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(A::name.isInitialized) &#123;</span><br><span class="line">            println(<span class="string">"inited"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="可见修饰符"><a href="#可见修饰符" class="headerlink" title="可见修饰符"></a>可见修饰符</h1><p>对于类、对象、函数存在可见修饰符。注意，函数同时也包括了，构造函数，get/set函数等函数</p><h2 id="public"><a href="#public" class="headerlink" title="public"></a>public</h2><p>默认不指定即为public，则随处可见</p><h2 id="private"><a href="#private" class="headerlink" title="private"></a>private</h2><p>对于文件来说即使当前文件可见，对于类来说就当前类可见</p><h2 id="internal"><a href="#internal" class="headerlink" title="internal"></a>internal</h2><p>本模块可见，模块即一块儿编译的代码集合。反正android中项目模块对应这个</p><h2 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h2><p>本类 + 子类可见</p><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><h2 id="扩展函数"><a href="#扩展函数" class="headerlink" title="扩展函数"></a>扩展函数</h2><p>kotlin允许为某个类进行静态增加函数。我们只需要以<code>fun 类名.扩展函数名(){}</code>进行书写即可，并且函数内部是可以获得到该对象的，即<code>this</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="built_in">Int</span>.<span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">println(<span class="string">"sayHello by "</span> + <span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> age: <span class="built_in">Int</span> = <span class="number">10</span></span><br><span class="line">    age.sayHello()<span class="comment">//输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这只是静态的增加，并没有真正意义的为该类增加函数</p><h2 id="扩展属性"><a href="#扩展属性" class="headerlink" title="扩展属性"></a>扩展属性</h2><p>其实就是扩展了set或者get函数，并不能插入字段。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> List.lastIndex: <span class="built_in">Int</span></span><br><span class="line"><span class="keyword">get</span>() = size + <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="伴生对象也可以扩展"><a href="#伴生对象也可以扩展" class="headerlink" title="伴生对象也可以扩展"></a>伴生对象也可以扩展</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123; &#125;  <span class="comment">// 将被称为 "Companion"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> MyClass.Companion.<span class="title">printCompanion</span><span class="params">()</span></span> &#123; println(<span class="string">"companion"</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    MyClass.printCompanion()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h1><p>通常在Java中我们需要创建大量的POJO类，同时也需要书写大量的模板代码，在kotlin中，我们直接将这种POJO类，使用数据类来定义。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure><p>这个一行代码就完成了下面巴拉巴拉一串Java模板代码的功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Peson</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(String age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即使时数据类，仍然还是Any的子类，所以含有<code>equals()</code>、<code>hashCode()</code>、<code>toString()</code>·以及一个克隆函数<code>copy()</code></p><p>除了在构造函数申明的属性之外，还可以有在类结构中声明的，但是类结构中声明的不会加入计算toString、equals、hashCode中。</p><h2 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Name</span></span>(<span class="keyword">val</span> n: String)</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> name = Name(<span class="string">"jack"</span>)</span><br><span class="line">    <span class="keyword">val</span> name2 = name.copy()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据类与解构"><a href="#数据类与解构" class="headerlink" title="数据类与解构"></a>数据类与解构</h2><p>即将数据类属性解析到量</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> jack = User(<span class="string">"jack"</span>, <span class="number">20</span>)</span><br><span class="line">    <span class="keyword">val</span> (name, age) = jack<span class="comment">//解构</span></span><br><span class="line">    println(<span class="string">"name is <span class="variable">$name</span> and age is <span class="variable">$age</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h1><p>基本</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">PlayMode</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> _value: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    SINGLE(<span class="number">0</span>), LOOP(<span class="number">1</span>), SINGLE_LOOP(<span class="number">2</span>), SHUFFLE(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> value: <span class="built_in">Int</span> <span class="keyword">get</span>() = _value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">valueOf</span><span class="params">(value: <span class="type">Int</span>)</span></span> = <span class="keyword">when</span> (value) &#123;</span><br><span class="line">            <span class="number">0</span> -&gt; SINGLE</span><br><span class="line">            <span class="number">1</span> -&gt; LOOP</span><br><span class="line">            <span class="number">2</span> -&gt; SINGLE_LOOP</span><br><span class="line">            <span class="number">3</span> -&gt; SHUFFLE</span><br><span class="line">            <span class="keyword">else</span> -&gt; LOOP</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtocolState</span> </span>&#123;</span><br><span class="line">    WAITING &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">signal</span><span class="params">()</span></span> = TALKING</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    TALKING &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">signal</span><span class="params">()</span></span> = WAITING</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">signal</span><span class="params">()</span></span>: ProtocolState</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">IntArithmetics</span> : <span class="type">BinaryOperator</span>&lt;<span class="type">Int</span>&gt;, <span class="type">IntBinaryOperator &#123;</span></span></span><br><span class="line">    PLUS &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">apply</span><span class="params">(t: <span class="type">Int</span>, u: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = t + u</span><br><span class="line">    &#125;,</span><br><span class="line">    TIMES &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">apply</span><span class="params">(t: <span class="type">Int</span>, u: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = t * u</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">applyAsInt</span><span class="params">(t: <span class="type">Int</span>, u: <span class="type">Int</span>)</span></span> = apply(t, u)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="嵌套类和内部类"><a href="#嵌套类和内部类" class="headerlink" title="嵌套类和内部类"></a>嵌套类和内部类</h1><p>因为在kotlin将面向对象概念深入了一下，即我们看不到所谓的静态方法啊、静态内部类啊等静态打头的名称。</p><h2 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h2><p>这里的嵌套类其实工作方式相似与Java的静态内部类。不会持有外部引用，即单纯的嵌套的类，相当于在类的内部多了一个类的声明</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Nester</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>这个内部类就相似于Java的内部类，需要加以额外的<code>Inner</code>关键字标志。这个内部类则是可以外部类的对象的引用</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        pirntln(<span class="string">"Outer test"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">this</span><span class="symbol">@Outer</span>.test()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>使用对象表达式创建匿名的类实例。<code>object</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">netMusicDataSource.loadPlaylistDetail(id, <span class="keyword">object</span> : Callback&lt;PlayListDetailResponse&gt;&#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onLoaded</span><span class="params">(t: <span class="type">PlayListDetailResponse</span>)</span></span> &#123;</span><br><span class="line">                cachePlayListDetail = t.playlist</span><br><span class="line">                callback.onLoaded(cachePlayListDetail!!)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailed</span><span class="params">(mes: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">                callback.onFailed(mes)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><p>如果时函数式接口即只有一个函数。可以继续简写<code>Observer{}</code>这样类似的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">musicDataLoading.observe(homeActivity, Observer &#123; isLoading -&gt;</span><br><span class="line">                view?.rv_list?.visibility = <span class="keyword">if</span> (isLoading) View.INVISIBLE <span class="keyword">else</span> View.VISIBLE</span><br><span class="line">                <span class="keyword">if</span> (isLoading) &#123;</span><br><span class="line">                    view?.loading_view?.show()</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    view?.loading_view?.hide()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><p>Kotlin中的真的万物皆对象，静态的概念直接巧妙的转化为了对象。现在我多少有点能理解Js中的面向对象编程的继承方式是原型继承。</p><h2 id="对象表达式"><a href="#对象表达式" class="headerlink" title="对象表达式"></a>对象表达式</h2><p>使用object进行继承类继而创建对象</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.addMouseListener(<span class="keyword">object</span> : MouseAdapter() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseClicked</span><span class="params">(e: <span class="type">MouseEvent</span>)</span></span> &#123; <span class="comment">/*……*/</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseEntered</span><span class="params">(e: <span class="type">MouseEvent</span>)</span></span> &#123; <span class="comment">/*……*/</span> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>有时候不需要继承，只是简单的聚合</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> xy = <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> x: <span class="built_in">Int</span> = <span class="number">10</span></span><br><span class="line">    <span class="keyword">val</span> y: <span class="built_in">Int</span> = <span class="number">20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象声明"><a href="#对象声明" class="headerlink" title="对象声明"></a>对象声明</h2><p>声明式的创建一个有名称的对象。单例，就像声明一个类并且创建一个对象这句话。内容的写法和类相同但是没有构造函数了。而且创建过程是线程安全，和Java的中的饿汉单例一样。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Preference &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> param: <span class="built_in">Int</span> = <span class="number">10</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"test : "</span>+ param)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Preference.test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h2><p>在kotlin没有静态，于是出现了一个伴生对象的概念。类拥有伴生对象。使用对象声明描述，可以通过类名直接访问伴生对象成员。功能相似与Java的静态成员</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> CompanionObject &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    A.hello()</span><br><span class="line">    A.CompanionObject.hello()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个伴生对象是可以带名字的，同样也可以省略。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A.hello()</span><br><span class="line">A.CompanionObject.hello()</span><br></pre></td></tr></table></figure><p>两种访问方法是都是可以的</p><p>若是没有指定伴生对象的名称，则以<code>Companion</code>表示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.Companion.hello()</span><br></pre></td></tr></table></figure><p>倘若要想变成和Java一样的静态方法，需要在成员加上<code>@JvmStatic</code>就可以变成真正的静态成员</p><p><strong>对象表达式和对象声明之间的语义差异</strong></p><p>对象表达式和对象声明之间有一个重要的语义差别：</p><ul><li>对象表达式是在使用他们的地方<strong>立即</strong>执行（及初始化）的；</li><li>对象声明是在第一次被访问到时<strong>延迟</strong>初始化的；</li><li>伴生对象的初始化是在相应的类被加载（解析）时，与 Java 静态初始化器的语义相匹配。</li></ul><h1 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h1><p>给类型去别名，简写或者区分</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> NodeSet = Set&lt;Network.Node&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typealias</span> FileTable&lt;K&gt; = MutableMap&lt;K, MutableList&lt;File&gt;&gt;</span><br></pre></td></tr></table></figure><h1 id="内联类"><a href="#内联类" class="headerlink" title="内联类"></a>内联类</h1><h1 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h1><p>委托模式实现继承</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseImpl</span></span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>) : Base &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span> &#123; print(x) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span></span>(b: Base) : Base <span class="keyword">by</span> b</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> b = BaseImpl(<span class="number">10</span>)</span><br><span class="line">    Derived(b).print()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>覆盖优先委托</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">printMessage</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">printMessageLine</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseImpl</span></span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>) : Base &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">printMessage</span><span class="params">()</span></span> &#123; print(x) &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">printMessageLine</span><span class="params">()</span></span> &#123; println(x) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span></span>(b: Base) : Base <span class="keyword">by</span> b &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">printMessage</span><span class="params">()</span></span> &#123; print(<span class="string">"abc"</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> b = BaseImpl(<span class="number">10</span>)</span><br><span class="line">    Derived(b).printMessage()<span class="comment">//abc</span></span><br><span class="line">    Derived(b).printMessageLine()<span class="comment">//10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>委托对象的成员只能访问其自身对接口成员实现</p><h1 id="属性委托"><a href="#属性委托" class="headerlink" title="属性委托"></a>属性委托</h1><p>将属性交由其他方式来实现，比如</p><ul><li>延迟属性：首次访问计算</li><li>可观察属性：监听器会收到有关此属性变更的通知；</li><li>映射：把多个属性储存在一个映射（map）中，而不是每个存在单独的字段中。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> kotlin.reflect.KProperty</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Delegate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"<span class="variable">$thisRef</span>, thank you for delegating '<span class="subst">$&#123;property.name&#125;</span>' to me!"</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">"<span class="variable">$value</span> has been assigned to '<span class="subst">$&#123;property.name&#125;</span>' in <span class="variable">$thisRef</span>."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p: String <span class="keyword">by</span> Delegate()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> e = Example()</span><br><span class="line">println(e.p)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Example@33a17727, thank you for delegating ‘p’ to me!</span></span><br></pre></td></tr></table></figure><p>而kotlin提供几种委托实现</p><h2 id="延迟属性-Lazy"><a href="#延迟属性-Lazy" class="headerlink" title="延迟属性 Lazy"></a>延迟属性 Lazy</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> lazyValue: String <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    println(<span class="string">"computed!"</span>)</span><br><span class="line">    <span class="string">"Hello"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(lazyValue)</span><br><span class="line">    println(lazyValue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lazy后仅执行一次，延迟</p><p>默认情况下，对于 lazy 属性的求值是<strong>同步锁的（synchronized）</strong>：该值只在一个线程中计算，并且所有线程会看到相同的值。如果初始化委托的同步锁不是必需的，这样多个线程可以同时执行，那么将 <code>LazyThreadSafetyMode.PUBLICATION</code> 作为参数传递给 <code>lazy()</code> 函数。 而如果你确定初始化将总是发生在与属性使用位于相同的线程， 那么可以使用 <code>LazyThreadSafetyMode.NONE</code> 模式：它不会有任何线程安全的保证以及相关的开销。</p><h2 id="可观察属性-Observable"><a href="#可观察属性-Observable" class="headerlink" title="可观察属性 Observable"></a>可观察属性 Observable</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.properties.Delegates</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: String <span class="keyword">by</span> Delegates.observable(<span class="string">"&lt;no name&gt;"</span>) &#123;</span><br><span class="line">        prop, old, new -&gt;</span><br><span class="line">        println(<span class="string">"<span class="variable">$old</span> -&gt; <span class="variable">$new</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> user = User()</span><br><span class="line">    user.name = <span class="string">"first"</span></span><br><span class="line">    user.name = <span class="string">"second"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在值变化触发监听</p><p>如果你想截获赋值并“否决”它们，那么使用 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-delegates/vetoable.html" target="_blank" rel="noopener"><code>vetoable()</code></a> 取代 <code>observable()</code>。 在属性被赋新值生效<em>之前</em>会调用传递给 <code>vetoable</code> 的处理程序。</p><h2 id="把属性储存在映射中"><a href="#把属性储存在映射中" class="headerlink" title="把属性储存在映射中"></a>把属性储存在映射中</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> map: Map&lt;String, Any?&gt;) &#123;</span><br><span class="line">    <span class="keyword">val</span> name: String <span class="keyword">by</span> map</span><br><span class="line">    <span class="keyword">val</span> age: <span class="built_in">Int</span>     <span class="keyword">by</span> map</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> user = User(mapOf(</span><br><span class="line">    <span class="string">"name"</span> to <span class="string">"John Doe"</span>,</span><br><span class="line">    <span class="string">"age"</span>  to <span class="number">25</span></span><br><span class="line">))</span><br><span class="line"></span><br><span class="line">println(user.name) <span class="comment">// Prints "John Doe"</span></span><br><span class="line">println(user.age)  <span class="comment">// Prints 25</span></span><br></pre></td></tr></table></figure><p>这也适用于 <em>var</em> 属性，如果把只读的 <code>Map</code> 换成 <code>MutableMap</code> 的话：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MutableUser</span></span>(<span class="keyword">val</span> map: MutableMap&lt;String, Any?&gt;) &#123;</span><br><span class="line">    <span class="keyword">var</span> name: String <span class="keyword">by</span> map</span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span>     <span class="keyword">by</span> map</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="局部委托"><a href="#局部委托" class="headerlink" title="局部委托"></a>局部委托</h2>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kotlin-协程</title>
      <link href="/2019/12/19/Kotlin-%E5%8D%8F%E7%A8%8B/"/>
      <url>/2019/12/19/Kotlin-%E5%8D%8F%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>dd第一眼在kotlin官方文档中看到协程，哇什么东西，好像很厉害的样子。而文档中讲述线程之类的却不如它多，第一是因为kotlin可以运行在jvm中，自然是可以现成用java的并发库，所以也就简单的讲了讲。第二就是它希望开发者使用协程。关于协程的概念很多，有些语言有而有些没有。这里的话我们就只讲kotlin中的协程。</p><h1 id="what-and-why：什么是协程，为什么用协程"><a href="#what-and-why：什么是协程，为什么用协程" class="headerlink" title="what and why：什么是协程，为什么用协程"></a>what and why：什么是协程，为什么用协程</h1><p>关于名词解释有很多，比如官方文档：“本质上，协程是轻量级的线程”。还有“协作式”等等，乍一看，哦好像懂了。其实还是不懂，像极了学习计算机网络中的各种抽象的名词概念，而我们又拼命的想只知道这是什么，为什么叫协程。它和线程怎么比较。其实本质上名词只是指代一个具体事物的映射。所以当我们用抽象的东西去解释抽象东西，第一次真的想破头。所以我们不去管为啥叫协程，它的专业解释是什么。我们来看看它具体干了啥事，有什么用。有了具体事物就可以映射概念了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        println(<span class="string">"hello"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"world"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个协程的helloworld代码，有一个<code>GlobalScope</code>的单例对象。持有一个<code>CoroutineContext</code>上下文对象</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">object</span> GlobalScope : kotlinx.coroutines.CoroutineScope &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">open</span> <span class="keyword">val</span> coroutineContext: kotlin.coroutines.CoroutineContext </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>去调用扩展函数<code>launch</code>，下面的时<code>lauchd</code>的函数声明</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> kotlinx.coroutines.CoroutineScope.<span class="title">launch</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    context: <span class="type">kotlin</span>.<span class="type">coroutines</span>.<span class="type">CoroutineContext</span> , </span></span></span><br><span class="line"><span class="function"><span class="params">    start: <span class="type">kotlinx</span>.<span class="type">coroutines</span>.<span class="type">CoroutineStart</span> , </span></span></span><br><span class="line"><span class="function"><span class="params">    block: <span class="type">suspend</span> <span class="type">kotlinx</span>.<span class="type">coroutines</span>.<span class="type">CoroutineScope</span>.()</span></span> -&gt; kotlin.<span class="built_in">Unit</span>): kotlinx.coroutines.Job</span><br><span class="line">&#123; </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前两个参数应该是有默认参数（用idea看的没有看到源码）。我们<code>launch</code>括号后面的其实是一个lambda（函数字面值，表达式）承载着具体的执行代码。launch返回的是<code>Job</code>。并且执行代码。可以说<code>lauch</code>括号内执行这个过程就是一个协程。其实说白了就是一段程序的执行，加上一些特殊效果就被定义为协程。那么什么特殊的效果呢？</p><p><code>launch</code>中的有<code>CoroutineContext</code>是可以指定协程运行的环境的。大家都知道进程是计算机资源分配的最小单位，线程是cpu执行的最小单位。而协程就是在线程上执行的有特殊效果的代码片段。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    GlobalScope.launch(Dispatchers.Default) &#123;</span><br><span class="line">        println(<span class="string">"hello"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class="line">        println(<span class="string">"hello"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    GlobalScope.launch(Dispatchers.IO) &#123;</span><br><span class="line">        println(<span class="string">"hello"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    GlobalScope.launch(Dispatchers.Unconfined) &#123;</span><br><span class="line">        println(<span class="string">"hello"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"world"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码开启了四个协程。每个协程都运行在不同的线程环境中。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Dispatchers.Default<span class="comment">//默认</span></span><br><span class="line">Dispatchers.Main<span class="comment">//主线程</span></span><br><span class="line">Dispatchers.IO<span class="comment">//IO线程</span></span><br><span class="line">Dispatchers.Unconfined<span class="comment">//计算线程</span></span><br></pre></td></tr></table></figure><p>我们通过指定环境很轻松的就切换了线程。这就是协程的特性。在Android中我们常常因为耗时操作需要去将代码运行在IO线程，在运行完毕后需要切换回UI线程，然后又因为业务问题有需要切换。这样切来切去也是常有的事。但是切换通常需要大量的回调和不清晰的代码来执行。你可能想到了使用RxJava来实现比较方便的线程切换。而kotlin通过协程库帮我我们做到了类似RxJava的操作，虽然两者实现思想不一样，但是相对于原来的回调好用、清晰、方便。所以总结下来就是<strong>kotlin协程库就是方便我们操作线程的一个库，而kotlin协程则是一个运行在线程上的更小的代码单位</strong>。</p><p>通俗的搞清楚了kotin协程是什么后，为什么用协程已经不言而喻。为了更加方便的线程切换，更加可阅读性代码。接下来就看看怎么用吧</p><h1 id="how"><a href="#how" class="headerlink" title="how"></a>how</h1><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><p>作为额外的扩展依赖</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//                                       👇 依赖协程核心库</span></span><br><span class="line">    implementation <span class="string">"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.1"</span></span><br><span class="line">    <span class="comment">//                                       👇 依赖当前平台所对应的平台库</span></span><br><span class="line">    implementation <span class="string">"org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.1"</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建协程"><a href="#创建协程" class="headerlink" title="创建协程"></a>创建协程</h2><p>首先我们需要取得<code>CoroutineScope</code>的实例，然后通过调用<code>launch</code>基本就就是一个运行协程的创建开启。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 方法一，使用 runBlocking 顶层函数</span></span><br><span class="line">runBlocking &#123;</span><br><span class="line">    getImage(imageId)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二，使用 GlobalScope 单例对象</span></span><br><span class="line"><span class="comment">// 可以直接调用 launch 开启协程</span></span><br><span class="line">GlobalScope.launch &#123;</span><br><span class="line">    getImage(imageId)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法三，自行通过 CoroutineContext 创建一个 CoroutineScope 对象</span></span><br><span class="line"><span class="comment">//  需要一个类型为 CoroutineContext 的参数</span></span><br><span class="line"><span class="keyword">val</span> coroutineScope = CoroutineScope(context)</span><br><span class="line">coroutineScope.launch &#123;</span><br><span class="line">    getImage(imageId)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一种是会阻塞线，效果相当于<code>Thread.sleep()</code>的效果，适用于单元测试。</p><p>第二种的话使用了一个全局的scope对象，如果用这个的话，相当于把协程和全局的生命周期绑定在一起了。不能及时取消协程，不推荐。</p><p>第三种通过手动的方式构建。</p><h2 id="指定运行线程"><a href="#指定运行线程" class="headerlink" title="指定运行线程"></a>指定运行线程</h2><p>在开头的介绍的中说明了，在线程中存在很多的回调以及层级等待，线程切换。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">coroutineScope.launch(Dispatchers.IO) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置协程的运行环境。</p><p>比如常见的Android中网络图片加载</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">coroutineScope.launch(Dispatchers.IO) &#123;</span><br><span class="line">    <span class="keyword">val</span> image = getImage(imageId)<span class="comment">//加载图片</span></span><br><span class="line">    launch(Dispatch.Main) &#123;</span><br><span class="line">        avatarIv.setImageBitmap(image)<span class="comment">//切回到主线程执行协程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>withContext</code>指定环境</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">coroutineScope.launch(Dispachers.Main) &#123;</span><br><span class="line">    ...</span><br><span class="line">    withContext(Dispachers.IO) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    withContext(Dispachers.IO) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是目前还是将代码杂糅在一个地方，如果我们继续将带协程执行放在函数里面，这就成为了一个挂起函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//👇</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getImage</span><span class="params">(imageId: <span class="type">Int</span>)</span></span> = withContext(Dispatchers.IO) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>挂起的意思其实就是标志下，这里面有个协程会执行，并且可能要花一些时间的意思。调用这个协程的协程后续代码要待会才能继续执行。比如上菜的服务员告诉厨师做什么菜，然后厨师告诉他我要做10分钟，你才能来取菜。所以服务员就不能立马取菜。其实说白了就是线程切换等待通信知识，只不过操作更加简单，控制性更强了。</p><h2 id="非阻塞式挂起"><a href="#非阻塞式挂起" class="headerlink" title="非阻塞式挂起"></a>非阻塞式挂起</h2><p>其实这玩意没啥玄乎的。通常我们在程序执行中，有耗时，有cpu，有IO操作，有UI操作。影响用户的是UI线程，所以我们将耗时操作放到其他的线程中执行。这样的感受就不那么卡了。而这里的非阻塞挂起其实就是通过线程切换调度完成的，手动的话也是可以实现，毕竟我们老干这事，不然就要ANR了。</p><blockquote><p>参考扔物线的博客</p><ul><li><a href="https://kaixue.io/kotlin-coroutines-1/" target="_blank" rel="noopener">https://kaixue.io/kotlin-coroutines-1/</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin-基础</title>
      <link href="/2019/12/12/Kotlin-%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/12/12/Kotlin-%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>首先Kotlin是可以运行再JVM中的，因为Kotlin可以编译成class，可以调用Java的库，有一定的关联程度。但是本质上上来说还是一门不同的语言，这一点要清楚。不要生硬去联想对应是Java的什么什么的。当然会有一定的关联，但那都是熟练之后考虑的事情。</p><h1 id="hello-wrold"><a href="#hello-wrold" class="headerlink" title="hello wrold!"></a>hello wrold!</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">mian</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(<span class="string">"hello world!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先kotlin文件main函数的入口不需要定义类，充分说明了kotlin是支持函数式编程的。</p><p>现代化语言不需要分号分隔行结尾</p><p>函数声明方式是形如</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">funName</span><span class="params">(argName: <span class="type">ArgType</span>)</span></span>: ReturnType &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量声明，采用后置形式，反正有关类型定义都是后置。不论是形参变量、变量、函数变量</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setName</span><span class="params">(name: <span class="type">String</span>)</span></span>&#123;&#125;<span class="comment">//形参变量后置声明</span></span><br><span class="line"><span class="keyword">var</span> num: <span class="built_in">Int</span> = <span class="number">10</span></span><br></pre></td></tr></table></figure><h1 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h1><p>Kotlin的所有东西都是对象，基础类型也是对象。所以基本类型也是可以调用成员函数的。</p><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><ul><li><code>Byte</code> 1字节</li><li><code>Short</code> 2字节</li><li><code>Int</code> 4字节</li><li><code>Long</code> 8字节</li><li><code>Float</code>  4字节</li><li><code>Double</code> 8字节</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> one = <span class="number">1</span><span class="comment">//Int</span></span><br><span class="line"><span class="keyword">val</span> threeBillion = <span class="number">3000000000</span><span class="comment">//Long</span></span><br><span class="line"><span class="keyword">val</span> oneLong = <span class="number">1L</span><span class="comment">//Long</span></span><br><span class="line"><span class="keyword">val</span> oneByte: <span class="built_in">Byte</span> = <span class="number">1</span><span class="comment">//完整声明</span></span><br></pre></td></tr></table></figure><ol><li>首先量的声明有<code>val</code>表示value值，也就是常量，<code>var</code>表示variable值，也就是变量。</li><li>量的类型可以根据右值进行自动推断。浮点值默认推断为Double，整数默认推断Int除非超过范围推断为Long，其它需要自行类型约束</li><li>给值添加后缀表示类型<code>F</code>、<code>L</code></li></ol><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a = <span class="number">10</span><span class="comment">//十进制</span></span><br><span class="line"><span class="keyword">val</span> b = <span class="number">0xF</span><span class="comment">//16进制</span></span><br><span class="line"><span class="keyword">val</span> c = <span class="number">0b1111</span><span class="comment">//二进制</span></span><br><span class="line"><span class="keyword">val</span> d = <span class="number">100_000_000L</span><span class="comment">//下划线分割便于阅读</span></span><br></pre></td></tr></table></figure><blockquote><p>tips:无八进制</p></blockquote><h3 id="表达方式"><a href="#表达方式" class="headerlink" title="表达方式"></a>表达方式</h3><p>Kotlin默认类型是非空，就是不可以为null。但是JVM原生类型是可以为空的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> boxA: <span class="built_in">Int</span>? = <span class="number">10</span><span class="comment">//通过再类型加上?表示为可空类型</span></span><br></pre></td></tr></table></figure><h3 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h3><p>kotlin不会隐式拓宽的，再运算式内会拓宽，这一点编程语言基本一致</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(num <span class="built_in">Double</span>)</span></span> &#123;</span><br><span class="line">println(num)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">mian</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> i = <span class="number">1</span></span><br><span class="line">    test(i)<span class="comment">//不匹配</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> l = <span class="number">1L</span> + <span class="number">3</span><span class="comment">//Long + Int =&gt; Long</span></span><br></pre></td></tr></table></figure><p>显示转化</p><p>直接使用toXXX即可</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a: <span class="built_in">Int</span> = <span class="number">6</span></span><br><span class="line"><span class="keyword">val</span> b: <span class="built_in">Long</span> = a.toLong()</span><br></pre></td></tr></table></figure><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">shl <span class="comment">//有符号左移</span></span><br><span class="line">shr <span class="comment">//有符号右移</span></span><br><span class="line">ushl <span class="comment">//无符号左移</span></span><br><span class="line">ushr <span class="comment">//有符号右移</span></span><br><span class="line">and <span class="comment">//位与</span></span><br><span class="line">or <span class="comment">//位或</span></span><br><span class="line">xor <span class="comment">//位异或</span></span><br><span class="line">inv <span class="comment">//位非</span></span><br><span class="line"><span class="keyword">val</span> a = <span class="number">6</span></span><br><span class="line">a.shr(<span class="number">3</span>)<span class="comment">//函数式</span></span><br><span class="line">a shlr <span class="number">3</span><span class="comment">//中缀式</span></span><br></pre></td></tr></table></figure><p>其实都是中缀函数</p><h2 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a: <span class="built_in">Char</span> = <span class="string">'a'</span></span><br><span class="line"><span class="keyword">val</span> b: <span class="built_in">Char</span> = <span class="string">'\n'</span><span class="comment">//转义</span></span><br><span class="line"><span class="keyword">val</span> c: <span class="built_in">Char</span> = <span class="string">'\uFF00'</span><span class="comment">//Unicode转义</span></span><br></pre></td></tr></table></figure><h2 id="布尔"><a href="#布尔" class="headerlink" title="布尔"></a>布尔</h2><p>仅用<code>true</code>和<code>false</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a: <span class="built_in">Boolean</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>逻辑操作符</p><ul><li><code>||</code> 短路或</li><li><code>&amp;&amp;</code> 短路与</li><li><code>!</code>逻辑非</li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>在kotlin中数组使用<code>Array</code>类表示</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span>&lt;<span class="type">T</span>&gt; <span class="keyword">private</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">    <span class="keyword">val</span> size: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(index: <span class="type">Int</span>)</span></span>: T</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">set</span><span class="params">(index: <span class="type">Int</span>, value: <span class="type">T</span>)</span></span>: <span class="built_in">Unit</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">iterator</span><span class="params">()</span></span>: Iterator&lt;T&gt;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用set、get函数设置或获取，同时可以运算符重载语法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> array = Array(<span class="number">5</span>)&#123;x-&gt;x&#125;<span class="comment">//通过new对象传入lmbda表达式进行构建对象</span></span><br><span class="line"><span class="keyword">val</span> array2 = arrayOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>);<span class="comment">//通过工厂方法进行构建对象</span></span><br><span class="line">println(array[<span class="number">1</span>])</span><br><span class="line">println(array.<span class="keyword">get</span>(<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>原生数组类型</p><p>当然Java中是存在非类基本数值，Kotlin中也有对应的原生数组，通过相应的工厂方法进行构建</p><p>它们对应的类型是<code>IntArray</code>、<code>ShortArray</code>等，它们和<code>Array</code>是不存继承关系的，对应着原生数组类型</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> array = intArrayOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="字符串字面值"><a href="#字符串字面值" class="headerlink" title="字符串字面值"></a>字符串字面值</h3><p>普通，存在转义</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> stringA = <span class="string">"hello world! \n"</span><span class="comment">//可以存在转义字符</span></span><br></pre></td></tr></table></figure><p>原始字符串，无转义，使用三引号包围，里面是怎么样表现的，输出就是怎样的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> stringB = <span class="string">"""</span></span><br><span class="line"><span class="string">fun mian() &#123;</span></span><br><span class="line"><span class="string">println()</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fun mian() &#123;</span><br><span class="line">println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然是可以修剪trim，<code>trimMargin</code>通过特定字符裁剪，<code>trimIndent</code>缩进裁剪</p><h3 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h3><p>加上<code>$</code>后在字符串中可以表现位一个变量使用了，复杂情况下使用括号限定，因为<code>$</code>在模板里属于特殊符，想要打出来就如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">val</span> str = <span class="string">"a = <span class="variable">$a</span>"</span></span><br><span class="line">println(str)<span class="comment">//output =&gt; a = 10</span></span><br><span class="line"><span class="keyword">val</span> s = <span class="string">"abc"</span></span><br><span class="line"><span class="keyword">val</span> sArray = <span class="string">"<span class="variable">$s</span>.length is <span class="subst">$&#123;s.length&#125;</span>"</span></span><br><span class="line">println(sArray)<span class="comment">//output =&gt; abc.length is 3</span></span><br><span class="line">println(<span class="string">"$"</span>)<span class="comment">//output =&gt; $</span></span><br><span class="line">println(<span class="string">"<span class="subst">$&#123;<span class="string">'$'</span>&#125;</span>"</span>)<span class="comment">//output =&gt; $</span></span><br></pre></td></tr></table></figure><p>虽然Java里面没有这个，PHP中倒是用的不少，所以有些亲切，反正各个语言基本上都有那么几个相似的地方。</p><h1 id="包和导入"><a href="#包和导入" class="headerlink" title="包和导入"></a>包和导入</h1><p>这个就基本和Java一样了。不过Java没有别名语法，kotlin理由</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.example.Test <span class="keyword">as</span> MyTest</span><br></pre></td></tr></table></figure><h1 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h1><p>特别注意，在kotlin中<code>if</code>和<code>when</code>不只是控制结构，同时也是表达式</p><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通用法</span></span><br><span class="line"><span class="keyword">val</span> a = <span class="number">3</span></span><br><span class="line"><span class="keyword">if</span> (a &gt; <span class="number">3</span>) &#123;</span><br><span class="line">    println(<span class="string">"大于3"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//表达式用法，表达式用法必须含有`else`</span></span><br><span class="line">println(<span class="keyword">if</span>(a &gt; <span class="number">3</span>) <span class="string">"大于3"</span> <span class="keyword">else</span> <span class="string">"小于3"</span>)</span><br><span class="line"><span class="comment">//表达式用法，最后一行作为返回值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> max = <span class="keyword">if</span>(a &gt; <span class="number">3</span>) &#123;</span><br><span class="line">    println(<span class="string">"大于3"</span>)</span><br><span class="line">    a + <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    prntln(<span class="string">"小于3"</span>)</span><br><span class="line">    a + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="when"><a href="#when" class="headerlink" title="when"></a>when</h2><p>其实也就是分支符<code>switch</code>一样的功能</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span>(x) &#123;</span><br><span class="line">    <span class="number">1</span> -&gt; println(<span class="string">"1"</span>)</span><br><span class="line">    <span class="number">2</span> -&gt; println(<span class="string">"2"</span>)</span><br><span class="line">    <span class="number">3</span>,<span class="number">4</span> -&gt; &#123;</span><br><span class="line">        println(<span class="string">"3 or 4"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">        println(<span class="string">"else"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分支条件不一定是常量</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span>(x) &#123;</span><br><span class="line">    parseInt(b) -&gt; println(<span class="string">"使用函数"</span>)</span><br><span class="line">    <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> -&gt; println(<span class="string">"使用区间"</span>)</span><br><span class="line">    !<span class="keyword">in</span> <span class="number">10</span>..<span class="number">20</span> -&gt; println(<span class="string">"区间"</span>)</span><br><span class="line">    <span class="keyword">is</span> <span class="built_in">Int</span> -&gt; println(<span class="string">"类型判断"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>甚至可以进一步简化</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> &#123;</span><br><span class="line">a <span class="keyword">is</span> <span class="built_in">Int</span> -&gt; println(<span class="string">""</span>)<span class="comment">//只要产出true值就可以分支选择</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表达式，和if表达式使用类似，也是必须要要else结构</p><p>1.3后when括号里面可以声明变量，并且用于when作用域</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Request.<span class="title">getBody</span><span class="params">()</span></span> =</span><br><span class="line">        <span class="keyword">when</span> (<span class="keyword">val</span> response = executeRequest()) &#123;</span><br><span class="line">            <span class="keyword">is</span> Success -&gt; response.body</span><br><span class="line">            <span class="keyword">is</span> HttpError -&gt; <span class="keyword">throw</span> HttpException(response.status)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> items) <span class="comment">//对迭代器迭代</span></span><br><span class="line"><span class="keyword">for</span> (num : <span class="built_in">Int</span> <span class="keyword">in</span> nums) <span class="comment">//数组迭代</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">3</span>) <span class="comment">//开区间</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until <span class="number">3</span>) <span class="comment">//前开后闭区间</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">10</span> downTo <span class="number">0</span> step <span class="number">2</span>)<span class="comment">//倒序，带步长</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> array.indices) &#123;<span class="comment">//索引遍历</span></span><br><span class="line">    println(array[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> ((index, value) <span class="keyword">in</span> array.withIndex)<span class="comment">// 索引和值遍历</span></span><br></pre></td></tr></table></figure><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><p>这个就是老套路</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(x &gt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125; <span class="keyword">while</span>(x &gt; <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h1 id="返回与跳转"><a href="#返回与跳转" class="headerlink" title="返回与跳转"></a>返回与跳转</h1><h2 id="return"><a href="#return" class="headerlink" title="return"></a>return</h2><h2 id="break"><a href="#break" class="headerlink" title="break"></a>break</h2><h2 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h2><p>标签返回</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">loop@</span> <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">100</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span>..<span class="number">100</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (……) <span class="keyword">break</span><span class="symbol">@loop</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android-相机</title>
      <link href="/2019/11/27/Android-%E7%9B%B8%E6%9C%BA/"/>
      <url>/2019/11/27/Android-%E7%9B%B8%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="Camera"><a href="#Camera" class="headerlink" title="Camera"></a>Camera</h1><h1 id="Camera2"><a href="#Camera2" class="headerlink" title="Camera2"></a>Camera2</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="CameraManager"><a href="#CameraManager" class="headerlink" title="CameraManager"></a>CameraManager</h3><p>相机的系统服务，可以用来获得一些初步的信息和动作比如：</p><h4 id="打开相机"><a href="#打开相机" class="headerlink" title="打开相机"></a>打开相机</h4><p>使用一个状态回调和一个线程handler来打开相机，继而走向stateCallback回调进行下一步操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">manager.openCamera(cameraId, stateCallback, mBackgroundHandler);</span><br></pre></td></tr></table></figure><h4 id="获得相机列表"><a href="#获得相机列表" class="headerlink" title="获得相机列表"></a>获得相机列表</h4><p>一个设备存在前后置摄像头，以及外置摄像头，<code>CameraManager</code>可以获得摄像头ID列表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">manager.getCameraIdList();</span><br></pre></td></tr></table></figure><h3 id="获得具体摄像头的描述信息"><a href="#获得具体摄像头的描述信息" class="headerlink" title="获得具体摄像头的描述信息"></a>获得具体摄像头的描述信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">manager.getCameraCharacteristics(cameraId);</span><br></pre></td></tr></table></figure><h3 id="CameraDevice"><a href="#CameraDevice" class="headerlink" title="CameraDevice"></a>CameraDevice</h3><p>相机设备的抽象集合，但是和Camera的API不太相同，包含的功能并没有那么多。</p><ul><li>关闭相机</li><li>创键Capture会话</li><li>创键Capture请求</li></ul><p>Camera2中，许多的操作都被抽象的定义为了Capture请求</p><p>比如预览连续重复的Capture请求，拍照则是一次Capture，甚至聚焦、闪关灯、等各种操作也都作为Capture的参数来进行请求。当然录象也是</p><p>所以大致我们流程是：</p><ol><li>获取CameraManager</li><li>去开启指定ID的摄像头</li><li>配置图像数据载体，即摄像头的数据由谁接受</li><li>创建Capture会话</li><li>配置Capture请求</li><li>发送请求</li></ol><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="检查权限"><a href="#检查权限" class="headerlink" title="检查权限"></a>检查权限</h3><p>首先我们使用相机肯定是要声明相机等权限和声明功能</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.CAMERA"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.RECORD_AUDIO"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-feature</span> <span class="attr">android:name</span>=<span class="string">"android.hardware.camera2"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>接着就是动态检查或请求权限了。</p><h3 id="准备Handler"><a href="#准备Handler" class="headerlink" title="准备Handler"></a>准备Handler</h3><p>相机的诸多操作为了不给主线程麻烦，当然是需要在子线程中运行的。所以创建线程，获得到<code>Handler</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mBackgroundThread = <span class="keyword">new</span> HandlerThread(<span class="string">"CameraBackground"</span>);</span><br><span class="line">mBackgroundThread.start();</span><br><span class="line">mBackgroundHandler = <span class="keyword">new</span> Handler(mBackgroundThread.getLooper());</span><br></pre></td></tr></table></figure><h3 id="准备预览载体Surface"><a href="#准备预览载体Surface" class="headerlink" title="准备预览载体Surface"></a>准备预览载体Surface</h3><p>这里我们通过创建TextureView来获得Surface</p><h2 id="打开相机-1"><a href="#打开相机-1" class="headerlink" title="打开相机"></a>打开相机</h2><p>这里我们首先通过获得到<code>CameraManager</code>，通过<code>CameraManager</code>去获取具体摄像头的描述信息，通过这些描述信息我们可以拿到Sensor的方向，以及Sensor支持的尺寸集，然后根据需要进行配置。继而进行打开相机。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><p>预览本质上是将实时的帧图像不断重复的显示并且覆盖在载体上。</p><h2 id="拍照"><a href="#拍照" class="headerlink" title="拍照"></a>拍照</h2><h2 id="录像"><a href="#录像" class="headerlink" title="录像"></a>录像</h2><h2 id="其它操作"><a href="#其它操作" class="headerlink" title="其它操作"></a>其它操作</h2><h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><h3 id="相机sensor的自然方向和屏幕自然方向"><a href="#相机sensor的自然方向和屏幕自然方向" class="headerlink" title="相机sensor的自然方向和屏幕自然方向"></a>相机sensor的自然方向和屏幕自然方向</h3><p>通常描述一张图片分辨率是这样width * height，比如720 * 1080的图片。</p><p>屏幕自然自然方向，也就是人手持竖直方向的。以左上角为基准参照点展开内容。如果横屏之类的话，同样内容展开还是以左上角为内容参照点向下向右展开。</p><p>但是相机sensor方向却一直是固定的。和手机向右横屏的左上角是同一参照点。那么问题来了。竖直情况下拍摄一张图片，比如我们所看到理解的是一张720x1080的图片，但是实际上在相机sensor来说是一张1080x702。照片还是那张照片，造成了输出照片就是横着的。所以这种情况下就需要进行顺时针旋转，旋转完成后，图片才会从1080x720,变为720x1080，这是时候就可以按照正常方向显示了。</p><p>YUV进行旋转后同样，YUV里面的数据只是连续不断的字节流，需要我们给他加上分辨率，才能正确的解释为一张图片。也就是需要按照分辨率进行解析。就好比如你给了宽和高，它就能被抽象化为一个二维的字节数组，然后分别对应着像素点的。所以在我们将YUV数据进行显示或者输入到编码器时需要给与正确显示分辨率，编码器才能够正确的进行编码。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Andriod下的硬编码和解码</title>
      <link href="/2019/11/26/Android-%E7%A1%AC%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81/"/>
      <url>/2019/11/26/Android-%E7%A1%AC%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="关于音视频基础知识"><a href="#关于音视频基础知识" class="headerlink" title="关于音视频基础知识"></a>关于音视频基础知识</h1><h2 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h2><p>平常我们看到的视频格式其实上容器封装格式，即将音频和视频进行封装。当播放器进行播放时，通过解封这个容器拿出视频数据和音频数据分别进行解码，同步控制，再而通过不同的硬件去表现。比如<code>mp4</code>，<code>avi</code>等都是封装格式。</p><p>实际上无关乎音频的话，那就是编码压缩格式，比如h264。视频的其实是每秒30帧的图片进行播放而营造的效果。也就是说一秒会有30张图片，而一张图片如果不压缩的话，按照RGB的方式存储一个像素三个字节，那么一个1920x720的分辨率将会有5MB，光是大概算下一张图片就有这么大，那么一秒，乃至两个小时视频那就会更大了。所以就要进行编码压缩。</p><h2 id="颜色空间"><a href="#颜色空间" class="headerlink" title="颜色空间"></a>颜色空间</h2><blockquote><p>参考：<a href="https://www.jianshu.com/p/3e44c2262775" target="_blank" rel="noopener">YUV格式</a></p></blockquote><h3 id="RGB"><a href="#RGB" class="headerlink" title="RGB"></a>RGB</h3><p>在图片上的像素点通过RGB三色通道来制造颜色，这样的话大概需要三个字节。</p><h3 id="YUV"><a href="#YUV" class="headerlink" title="YUV"></a>YUV</h3><p>YUV也是一中颜色空间，其中Y代表的亮度，UV控制颜色。YUV是可以通过矩阵计算和RGB进行互换的。如果一张YUV的图片的像素只有Y数据的话，整体上就表现为一张黑白的图片。</p><h3 id="YUV的表现格式"><a href="#YUV的表现格式" class="headerlink" title="YUV的表现格式"></a>YUV的表现格式</h3><p>想象下我们有张黑白的图片即拥有Y向量，然后我们UV向量可以有选择给像素加上，可以理解为上色</p><h4 id="YUV444"><a href="#YUV444" class="headerlink" title="YUV444"></a>YUV444</h4><p>每个像素拥有完整Y、U、V分量，和RGB一样占三个字节，只不过计算不同而已</p><p>上色精确到每个像素点。</p><h4 id="YUV422"><a href="#YUV422" class="headerlink" title="YUV422"></a>YUV422</h4><p>两个像素共用一个UV分量。也就是说我们上色不精确到每个像素点了，而是每两个像素点，这么以来，占用的存储空间少了很多。比如4个像素，本来是4x3，现在的话4x1(Y) + 2x1(U) + 2x1(V)</p><h4 id="YUV420"><a href="#YUV420" class="headerlink" title="YUV420"></a>YUV420</h4><p>四个像素公用一个UV分量。同样上色变成了4个像素点上同样的UV分量。这么以来占用的空间又少了。</p><p>4x1(Y) + 1(U) + 1(V)</p><h3 id="YUV的存储格式"><a href="#YUV的存储格式" class="headerlink" title="YUV的存储格式"></a>YUV的存储格式</h3><p>上面的只是颜色表现方式，落实到具体的存储的话。又分为了好几种</p><h4 id="packet"><a href="#packet" class="headerlink" title="packet"></a>packet</h4><p>YUV数据在实际的字节数组中是连续交错存放。细分不同的格式也只是YUV存放不同而已。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VYUY422 V1 Y1 U1 Y2 V2 Y3 U2 Y4 ....</span><br></pre></td></tr></table></figure><h4 id="planar"><a href="#planar" class="headerlink" title="planar"></a>planar</h4><p>Y、U、V分隔开连续存储</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">YYYY</span><br><span class="line">UU</span><br><span class="line">VV</span><br></pre></td></tr></table></figure><h4 id="SemiPlanar"><a href="#SemiPlanar" class="headerlink" title="SemiPlanar"></a>SemiPlanar</h4><p>Y连续存储，UV叫错存储</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">YYYY</span><br><span class="line">UVUV</span><br></pre></td></tr></table></figure><h3 id="常见的存储格式解释"><a href="#常见的存储格式解释" class="headerlink" title="常见的存储格式解释"></a>常见的存储格式解释</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">I420: YYYYYYYY UU VV =&gt;YUV420P</span><br><span class="line"></span><br><span class="line">YV12: YYYYYYYY VV UU =&gt;YUV420P</span><br><span class="line"></span><br><span class="line">NV12: YYYYYYYY UVUV =&gt;YUV420SP</span><br><span class="line"></span><br><span class="line">NV21: YYYYYYYY VUVU =&gt;YUV420SP</span><br></pre></td></tr></table></figure><h3 id="RGB与YUV格式互转"><a href="#RGB与YUV格式互转" class="headerlink" title="RGB与YUV格式互转"></a>RGB与YUV格式互转</h3><p>RGB 转 YUV</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Y = (0.257 * R) + (0.504 * G) + (0.098 * B) + 16</span><br><span class="line">Cr = V = (0.439 * R) - (0.368 * G) - (0.071 * B) + 128</span><br><span class="line">Cb = U = -( 0.148 * R) - (0.291 * G) + (0.439 * B) + 128</span><br></pre></td></tr></table></figure><p>YUV转RGB</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">B = 1.164(Y - 16) + 2.018(U - 128)</span><br><span class="line">G = 1.164(Y - 16) - 0.813(V - 128) - 0.391(U - 128)</span><br><span class="line">R = 1.164(Y - 16) + 1.596(V - 128)</span><br></pre></td></tr></table></figure><h1 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h1><h1 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h1><h1 id="合成与解封"><a href="#合成与解封" class="headerlink" title="合成与解封"></a>合成与解封</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Android-动画归纳</title>
      <link href="/2019/10/29/Android-%E5%8A%A8%E7%94%BB/"/>
      <url>/2019/10/29/Android-%E5%8A%A8%E7%94%BB/</url>
      
        <content type="html"><![CDATA[<p>各种各样的动画快速归纳下</p><p>参考：<a href="https://blog.csdn.net/harvic880925/article/details/50995268" target="_blank" rel="noopener">Android 自定义控件三部曲</a>中动画篇章，以及<a href="https://github.com/OCNYang/Android-Animation-Set" target="_blank" rel="noopener">动画总结</a>，两篇上面详细的学习</p><h1 id="视图动画"><a href="#视图动画" class="headerlink" title="视图动画"></a>视图动画</h1><p>早期android上动画是通过视图动画即Animation这个类以及超类来实现控制，通过控制View的属性，只是控制而已，并没有改变View的属性，所以我们能看到动画的效果，但是view本身的坐标以及各种属性是没有改变的，所以比如点击还是在原来的位置。</p><p>详细学习查询跳转<a href="https://blog.csdn.net/harvic880925/article/details/39996643" target="_blank" rel="noopener">启舰的视图动画博客</a></p><h2 id="Animation的xml基础使用"><a href="#Animation的xml基础使用" class="headerlink" title="Animation的xml基础使用"></a>Animation的xml基础使用</h2><p>可供控制的属性有很多，通过在xml文件任意的view中就能看到，其实和差不多对应了自定义控件里面的各种操作了。</p><ul><li>alpha 透明度</li><li>scale 缩放</li><li>translate 平移</li><li>rotate 旋转</li></ul><a id="more"></a><h3 id="定义xml文件"><a href="#定义xml文件" class="headerlink" title="定义xml文件"></a>定义xml文件</h3><p>在资源文件夹建立anim的文件夹，在里面定义各种动画的xml文件，一共有这么几个标签</p><p>其中scale、alpha、rotate、translate都可以单独做根标签表示一个动画，使用set表示动画集合，当然set里面也是可以嵌套set的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scale</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">alpha</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rotate</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">translate</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure><p>每个标签的属性就不解释了，大概了解就行了，记不住的</p><p>首先定义一个scale缩放的，缩放就是x，y从哪缩放到哪，根据那个坐标来缩放，以及时间等属性。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scale</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:fromXScale</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:toXScale</span>=<span class="string">"1.0"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:fromYScale</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:toYScale</span>=<span class="string">"1.0"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:pivotX</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:pivotY</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:duration</span>=<span class="string">"400"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">scale</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="开启动画"><a href="#开启动画" class="headerlink" title="开启动画"></a>开启动画</h3><p>直接通过工具方法加载动画xml文件，目标view开启动画就行了</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> scaleAnimation = AnimationUtils.loadAnimation(<span class="keyword">this</span>, R.anim.scale)</span><br><span class="line">btn_start.setOnClickListener &#123;</span><br><span class="line">    tv.startAnimation(scaleAnimation)<span class="comment">//开启</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是特简单，使用是很简单，具体其它的属性就要具体使用了，这个具体看应用场景。其它的几个动画依次类推</p><h3 id="组合使用"><a href="#组合使用" class="headerlink" title="组合使用"></a>组合使用</h3><p>有时候需要多个属性效果变化结合起来，这时候就需要用到set标签，将动画写在set标签里面，调用还是一样的</p><h2 id="使用插值器"><a href="#使用插值器" class="headerlink" title="使用插值器"></a>使用插值器</h2><p>动画我们定义了起始值和终值，但是其中是怎么变化并没规定，而插值器就是用来控制从起始值到终值是怎么变化的。比如匀速变化，加速变化等等。通过在动画标签加入android:interpolator属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;scale xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">       android:interpolator=&quot;@android:anim/accelerate_interpolator&quot;</span><br><span class="line">       android:fromXScale=&quot;0&quot;</span><br><span class="line">       android:toXScale=&quot;1.0&quot;</span><br><span class="line">       android:fromYScale=&quot;0&quot;</span><br><span class="line">       android:toYScale=&quot;1.0&quot;</span><br><span class="line">       android:pivotX=&quot;0&quot;</span><br><span class="line">       android:pivotY=&quot;0&quot;</span><br><span class="line">       android:duration=&quot;1000&quot;&gt;</span><br><span class="line">&lt;/scale&gt;</span><br></pre></td></tr></table></figure><p>一些常用的插值器在<code>@android:anim/</code>目录下都可找到</p><h2 id="代码使用Animation"><a href="#代码使用Animation" class="headerlink" title="代码使用Animation"></a>代码使用Animation</h2><p>本质上xml文件还是被解析成的Animation的子类，然后再使用，当然也可直接通过实例化不同Animation进行动画操作</p><ul><li><code>scale</code>对应<code>ScaleAnimation</code></li><li><code>alpha</code>对应<code>AlphaAnimation</code></li><li><code>rotate</code>对应<code>RotateAnimation</code></li><li><code>translate</code> 对应<code>TranslateAnimation</code></li><li><code>set</code> 对应<code>AnimationSet</code></li></ul><p>用法的那就是通过代码去实例化animation对象即可</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构建</span></span><br><span class="line"><span class="keyword">val</span> translateAnimation = TranslateAnimation(<span class="number">0f</span>,<span class="number">200f</span>, <span class="number">0f</span>,<span class="number">300f</span>)</span><br><span class="line">translateAnimation.duration  = <span class="number">1000</span></span><br><span class="line">translateAnimation.fillAfter = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">btn_start_by_code.setOnClickListener &#123;</span><br><span class="line">    tv.startAnimation(translateAnimation)<span class="comment">//开启</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其它的也是依次类推，除了基本的控件动画，还可以作用于activity和fragment的过场动画，由于视图动画很遥远了，“只能做表面上的效果”，优先考虑使用属性动画。</p><h1 id="帧动画"><a href="#帧动画" class="headerlink" title="帧动画"></a>帧动画</h1><p>帧动画好理解，我们看的电影，以及玩的游戏，都会有帧的概念，帧动画通过播放不同drawable实现动画效果</p><p>AnimationDrawable它本质上是drawable</p><h2 id="定义xml"><a href="#定义xml" class="headerlink" title="定义xml"></a>定义xml</h2><p>在drawable下定义</p><p>一个item表示一个帧</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">animation-list</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@android:drawable/ic_media_pause"</span> <span class="attr">android:duration</span>=<span class="string">"1000"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@android:drawable/ic_media_play"</span> <span class="attr">android:duration</span>=<span class="string">"1000"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">animation-list</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>ImageView或其它中引用它，然后获得对象</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(imageView.drawable <span class="keyword">as</span> AnimationDrawable).start()<span class="comment">//开启</span></span><br></pre></td></tr></table></figure><p>就这么简单</p><h1 id="属性动画"><a href="#属性动画" class="headerlink" title="属性动画"></a>属性动画</h1><p>属性动画是在视图动画后面出现的，为了弥补视图动画的“表面功夫”，属性动画是通过控制view的属性来完成动画的。</p><h2 id="基础用法之ValueAnimator"><a href="#基础用法之ValueAnimator" class="headerlink" title="基础用法之ValueAnimator"></a>基础用法之ValueAnimator</h2><p>看名字也直到ValueAnimator传入值进行变化计算，然后我们需要在监听中获得值来设置，从而生成动画效果</p><h3 id="一个栗子"><a href="#一个栗子" class="headerlink" title="一个栗子"></a>一个栗子</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> animator = ValueAnimator.ofArgb(Color.RED, Color.CYAN)<span class="comment">//实例</span></span><br><span class="line">animator.duration = <span class="number">1000</span><span class="comment">//设置时长</span></span><br><span class="line">animator.repeatCount = <span class="number">2</span><span class="comment">//重复次数</span></span><br><span class="line">animator.repeatMode = REVERSE<span class="comment">//重复模式</span></span><br><span class="line">animator.interpolator = LinearInterpolator()<span class="comment">//插值器</span></span><br><span class="line">animator.addUpdateListener &#123;<span class="comment">//添加监听</span></span><br><span class="line">    btn.setBackgroundColor(it.animatedValue <span class="keyword">as</span> <span class="built_in">Int</span>)<span class="comment">//获取动画值进行更新view</span></span><br><span class="line">&#125;</span><br><span class="line">btn_start.setOnClickListener &#123;</span><br><span class="line">    animator.start()<span class="comment">//开启动画</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获得实例方法"><a href="#获得实例方法" class="headerlink" title="获得实例方法"></a>获得实例方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ValueAnimator <span class="title">ofInt</span><span class="params">(<span class="keyword">int</span>... values)</span></span>;<span class="comment">//从int值构建</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ValueAnimator <span class="title">ofArgb</span><span class="params">(<span class="keyword">int</span>... values)</span></span>;<span class="comment">//从arg的int值构建</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ValueAnimator <span class="title">ofFloat</span><span class="params">(<span class="keyword">float</span>... values)</span></span>;<span class="comment">//从float构建</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ValueAnimator <span class="title">ofPropertyValuesHolder</span><span class="params">(PropertyValuesHolder... values)</span></span>;<span class="comment">//PropertyValuesHolder构建</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ValueAnimator <span class="title">ofObject</span><span class="params">(TypeEvaluator evaluator, Object... values)</span></span>;<span class="comment">//自定义取值器构建</span></span><br></pre></td></tr></table></figure><p>有了这些值得变化，就能够实现简单的动画。但是呢我们动画效果的值可能不是int，float，有可能是抽象的数据类型，这个时候就要用下面的自定义求值器了(Evaluator)</p><h2 id="插值器和求值器-Evaluator"><a href="#插值器和求值器-Evaluator" class="headerlink" title="插值器和求值器(Evaluator)"></a>插值器和求值器(Evaluator)</h2><p>插值器讲过了是用来设定动画过程中值是如何变化的</p><p>求值器则是根据从插值器中得到的瞬时值，转化为我们所要包装的值。比如ValueAnimator.ofArgb其实就是使用了<code>ArgbEvaluator</code>来计算最终值</p><h3 id="自定义插值器"><a href="#自定义插值器" class="headerlink" title="自定义插值器"></a>自定义插值器</h3><p>input 输入进度，返回输出进度</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInterpolater</span>: <span class="type">BaseInterpolator</span></span>()&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getInterpolation</span><span class="params">(input: <span class="type">Float</span>)</span></span>: <span class="built_in">Float</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> input</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求值器"><a href="#求值器" class="headerlink" title="求值器"></a>求值器</h3><p>求值器根据插值器中的进度，计算出真正的进度值</p><p>比如这个是用于求字符的求值器</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyEvaluator</span>: <span class="type">TypeEvaluator</span>&lt;<span class="type">Char</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">evaluate</span><span class="params">(fraction: <span class="type">Float</span>, startValue: <span class="type">Char</span>?, endValue: <span class="type">Char</span>?)</span></span>: <span class="built_in">Char</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> a : <span class="built_in">Int</span> = ((endValue!!.toInt() - startValue!!.toInt()) * fraction).toInt() + startValue.toInt()   </span><br><span class="line">        <span class="keyword">return</span> a.toChar()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ObjectAnimator运用"><a href="#ObjectAnimator运用" class="headerlink" title="ObjectAnimator运用"></a>ObjectAnimator运用</h2><p>对于上面的<code>ValueAnimator</code>中得出动画值，通过监听来设置属性，从而完成动画效果，而<code>ObjectAnimator</code>则就是不需要你手动设置监听改变属性</p><h3 id="一个栗子-1"><a href="#一个栗子-1" class="headerlink" title="一个栗子"></a>一个栗子</h3><p>通过直接传入目标，以及动画作用属性完成animator构建，但是这中创键方式需要满足，能够找到对应的set方法，即参数签名类型，方法名相同。才会起作用</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//ObjectAnimator</span></span><br><span class="line"><span class="keyword">val</span> objAnimator = ObjectAnimator.ofFloat(btn, <span class="string">"rotation"</span>, <span class="number">0f</span>, <span class="number">180f</span>)<span class="comment">//构建</span></span><br><span class="line">animator.duration = <span class="number">1000</span><span class="comment">//设置时长</span></span><br><span class="line">animator.repeatCount = <span class="number">2</span><span class="comment">//重复次数</span></span><br><span class="line">animator.repeatMode = REVERSE<span class="comment">//重复模式</span></span><br><span class="line">animator.interpolator = LinearInterpolator()<span class="comment">//插值器</span></span><br><span class="line">btn_start_by_object.setOnClickListener &#123;</span><br><span class="line">    objAnimator.start()<span class="comment">//开启</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其它属性"><a href="#其它属性" class="headerlink" title="其它属性"></a>其它属性</h3><p>总之能够找到对应的set方法就行</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rotation //绕z轴</span><br><span class="line">rotationX //绕x轴</span><br><span class="line">rotationY //绕y轴</span><br><span class="line">scaleX //水平缩放</span><br><span class="line">scaleY //竖直缩放</span><br><span class="line">translateX //水平平移</span><br><span class="line">translateY //竖直平移</span><br><span class="line">alpha //透密度</span><br></pre></td></tr></table></figure><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>其实本质上和VauleAnimator差不多，ObjectAnimator会根据传入的属性名去反射查找对应的set方法，从而进行动画。</p><h3 id="作用于自定义属性"><a href="#作用于自定义属性" class="headerlink" title="作用于自定义属性"></a>作用于自定义属性</h3><p>既然它是通过反射去查找对应的set方法，那么只要我们的自定义view中暴露了set的属性方法，就可以使用ObjectAnimator进行动画操作。当然如果需要get的方法，还是要实现的一下的。</p><h2 id="PropertyValuesHolder和KeyFrame"><a href="#PropertyValuesHolder和KeyFrame" class="headerlink" title="PropertyValuesHolder和KeyFrame"></a>PropertyValuesHolder和KeyFrame</h2><h3 id="PropertyValuesHolder"><a href="#PropertyValuesHolder" class="headerlink" title="PropertyValuesHolder"></a>PropertyValuesHolder</h3><p><code>PropertyValuesHolder</code>直译也直到属性持有，之前我们通过<code>ObjectAnimator</code>是设置目标属性，以及变化，而一个<code>PropertyValueHolder</code>就是一个属性的变化持有，而<code>ObjectAnimator</code>可以从多个<code>PropertyValueHolder</code>构建，也就是可以有多个属性同时变化来完成动画。</p><p>下面的栗子就表现为，同时旋转和颜色改变。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rotationHolder = PropertyValuesHolder.ofFloat(<span class="string">"rotation"</span>, <span class="number">0f</span>, <span class="number">180f</span>)</span><br><span class="line"><span class="keyword">val</span> argbHolder = PropertyValuesHolder.ofInt(<span class="string">"backgroundColor"</span>, Color.CYAN, Color.RED, Color.BLUE)</span><br><span class="line"><span class="keyword">val</span> holderAnimator = ObjectAnimator.ofPropertyValuesHolder(btn_start_by_holder, rotationHolder, argbHolder)</span><br><span class="line">holderAnimator.duration = <span class="number">2000</span></span><br><span class="line">btn_start_by_holder.setOnClickListener &#123;</span><br><span class="line">    holderAnimator.start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="KeyFrame"><a href="#KeyFrame" class="headerlink" title="KeyFrame"></a>KeyFrame</h3><p>这个就是关键帧的意思，给定关键帧的属性，让它自己计算动画变化。然后也可以设置不同的插值器，这么一看，其实我们之前的动画就相当于给了起始和末尾两个关键帧。而这里可以更加自由的设置变化。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> keyframeA = Keyframe.ofFloat(<span class="number">0.1f</span>, <span class="number">30f</span>)<span class="comment">//关键帧A</span></span><br><span class="line"><span class="keyword">val</span> keyframeB = Keyframe.ofFloat(<span class="number">0.5f</span>, -<span class="number">30f</span>)<span class="comment">//关键帧B</span></span><br><span class="line"><span class="keyword">val</span> keyframeC = Keyframe.ofFloat(<span class="number">1f</span>, <span class="number">90f</span>)<span class="comment">//关键帧C</span></span><br><span class="line"><span class="comment">//使用关键帧构建属性holder</span></span><br><span class="line"><span class="keyword">val</span> translateHolder = PropertyValuesHolder.ofKeyframe(<span class="string">"rotation"</span>, keyframeA, keyframeB, keyframeC)</span><br><span class="line"><span class="comment">//构建动画实例</span></span><br><span class="line"><span class="keyword">val</span> keyAnimator = ObjectAnimator.ofPropertyValuesHolder(btn_start_by_keyframe,translateHolder)</span><br><span class="line">keyAnimator.duration = <span class="number">2000</span></span><br><span class="line">btn_start_by_keyframe.setOnClickListener &#123;</span><br><span class="line">    keyAnimator.start()<span class="comment">//开启</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里没有介绍<code>PropertyValuesHolder.ofObject</code>因为类似之前的，也是要去自定义求值器。然后关键帧之间是可以设置插值器的。</p><h2 id="组合动画"><a href="#组合动画" class="headerlink" title="组合动画"></a>组合动画</h2><p>组合动画？之前我们同时变化多个属性不就相当了嘛。no，no。那只是一个Animator的实例在起作用。而这里的组合动画就是<code>AnimatorSet</code>是可以将多个<code>Animator</code>的动画进行一同播放或者按照某种顺序播放。</p><h3 id="顺序播放"><a href="#顺序播放" class="headerlink" title="顺序播放"></a>顺序播放</h3><p>调用<code>playSequentially</code>传入animator集合即可，animatorSet只是负责在一个动画完成后顺序开另一个动画，如果一个动画始终没有完成，那么下一个也始终不会执行</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AnimatorSet</span></span><br><span class="line"><span class="keyword">val</span> animatorSet = AnimatorSet()</span><br><span class="line">animatorSet.playSequentially(animator, holderAnimator, keyAnimator)</span><br><span class="line">animatorSet.duration = <span class="number">2000</span></span><br><span class="line">btn_start_animator_set.setOnClickListener &#123;</span><br><span class="line">    animatorSet.start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="同时播放"><a href="#同时播放" class="headerlink" title="同时播放"></a>同时播放</h3><p>调用<code>playTogether</code>传入animator集合即可，animatorSet负责同时运行多个动画</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AnimatorSet</span></span><br><span class="line"><span class="keyword">val</span> animatorSet = AnimatorSet()</span><br><span class="line">animatorSet.playTogether(animator, holderAnimator, keyAnimator)</span><br><span class="line">animatorSet.duration = <span class="number">2000</span></span><br><span class="line">btn_start_animator_set.setOnClickListener &#123;</span><br><span class="line">    animatorSet.start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自由播放"><a href="#自由播放" class="headerlink" title="自由播放"></a>自由播放</h3><p>通过<code>Animator.Builder</code>来自由的构建动画顺序</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> animatorSetByBuild = AnimatorSet()</span><br><span class="line">animatorSetByBuild</span><br><span class="line">    .play(keyAnimator)<span class="comment">//通过play构建Builder</span></span><br><span class="line">.with(vlaueAnimator)<span class="comment">//</span></span><br><span class="line">    .before(holderAnimator)<span class="comment">//</span></span><br><span class="line">    .after(objAnimator)</span><br></pre></td></tr></table></figure><p>其中这几个方法代表</p><ul><li>set.play(A)，第一个播放且返回builder</li><li>with(B)，表示和一同播放B和A一同播放</li><li>before(C)，表示C在A，B的后面，符合英文语义，A before C</li><li>after(D),表示D在A的前面，A after D</li></ul><p>这些构建都要以第一play的动画为参照点的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">play(A).with(B).after(C).before(D)<span class="comment">//顺序是 C A(B) D</span></span><br></pre></td></tr></table></figure><p>加入连续调用多个before，和after呢</p><p>比如</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">play(A).before(B).before(C).after(D).after(E)<span class="comment">//顺序D(E)AB(C)</span></span><br></pre></td></tr></table></figure><p>其实还是以第一个play的为基准，多个重复的after或者before，会被视为一同播放。</p><h3 id="覆盖动画设置"><a href="#覆盖动画设置" class="headerlink" title="覆盖动画设置"></a>覆盖动画设置</h3><p>在AnimatorSet设置某些东西，是会覆盖每个animator的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置单次动画时长</span></span><br><span class="line"><span class="keyword">public</span> AnimatorSet setDuration(long duration);</span><br><span class="line"><span class="comment">//设置插值器</span></span><br><span class="line"><span class="keyword">public</span> void setInterpolator(TimeInterpolator interpolator);</span><br><span class="line"><span class="comment">//设置目标</span></span><br><span class="line"><span class="keyword">public</span> void setTarget(Object target);</span><br></pre></td></tr></table></figure><p>设置延时不会覆盖，因为这个的意义是animatorSet的延时</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">animatorSet.startDelay = <span class="number">2000</span></span><br></pre></td></tr></table></figure><p>其实就是延迟2秒后，开始这个动画集</p><p><strong>总结下，AnimatorSet通过play开头的方法调用第一个动画都是同一时间触发，顺序操作要看<code>playSequentially</code>和<code>after</code>以及before来决定的，AnimatorSet的延时只是自身的延时，其它的属性比如，单个时长，插值器，目标，是会覆盖动画的。</strong></p><h1 id="Transation"><a href="#Transation" class="headerlink" title="Transation"></a>Transation</h1><p>Transation翻译为过渡，转场，意思从一个场景过渡到另一个场景，可以运用于一个activity间，fragment间，乃至更小的地方。两种变化之间需要过渡</p><p>首先分析下这个作用流程：</p><p>在这个板块里面有三个概念：</p><ul><li><code>Transition</code>  过渡，代表了具体的过渡动作</li><li><code>TransitionMananger</code>  过渡管理器，代表了执行过渡动作的管理者</li><li>Scene 场景 ，抽象的的UI状态的表达</li></ul><p>也就是说从一个<code>Scene</code>过渡到另一个<code>Scene</code>就完成一次场景过渡</p><h2 id="Scene"><a href="#Scene" class="headerlink" title="Scene"></a>Scene</h2><p>场景这个挺抽象的，我的理解就是某一状态下的UI信息包装，比如在某一个LinearLayout为根的场景下，有一个图片坐标在某个位置，这就代表了一个场景。所以我们的场景最根本的是有一个<code>根容器</code>，表示这个舞台。</p><p>首先看下Scene的构造方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sceneRoot: ViewGroup</span><br><span class="line"><span class="keyword">val</span> sonView: View</span><br><span class="line"><span class="keyword">val</span> scene = Scene(sceneRoot, sonView)<span class="comment">//手动搭建</span></span><br><span class="line">Scene.getSceneForLayout(sceneRoot,resId,context)<span class="comment">//从layout中注入形成</span></span><br></pre></td></tr></table></figure><p>scene代表场景，sceneRoot代表整个场景的舞台，也就是要给ViewGroup，然后sonView里面的一个演员，舞台上包括了演员在内的只要是属性等状态变化的，就是一个瞬时的场景。我们只需要知道这个瞬时的场景就Ok了。</p><h2 id="TransitionManager的方法"><a href="#TransitionManager的方法" class="headerlink" title="TransitionManager的方法"></a>TransitionManager的方法</h2><p>说白了过渡控制器，通过动画完成到达某个场景，往深层次看就是，从某一场景属性变化成另一个场景属性，即完成一次场景过渡。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TransitionManager.go(scene, transition)<span class="comment">//以transition过渡，进入一个场景</span></span><br><span class="line">TransitionManager.go(scene)<span class="comment">//以默认过渡，进入一个场景</span></span><br><span class="line">TransitionManager.beginDelayedTransition(sceneRoot)<span class="comment">//当前舞台以默认方式开始过渡</span></span><br><span class="line">TransitionManager.beginDelayedTransition(sceneRoot, transition)<span class="comment">//当前舞台开始以某种方式过渡</span></span><br><span class="line">TransitionManager.endTransitions(sceneRoot)<span class="comment">//终止所有的过渡</span></span><br></pre></td></tr></table></figure><p><strong>go还好理解直接过渡就完事了，beginDelayedTransition的话是通知准备开始过渡了，但是场景不明确，也就是说接下来的以当前舞台的任何变化，都会以某种过渡完成。</strong></p><p><strong>go方式进行的切换是会将原来场景舞台上所有东西撤下来，过渡到以新场景的内容。</strong></p><p>目前我还只是写出测试效果，我没找到具体可以实现的应用，从api来看，大概就是在添加view，以及某容器属性变化时可以使用，其transition内部实现也还是通过属性动画去完成的，所以实现再说。</p><p>除了下面的转场应用以外，待补充。。。</p><h1 id="转场动画运用"><a href="#转场动画运用" class="headerlink" title="转场动画运用"></a>转场动画运用</h1><p>到了这里的话就可以看到很常见的运用了</p><h2 id="activity转场动画"><a href="#activity转场动画" class="headerlink" title="activity转场动画"></a>activity转场动画</h2><p>activity之间的转换过渡是会有动画效果的，但是我们也可以自己定义</p><h3 id="老式转场"><a href="#老式转场" class="headerlink" title="老式转场"></a>老式转场</h3><p>android5.0之前的话，使用视图动画来做转场动画的。比较古老了，但是还是可以使用</p><h4 id="简单手动使用"><a href="#简单手动使用" class="headerlink" title="简单手动使用"></a>简单手动使用</h4><p>首先需要定义两个animation的xml动画，代表了<code>进</code>和<code>出</code>。</p><p>然后只需要在跳转后调用<code>overridePendingTransition</code>传入<code>进</code>和<code>出</code>的动画效果就行了，进就是新的activity进入的动画，出就是本身离开的动画</p><p>xml示范：right_in</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">translate</span> <span class="attr">android:fromXDelta</span>=<span class="string">"100%"</span> <span class="attr">android:toXDelta</span>=<span class="string">"0"</span> <span class="attr">android:duration</span>=<span class="string">"1000"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure><p>调用</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">btn_to_b.setOnClickListener &#123;</span><br><span class="line">    go(AnimationBActivity::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)//<span class="title">startActivity</span></span></span><br><span class="line">    overridePendingTransition(R.anim.activity_rigth_in, R.anim.activity_left_out)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理而言在finish使用后面调用也是需要手动重写动画的，<strong>而且还得重写动画，不能用之前的</strong>，当然用了会很奇怪，所以重写下。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">btn_finish.setOnClickListener &#123;</span><br><span class="line">    finish()</span><br><span class="line">    overridePendingTransition(R.anim.activity_left_in, R.anim.activity_rigth_out)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况我们使用系统的返回按钮还是默认的动画效果的，所以如果要改变的话，需要手动重写onBackPress或者直接重写finish也行</p><h4 id="使用主题配置动画"><a href="#使用主题配置动画" class="headerlink" title="使用主题配置动画"></a>使用主题配置动画</h4><p>这样就相当于直接修改默认的动画效果了。</p><p>首先在定义四种动画，分别代表了进入时的两个动画，和退出时两个动画。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"default_animation"</span> <span class="attr">mce_bogus</span>=<span class="string">"1"</span> <span class="attr">parent</span>=<span class="string">"@android:style/Animation.Activity"</span>&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:activityOpenEnterAnimation"</span>&gt;</span>@anim/activity_right_in<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:activityOpenExitAnimation"</span>&gt;</span>@anim/activity_left_out<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:activityCloseEnterAnimation"</span>&gt;</span>@anim/activity_left_in<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:activityCloseExitAnimation"</span>&gt;</span>@anim/activity_right_out<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>启用主题配置</p><p>在AppTheme主题种，配置<code>android:windowAnimationStyle</code>这一项</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"AppTheme"</span> <span class="attr">parent</span>=<span class="string">"Theme.AppCompat.Light.DarkActionBar"</span>&gt;</span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- Customize your theme here. --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"colorPrimary"</span>&gt;</span>@color/colorPrimary<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"colorPrimaryDark"</span>&gt;</span>@color/colorPrimaryDark<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"colorAccent"</span>&gt;</span>@color/colorAccent<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowAnimationStyle"</span>&gt;</span>@style/default_animation<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样做的话，嗯~，就相当于改变了默认的转场效果，自然back效果也是被应用了，如果代码中没有重写，则就会表现。</p><h3 id="新式转场"><a href="#新式转场" class="headerlink" title="新式转场"></a>新式转场</h3><p>在5.0之后由于推广MD风格的设计，自然之前的转场效果就不好看了，使用Transition来完成转场。</p><h4 id="普通用法"><a href="#普通用法" class="headerlink" title="普通用法"></a>普通用法</h4><p>启动方</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//启动方</span></span><br><span class="line">btn_to_b_new.setOnClickListener &#123;</span><br><span class="line">    startActivity(</span><br><span class="line">        Intent(<span class="keyword">this</span><span class="symbol">@AActivity</span>, BActivity::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>),<span class="type"></span></span></span><br><span class="line">        ActivityOptions.makeSceneTransitionAnimation(<span class="keyword">this</span><span class="symbol">@AActivity</span>).toBundle())<span class="comment">//这里是重点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被启动方</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//被启动方</span></span><br><span class="line"><span class="keyword">val</span> explode = Fade()<span class="comment">//转场效果</span></span><br><span class="line">explode.duration = <span class="number">2000</span></span><br><span class="line">window.enterTransition = explode<span class="comment">//设置入场效果</span></span><br><span class="line">window.exitTransition = explode<span class="comment">//设置出场效果</span></span><br></pre></td></tr></table></figure><h4 id="动画种类"><a href="#动画种类" class="headerlink" title="动画种类"></a>动画种类</h4><p>默认提供了三种</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Expolde()<span class="comment">//炸开</span></span><br><span class="line">Slide()<span class="comment">//平滑</span></span><br><span class="line">Fade()<span class="comment">//渐变</span></span><br></pre></td></tr></table></figure><h4 id="高级用法-共享元素"><a href="#高级用法-共享元素" class="headerlink" title="高级用法-共享元素"></a>高级用法-共享元素</h4><p>这个效果非常好用</p><p>转场的两个Activity中的控件进行关联，转场的时候，关联的控件会非常自然的过度</p><p>首先要设置关联共享元素，两个关联的控件设置同样的<code>transitionName</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:transitionName="one"</span><br></pre></td></tr></table></figure><p>启动</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//启动</span></span><br><span class="line">startActivity(intent, ActivityOptions.makeSceneTransitionAnimation(<span class="keyword">this</span>, holder.fruitImage, <span class="string">"one"</span>).toBundle());</span><br></pre></td></tr></table></figure><p>关联多个</p><p>准备多个Pair即可，后面的动画可随便选择，也或者</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">startActivity(Intent(<span class="keyword">this</span>, Main2Activity.<span class="keyword">class</span>),</span><br><span class="line">                ActivityOptions.makeSceneTransitionAnimation(<span class="keyword">this</span>, Pair.create(((View) iv1),<span class="string">"myiv"</span>), Pair.create(((View) textView),<span class="string">"mytv"</span>)).toBundle());</span><br></pre></td></tr></table></figure><h4 id="使用xml"><a href="#使用xml" class="headerlink" title="使用xml"></a>使用xml</h4><p>之前的转场可以通过xml文件设置，新式转场自然也是可以设置全局默认效果的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowContentTransitions"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowEnterTransition"</span>&gt;</span>@android:transition/fade<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowExitTransition"</span>&gt;</span>@android:transition/fade<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowReenterTransition"</span>&gt;</span>@android:transition/fade<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowReturnTransition"</span>&gt;</span>@android:transition/fade<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其实这样设置和代码设置没有多大区别</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> explode = Fade()</span><br><span class="line">explode.duration = <span class="number">2000</span></span><br><span class="line">window.enterTransition = explode</span><br><span class="line">window.exitTransition = explode</span><br><span class="line">window.reenterTransition = explode</span><br><span class="line">window.returnTransition = explode</span><br></pre></td></tr></table></figure><p><strong>对了，如果新式转场和旧式转场都设置了的话，我测试效果是旧式转场把新的覆盖了。</strong></p><h4 id="自定义效果"><a href="#自定义效果" class="headerlink" title="自定义效果"></a>自定义效果</h4><p>自定义Transition</p><p>待补充。。</p><h2 id="Fragment转场动画"><a href="#Fragment转场动画" class="headerlink" title="Fragment转场动画"></a>Fragment转场动画</h2><p>fragment也是和activity的转场时差不多的思路，包括了旧式animation转场，Transition过渡，以及共享元素</p><h3 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h3><p>使用比较简单，首先准备好animation的xml，然后在代码运用</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">supportFragmentManager</span><br><span class="line">                .beginTransaction()</span><br><span class="line">                .setCustomAnimations(R.anim.slide_up, <span class="number">0</span>)</span><br><span class="line">                .add(R.id.fragment_container, bFragment)</span><br><span class="line">                .addToBackStack(<span class="literal">null</span>)</span><br><span class="line">                .commit()</span><br></pre></td></tr></table></figure><p>给本次事务加上动画</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//enter 进入动画 exit退出动画，返回栈退出无效</span></span><br><span class="line"><span class="function">FragmentTransaction <span class="title">setCustomAnimations</span> <span class="params">(<span class="keyword">int</span> enter, <span class="keyword">int</span> exit)</span></span>;</span><br><span class="line"><span class="comment">//enter 进入动画，exit退出动画，popEnter返回栈进入动画 popExit从返回栈退出动画</span></span><br><span class="line"><span class="function">FragmentTransaction <span class="title">setCustomAnimations</span> <span class="params">(<span class="keyword">int</span> enter, <span class="keyword">int</span> exit, <span class="keyword">int</span> popEnter, <span class="keyword">int</span> popExit)</span></span>;</span><br></pre></td></tr></table></figure><p>这种动画是作用在事务上的，所以，我们可以在hide和show之前设置动画，也会出现动画效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FragmentTransaction ft = getSupportFragmentManager().beginTransaction();</span><br><span class="line">ft.setCustomAnimations(<span class="number">0</span>, R.anim.fragment_slide_down);</span><br><span class="line">ft.hide(musicPlayFragment);</span><br><span class="line">ft.commitAllowingStateLoss();</span><br></pre></td></tr></table></figure><p>当然也可以在代码中实现，需要重写</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateAnimation</span><span class="params">(transit: <span class="type">Int</span>, enter: <span class="type">Boolean</span>, nextAnim: <span class="type">Int</span>)</span></span>: Animation &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onCreateAnimation(transit, enter, nextAnim)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Transition"><a href="#Transition" class="headerlink" title="Transition"></a>Transition</h3><p>这个就简单了</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bFragment.enterTransition = Slide()<span class="comment">//设置进入的过渡</span></span><br><span class="line">bFragment.exitTransition = Slide()<span class="comment">//退出的过渡</span></span><br><span class="line">bFragment.sharedElementEnterTransition = Slide()<span class="comment">//共享元素的过渡</span></span><br><span class="line">supportFragmentManager</span><br><span class="line">    .beginTransaction()</span><br><span class="line">    .add(R.id.fragment_container, bFragment)</span><br><span class="line">.addSharedElement(view, tag)<span class="comment">//设置共享元素</span></span><br><span class="line">    .addToBackStack(<span class="literal">null</span>)</span><br><span class="line">    .commit()</span><br></pre></td></tr></table></figure><p>通过这种方式设定的，比较彻底，过渡就绑定在fragment上了，无论是add，replace，以及show，hide，都会呈现设置的过渡形式</p><h1 id="ViewPager切换动画"><a href="#ViewPager切换动画" class="headerlink" title="ViewPager切换动画"></a>ViewPager切换动画</h1><p>ViewPager的切换的话其实掌握三个点就行了。</p><p>第一，开启子控件允许超出父控件</p><p>通过这个属性：<code>android:clipChildren=&quot;false&quot;</code>，一般来说不论子控件怎么大，都是会被限定在父布局中，通过这个属性，子控件可以突破这个限制。一般而言viewpager静止的时候，布局中只会有一个fragment显示出来，而我们使用了这个属性，多个fragment就会同时显示出来，突破了viewpager布局的限制。而我们要做的许多效果基本上都需要静止时或多或少能够看到其它多个fragment。</p><p>第二、加载多张</p><p>有了第一点突破布局限制，那么我们viewpager是可以设置屏幕加载多少张的。</p><p>第三、自定义PageTransformer</p><p>这个就是我们的具体效果实现了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScaleTransformer</span>: <span class="type">ViewPager.PageTransformer&#123;</span></span></span><br><span class="line">    <span class="keyword">val</span> MIN_SCALE = <span class="number">0.8f</span></span><br><span class="line">    <span class="keyword">val</span> MIN_ALPHA = <span class="number">0.5f</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">transformPage</span><span class="params">(view: <span class="type">View</span>, position: <span class="type">Float</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">when</span> &#123;</span><br><span class="line">            position &lt;= -<span class="number">1</span> || position &gt;= <span class="number">1</span> -&gt;&#123;</span><br><span class="line">                view.alpha = <span class="number">0.8f</span></span><br><span class="line">                view.scaleX = <span class="number">0.8f</span></span><br><span class="line">                view.scaleY = <span class="number">0.8f</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            position &lt;= <span class="number">0</span> -&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> scale = MIN_SCALE + (<span class="number">1</span>+position) * (<span class="number">1</span>-MIN_SCALE)</span><br><span class="line">                <span class="keyword">val</span> alpha = MIN_ALPHA + (<span class="number">1</span>+position) * (<span class="number">1</span>-MIN_ALPHA)</span><br><span class="line">                view.scaleX = scale</span><br><span class="line">                view.scaleY = scale</span><br><span class="line">                view.alpha = alpha</span><br><span class="line">            &#125;</span><br><span class="line">            position &lt;= <span class="number">1</span> -&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> scale = MIN_SCALE + (<span class="number">1</span>-position) * (<span class="number">1</span>-MIN_SCALE)</span><br><span class="line">                <span class="keyword">val</span> alpha = MIN_ALPHA + (<span class="number">1</span>-position) * (<span class="number">1</span>-MIN_SCALE)</span><br><span class="line">                view.scaleX = scale</span><br><span class="line">                view.scaleY = scale</span><br><span class="line">                view.alpha = alpha</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现这个<code>PageTransformer</code>我们需要实现<code>transformPage</code>方法即可，这里面给出参数只有<code>view</code>和<code>position</code>，view代表一个页面，而position代表这个页面所处的位置。我们以每个页面的中中心位置为参考点，当页面位于屏幕中心的时候，页面参考点和屏幕中心横坐标重合，这个时候position就是0，而当这个页面滑向左边，直到刚好不见时，页面中心参考点和屏幕中心参考点横向距离就是view的宽度，这个时候的position就是-1。反之右边就是1，然后依次类推</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-2..-1..0..1..2</span><br></pre></td></tr></table></figure><p>意思每个page都有对应的positon位置，然后原本的情况的是依次排列。而我们可以在这个基础上给它加上基于position变化的缩放比，透明度，平移，旋转，这样的话就可以完成一个切换动画。基本都是基于瞬时值的变化。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">        viewpager.adapter = SimpleAdapter(supportFragmentManager)</span><br><span class="line"><span class="comment">//        viewpager.setPageTransformer(true, DepthTransformer())</span></span><br><span class="line"><span class="comment">//        viewpager.setPageTransformer(true, ScaleTransformer())</span></span><br><span class="line">        viewpager.setPageTransformer(<span class="literal">true</span>, StackCardTransformer())<span class="comment">//第一参数代表绘制顺序，true表示左边要后绘制，效果就是左边的在右边上层。</span></span><br><span class="line">        viewpager.offscreenPageLimit = <span class="number">6</span> <span class="comment">//page数</span></span><br></pre></td></tr></table></figure><h1 id="ViewGroup加入子view动画"><a href="#ViewGroup加入子view动画" class="headerlink" title="ViewGroup加入子view动画"></a>ViewGroup加入子view动画</h1><p>首先将viewgroup的<code>android:animateLayoutChanges=&quot;true&quot;</code>属性开启</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> layoutTransition = LayoutTransition()<span class="comment">//这个transition和之前那个并没有关联</span></span><br><span class="line"><span class="keyword">val</span> objectAnimator = ObjectAnimator.ofFloat(<span class="literal">null</span>, <span class="string">"rotation"</span>, <span class="number">0f</span>, <span class="number">90f</span>,<span class="number">0f</span>)<span class="comment">//设置动画</span></span><br><span class="line">layoutTransition.setAnimator(LayoutTransition.APPEARING, objectAnimator)<span class="comment">//将动画设置给哪个目标</span></span><br><span class="line">container.layoutTransition = layoutTransition<span class="comment">//设置到viewgroup</span></span><br><span class="line">btn_add_btn.setOnClickListener &#123;</span><br><span class="line">    <span class="keyword">val</span> btn = Button(<span class="keyword">this</span>)</span><br><span class="line">    container.addView(btn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤就是以上几个，动画的目标有以下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">APPEARING<span class="comment">//本身item出现时。目标自身</span></span><br><span class="line">DISAPPEARING<span class="comment">//本身item消失时，目标自身</span></span><br><span class="line">CHANGING<span class="comment">//因layout改变(而不是因为add，remove造成)，动画，默认是没开启的</span></span><br><span class="line">CHANGE_APPEARING<span class="comment">//别的item出现，目标自身</span></span><br><span class="line">CHANGE_DISAPPEARING<span class="comment">//别的item消失，目标自身</span></span><br></pre></td></tr></table></figure><p><code>APPERARING</code> 和<code>DISAPPERARING</code>直接添加动画就行了。</p><p>而<code>CHANGE_APPEARING</code> 和 <code>CHANGE_DISAPPEARING</code>需要通过<code>PropetryHolder</code>进行完成，因为它必须包含<code>left</code>和<code>top</code>的变化。</p><p>同样可以在动画设置的其它比如方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDuration</span><span class="params">(<span class="keyword">long</span> duration)</span></span>;<span class="comment">//所有动画所需时间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDuration</span><span class="params">(<span class="keyword">int</span> transitionType, <span class="keyword">long</span> duration)</span></span>;<span class="comment">//针对type</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInterpolator</span><span class="params">(<span class="keyword">int</span> transitionType, TimeInterpolator interpolator)</span></span>;<span class="comment">//针对不同type的插值器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStartDelay</span><span class="params">(<span class="keyword">int</span> transitionType, <span class="keyword">long</span> delay)</span></span>;<span class="comment">//针对不同type的延时</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStagger</span><span class="params">(<span class="keyword">int</span> transitionType, <span class="keyword">long</span> duration)</span></span>;<span class="comment">//针对不同type，每个item动画间隔</span></span><br></pre></td></tr></table></figure><h1 id="触摸反馈动画Ripple-Effect"><a href="#触摸反馈动画Ripple-Effect" class="headerlink" title="触摸反馈动画Ripple Effect"></a>触摸反馈动画Ripple Effect</h1><p>比如我们的原生按钮，哪个触摸反馈就是用了这个。</p><p>使用起来很简单</p><h2 id="使用系统定义的"><a href="#使用系统定义的" class="headerlink" title="使用系统定义的"></a>使用系统定义的</h2><p>只需要设置前景或者背景即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//有边界</span><br><span class="line">?android:attr/selectableItemBackground</span><br><span class="line">//无边界 （要求API21以上）</span><br><span class="line">?android:attr/selectableItemBackgroundBorderless</span><br></pre></td></tr></table></figure><p>设置，前景和背景都可以设置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:clickable</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:background</span>=<span class="string">"@color/colorPrimary"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:foreground</span>=<span class="string">"?android:attr/selectableItemBackgroundBorderless"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"287dp"</span> <span class="attr">android:layout_height</span>=<span class="string">"196dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginStart</span>=<span class="string">"16dp"</span> <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginEnd</span>=<span class="string">"8dp"</span> <span class="attr">android:layout_marginTop</span>=<span class="string">"100dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">"parent"</span> <span class="attr">app:layout_constraintHorizontal_bias</span>=<span class="string">"0.46"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样的话，只要这个view可以点击，就会触发触摸反馈</p><h2 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h2><p>自定义也很简单，本质上其实是一个drawable，所以在drawable文件夹定义一个xml即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ripple</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span> <span class="attr">android:color</span>=<span class="string">"@color/colorAccent"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ripple</span>&gt;</span></span><br></pre></td></tr></table></figure><p>ripple根标签必须要给出color属性，这个代表了波纹的颜色，当然最好是带透明度的颜色，不然就会盖住了。</p><p>ripple里面还可以添加标签<code>item</code>，这个的作用是设置边界，<del>额，我感觉啊，有没有边界好像差不多额</del>。了解就差不多了</p><p>补充下，这个边界还是有用的，我在模拟器上没看出不同来，换到手机就看出来了，有边界的ripple触摸反馈，不会无限扩展到整个view，无边界则会。</p><h1 id="揭露动画"><a href="#揭露动画" class="headerlink" title="揭露动画"></a>揭露动画</h1><p>看起来的效果和ripple的差不多，就是一个以圆半径从a到b的变化。</p><p>使用起来比较简单，通过<code>ViewAnimationUtils.createCircularReveal</code>就可创键一个揭露animator</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> show = ViewAnimationUtils.createCircularReveal(</span><br><span class="line">    frame_b,<span class="comment">//目标view</span></span><br><span class="line">    x,<span class="comment">//圆心横坐标</span></span><br><span class="line">    y,<span class="comment">//圆心纵坐标</span></span><br><span class="line">    <span class="number">0f</span>,<span class="comment">//起始半径</span></span><br><span class="line">    radius.toFloat()<span class="comment">//结束半径</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这个动画的过程就是以某点到位圆心得半径变化得圆。通过在开始或者设置可见性，比如开从半径0到100时，动画开始设置可见性位可见，动画开始，看到得效果就是view逐渐以圆扩张可见。反之也可以隐藏。</p><p>下面是完整show和hide栗子</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">launchReveal</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> x = frame_b.width</span><br><span class="line">    <span class="keyword">val</span> y = frame_b.height</span><br><span class="line">    <span class="keyword">val</span> radius = Math.hypot(x.toDouble(), y.toDouble())</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="comment">//hide</span></span><br><span class="line">        <span class="keyword">val</span> hide = ViewAnimationUtils.createCircularReveal(</span><br><span class="line">            frame_b,</span><br><span class="line">            x,</span><br><span class="line">            y,</span><br><span class="line">            radius.toFloat(),</span><br><span class="line">            <span class="number">0f</span></span><br><span class="line">        )</span><br><span class="line">        hide.duration = <span class="number">2000</span></span><br><span class="line">        hide.run &#123;</span><br><span class="line">            hide.duration = <span class="number">2000</span></span><br><span class="line">            addListener(<span class="keyword">object</span> : Animator.AnimatorListener&#123;</span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onAnimationRepeat</span><span class="params">(animation: <span class="type">Animator</span>?)</span></span> &#123;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onAnimationCancel</span><span class="params">(animation: <span class="type">Animator</span>?)</span></span> &#123;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onAnimationStart</span><span class="params">(animation: <span class="type">Animator</span>?)</span></span> &#123;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onAnimationEnd</span><span class="params">(animation: <span class="type">Animator</span>?)</span></span> &#123;</span><br><span class="line">                    frame_b.visibility = View.GONE</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;)</span><br><span class="line">            start()</span><br><span class="line">        &#125;</span><br><span class="line">        flag = <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//show</span></span><br><span class="line">        <span class="keyword">val</span> show = ViewAnimationUtils.createCircularReveal(</span><br><span class="line">            frame_b, x, y, <span class="number">0f</span>,</span><br><span class="line">            radius.toFloat()</span><br><span class="line">        )</span><br><span class="line">        show.duration = <span class="number">2000</span></span><br><span class="line">        frame_b.visibility = View.VISIBLE</span><br><span class="line">        show.start()</span><br><span class="line">        flag = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="视图状态动画"><a href="#视图状态动画" class="headerlink" title="视图状态动画"></a>视图状态动画</h1><p>视图状态动画：即在view状态发生改变时的动画，状态？何为状态，比如说：按下，获得焦点等等，这也就我们经常使用selector，用于对不同状态的drawable。同样，在状态发生改变时可以进行动画效果过渡。</p><p>使用也比较简单，在animtor动画目录下定义以selector的动画即可</p><p>下面定义了一个按压是，z轴增加有卡片效果，同时绕x轴小幅度晃动。不按压时则变回原来属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">selector</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:state_pressed</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">objectAnimator</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:propertyName</span>=<span class="string">"translationZ"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:valueTo</span>=<span class="string">"10dp"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:valueType</span>=<span class="string">"floatType"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:duration</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">objectAnimator</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:propertyName</span>=<span class="string">"rotationX"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:duration</span>=<span class="string">"100"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:valueTo</span>=<span class="string">"20"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:valueFrom</span>=<span class="string">"-20"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:valueType</span>=<span class="string">"floatType"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:state_pressed</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">objectAnimator</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:propertyName</span>=<span class="string">"translationZ"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:valueTo</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:valueType</span>=<span class="string">"floatType"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:duration</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">objectAnimator</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:propertyName</span>=<span class="string">"rotationX"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:duration</span>=<span class="string">"100"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:valueTo</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:valueType</span>=<span class="string">"floatType"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">selector</span>&gt;</span></span><br></pre></td></tr></table></figure><p>后面只需要给view设置属性即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:stateListAnimator="@animator/state_z_up"</span><br></pre></td></tr></table></figure><p>或者在代码中</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载动画</span></span><br><span class="line"><span class="keyword">val</span> stateLAnim = AnimatorInflater.loadStateListAnimator(<span class="keyword">this</span>,R.animator.state_z_up)</span><br><span class="line"><span class="comment">//设置动画</span></span><br><span class="line">b.stateListAnimator(stateLAnim)</span><br></pre></td></tr></table></figure><h1 id="矢量图动画"><a href="#矢量图动画" class="headerlink" title="矢量图动画"></a>矢量图动画</h1><p>矢量图它不是一个固定的图片，而是根据xml里面的规则，进行绘制出来的，所以无论你的放大多少，然后它还是按照你给的区域进行绘制，所以不会模糊之类的。简单来理解，我感觉就和我们之前进行自定义view中进行图形路径等绘制一样，只不过它是把绘制动作写到了xml文件中。而这些矢量图和自定义view一样，拥有路径绘制，旋转，颜色等属性。而我们的矢量图动画就是在矢量图的基础上控制矢量图属性的变化来完成动画过渡。</p><p>简单来说有三个步骤</p><h2 id="准备矢量图和动画"><a href="#准备矢量图和动画" class="headerlink" title="准备矢量图和动画"></a>准备矢量图和动画</h2><p>比如，画一个<code>√</code>,在<code>path</code>标签中，pathData使用<code>M</code> <code>L</code>函数，分别代表了，<code>moveTo</code>， <code>LineTo</code>是不是和canvas中画图操作差不多。贝塞尔函数也是可以用的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">vector</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:width</span>=<span class="string">"100dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:height</span>=<span class="string">"100dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:viewportWidth</span>=<span class="string">"24"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:viewportHeight</span>=<span class="string">"24"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">group</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">"g_rotation"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:pivotX</span>=<span class="string">"12"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:pivotY</span>=<span class="string">"12"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:rotation</span>=<span class="string">"0"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">path</span> <span class="attr">android:name</span>=<span class="string">"check"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:strokeAlpha</span>=<span class="string">"1.0"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:pathData</span>=<span class="string">"M4,10 L9,16 L20,4"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:strokeColor</span>=<span class="string">"@color/colorPrimary"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:strokeLineJoin</span>=<span class="string">"round"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:strokeLineCap</span>=<span class="string">"round"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:strokeWidth</span>=<span class="string">"3"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">vector</span>&gt;</span></span><br></pre></td></tr></table></figure><p>定义一个动画文件，我们控制的旋转属性，而旋转是在group标签的，所以上面用group包裹了path</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">objectAnimator</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span> </span></span><br><span class="line"><span class="tag">                <span class="attr">android:duration</span>=<span class="string">"1000"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:propertyName</span>=<span class="string">"rotation"</span> </span></span><br><span class="line"><span class="tag">                <span class="attr">android:valueFrom</span>=<span class="string">"0"</span> </span></span><br><span class="line"><span class="tag">                <span class="attr">android:valueTo</span>=<span class="string">"360"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">objectAnimator</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="定义含动画的矢量图-animated-vector"><a href="#定义含动画的矢量图-animated-vector" class="headerlink" title="定义含动画的矢量图(animated-vector):"></a>定义含动画的矢量图(animated-vector):</h2><p>设定源矢量图，以及设置动画匹配的目标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">animated-vector</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/hook"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">target</span> <span class="attr">android:animation</span>=<span class="string">"@animator/rotation_round"</span> <span class="attr">android:name</span>=<span class="string">"g_rotation"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">target</span> <span class="attr">android:animation</span>=<span class="string">"@animator/alpha"</span> <span class="attr">android:name</span>=<span class="string">"check"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">target</span> <span class="attr">android:animation</span>=<span class="string">"@animator/color"</span> <span class="attr">android:name</span>=<span class="string">"check"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">animated-vector</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="开启动画-1"><a href="#开启动画-1" class="headerlink" title="开启动画"></a>开启动画</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iv_hook.setOnClickListener &#123;</span><br><span class="line">    <span class="keyword">val</span> drawable = iv_hook.drawable</span><br><span class="line">    (drawable <span class="keyword">as</span> Animatable).start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相关属性"><a href="#相关属性" class="headerlink" title="相关属性"></a>相关属性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">trimPathEnd 截取末尾，这个也用来实现一条路径的从无到有</span><br><span class="line">pathData</span><br></pre></td></tr></table></figure><p>这样就可以通过操纵矢量图属性进行动画了。我们一般看到的MD设计中那些非常细腻的图标变化动画就是通过矢量图动画表达的。当然上面只是操纵了rotation属性，更加牛逼的是可以直接过渡变换<code>pathData</code>路径表述，只要它们路径表述结构相同，也是可以实现很巧妙的动画。不过能上面也只是粗略的介绍，后续需要深入，考虑使用优美的矢量动画库，学习学学习。</p><h1 id="约束布局实现的关键帧动画"><a href="#约束布局实现的关键帧动画" class="headerlink" title="约束布局实现的关键帧动画"></a>约束布局实现的关键帧动画</h1><p>在约束布局中，开启transition，动态改变约束布局中子view属性，ConstraintSet 会按照动画过渡完成属性转变，具体参看下面链接</p><p><a href="https://github.com/OCNYang/Android-Animation-Set/tree/master/constraint-animation" target="_blank" rel="noopener">约束布局动画</a></p><h1 id="动画库"><a href="#动画库" class="headerlink" title="动画库"></a>动画库</h1>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android-自定义View之绘图</title>
      <link href="/2019/08/08/Android-%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B9%8B%E7%BB%98%E5%9B%BE/"/>
      <url>/2019/08/08/Android-%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B9%8B%E7%BB%98%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h1><p>建议看启舰大神的<a href="https://blog.csdn.net/harvic880925/article/details/50995268" target="_blank" rel="noopener">系列博客</a>，或者《android-自定义控件》，</p><p>在android的世界里面，你所看到的所有控件本质上都是通过逻辑概念绘画给“画”上去的，比如一张图片，也是“画”上去的，而我们看到如此多的动态效果其实是在每一帧绘制不同的图像，包装下形成动画，就是这么而来的。</p><p>基本而言我们所能用到的有这么几个逻辑概念：</p><ul><li>Paint 英文词汇是绘画，是个动词，在这里我们可以理解为画笔画画这套动作，或者直接理解为画笔来表述好一点，它所能的就是“我该以什么方式来画”</li><li>Canvas 画布，我们所画的东西是画在画布上，然后通过画布进而映射到屏幕上。“我可以承载画画的内容”</li><li>Path 路径，点于点之间的连线</li><li>Rect 矩形</li><li>Bitmap位图</li></ul><p>所以最基本动作就是</p><ol><li>准备画笔</li><li>准备要画的内容</li><li>在画布上画画</li></ol><h2 id="画笔"><a href="#画笔" class="headerlink" title="画笔"></a>画笔</h2><blockquote><p>The Paint class holds the style and color information about how to draw* geometries, text and bitmaps.</p></blockquote><p>画笔类承载着关于如何取绘画的颜色风格。</p><p>绘制之前，我们需要了解，画笔有那些可以做的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mPaint = <span class="keyword">new</span> Paint();</span><br><span class="line">mPaint.setAntiAlias(<span class="keyword">true</span>);<span class="comment">//抗锯齿</span></span><br><span class="line">mPaint.setStrokeWidth(<span class="number">45</span>);<span class="comment">//画笔宽度</span></span><br><span class="line">mPaint.setStyle(Paint.Style.STROKE);<span class="comment">//风格</span></span><br><span class="line">mPaint.setStrokeCap(Paint.Cap.ROUND);<span class="comment">//笔帽风格</span></span><br><span class="line">mPaint.setStrokeJoin(Paint.Join.ROUND);<span class="comment">//转角风格</span></span><br><span class="line">mPaint.setColor(Color.Red);<span class="comment">//颜色</span></span><br><span class="line">mPaint.setXfermode();<span class="comment">//图层叠加效果</span></span><br><span class="line">mPaint.setShader();<span class="comment">//设置印章</span></span><br><span class="line">mPaint.setColorFilter();<span class="comment">//设置颜色过滤，滤镜</span></span><br><span class="line">mPaint.setMaskFilter();<span class="comment">//设置阴影，发光</span></span><br><span class="line">mPaint.setShadowLayer();<span class="comment">//设置阴影</span></span><br></pre></td></tr></table></figure><p>额，可以设置东西非常多，还是建议看启舰大神的书。</p><h2 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a>坐标</h2><p>首先需要介绍下android的坐标系，它是以画布左上角为圆点，向下为正坐标，向右为正坐标。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-------------</span><br><span class="line">|            </span><br><span class="line">|     .       </span><br><span class="line">|</span><br><span class="line">|</span><br></pre></td></tr></table></figure><h2 id="基本图形绘制"><a href="#基本图形绘制" class="headerlink" title="基本图形绘制"></a>基本图形绘制</h2><p>画笔设置到了后就可以画画了</p><p>绘制图形，线，弧，点</p><p>绘点的好理解，给出一个坐标就行了</p><p>绘制线的画就是给出若干个点</p><p>绘制矩形就是给出矩形四条边距离坐标轴的距离</p><p>绘制椭圆，高中的学习我们直到，一个椭圆是建立一个矩形中的，所以我们需要给出矩形，当然如果矩形变成正方形后，自然就成为圆了。</p><p>如果单纯画圆的画就需要给出圆心坐标，以及半径</p><p>绘制弧的的画就要给具体的角度了。android的角度轴是以x正方向为0，顺时针针增加。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">canvas.drawLines(pts, mPaint);<span class="comment">//线</span></span><br><span class="line">canvas.drawPoint(<span class="number">500</span>,<span class="number">500</span>, mPaint);<span class="comment">//点</span></span><br><span class="line">canvas.drawRect(<span class="keyword">new</span> Rect(<span class="number">40</span>, <span class="number">40</span>, <span class="number">150</span>, <span class="number">200</span>), mPaint);<span class="comment">//矩形</span></span><br><span class="line">canvas.drawRoundRect(<span class="keyword">new</span> RectF(<span class="number">200</span>, <span class="number">40</span>, <span class="number">400</span>, <span class="number">200</span>), <span class="number">10</span>, <span class="number">10</span>, mPaint);<span class="comment">//圆角矩形</span></span><br><span class="line">canvas.drawOval(<span class="keyword">new</span> RectF(<span class="number">400</span>, <span class="number">400</span>, <span class="number">700</span>, <span class="number">900</span>), mPaint);<span class="comment">//圆形或椭圆</span></span><br><span class="line">canvas.drawCircle(<span class="number">200</span>,<span class="number">200</span>,<span class="number">10</span>,mPaint);<span class="comment">//圆</span></span><br><span class="line">canvas.drawArc(<span class="keyword">new</span> RectF(<span class="number">200</span>,<span class="number">400</span>,<span class="number">400</span>, <span class="number">700</span>), <span class="number">30</span>, <span class="number">200</span>, <span class="keyword">false</span>, mPaint);<span class="comment">//区域</span></span><br></pre></td></tr></table></figure><p>通过画出这些基本图形，结合动画也就能做出不错的效果了</p><h2 id="canvas变换"><a href="#canvas变换" class="headerlink" title="canvas变换"></a>canvas变换</h2><h1 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h1><h2 id="普通事件"><a href="#普通事件" class="headerlink" title="普通事件"></a>普通事件</h2><h2 id="手势检测"><a href="#手势检测" class="headerlink" title="手势检测"></a>手势检测</h2><h1 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h1><h1 id="封装控件"><a href="#封装控件" class="headerlink" title="封装控件"></a>封装控件</h1>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android-RxJava之背压学习</title>
      <link href="/2019/08/05/Android-RxJava%E4%B9%8B%E8%83%8C%E5%8E%8B%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/08/05/Android-RxJava%E4%B9%8B%E8%83%8C%E5%8E%8B%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>参考：<a href="https://www.jianshu.com/p/ff8167c1d191/" target="_blank" rel="noopener">Flowable背压支持</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rxJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android-ViewModel探究</title>
      <link href="/2019/08/05/Android-ViewModel%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/08/05/Android-ViewModel%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="ViewModel如何产生的？"><a href="#ViewModel如何产生的？" class="headerlink" title="ViewModel如何产生的？"></a>ViewModel如何产生的？</h2><p>通常我们第一步都是通过<code>ViewModelProviders.of()</code>这个工具方法进行传入activity来获得。我们之间看源码</p><p>传入<code>FragmentActivity</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ViewModelProvider <span class="title">of</span><span class="params">(@NonNull FragmentActivity activity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> of(activity, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>走到重载方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ViewModelProvider <span class="title">of</span><span class="params">(@NonNull FragmentActivity activity,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   @Nullable Factory factory)</span> </span>&#123;</span><br><span class="line">    Application application = checkApplication(activity);</span><br><span class="line">    <span class="keyword">if</span> (factory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        factory = ViewModelProvider.AndroidViewModelFactory.getInstance(application);<span class="comment">//默认工厂</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ViewModelProvider(activity.getViewModelStore(), factory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个方法区别就是有无提供<strong>工厂</strong>，其实实际上<code>ViewModel</code>的生成就是工厂生产出来的。这里的话如果不提供工厂则会给我们一个默认的工厂。最后构建一个<code>ViewModelProvider</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AndroidViewModelFactory <span class="title">getInstance</span><span class="params">(@NonNull Application application)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sInstance = <span class="keyword">new</span> AndroidViewModelFactory(application);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认工厂也很简单就是一个<code>AndroidViewModelFactory</code>实例</p><p>我们回头看<code>ViewModelProvider</code>的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewModelProvider</span><span class="params">(@NonNull ViewModelStore store, @NonNull Factory factory)</span> </span>&#123;</span><br><span class="line">    mFactory = factory;</span><br><span class="line">    mViewModelStore = store;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入一个<code>ViewModelStore</code>和<code>Factory</code>。这个<code>ViewModelStore</code>看名字就是实际存储用于存储<code>ViewModel</code>的。而它也是直接从<code>FragmentActivity.getViewModelStore()</code>获得。</p><p>目前我们就获得到了一个activity的<code>ViewModelProvider</code>。它维持了一个<code>Factory</code>和<code>ViewModelStore</code>，分别用于生产<code>ViewModel</code>和存储<code>ViewModel</code></p><p>下一步，获取具体的<code>ViewModel</code>，<code>ViewModelProvider.get(clazz)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T extends ViewModel&gt; <span class="function">T <span class="title">get</span><span class="params">(@NonNull Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class="line">    String canonicalName = modelClass.getCanonicalName();<span class="comment">//获取全类名</span></span><br><span class="line">    <span class="keyword">if</span> (canonicalName == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Local and anonymous classes can not be ViewModels"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> get(DEFAULT_KEY + <span class="string">":"</span> + canonicalName, modelClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过key获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T extends ViewModel&gt; <span class="function">T <span class="title">get</span><span class="params">(@NonNull String key, @NonNull Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class="line">    ViewModel viewModel = mViewModelStore.get(key);<span class="comment">//获取viewmodel</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (modelClass.isInstance(viewModel)) &#123;</span><br><span class="line">        <span class="comment">//noinspection unchecked</span></span><br><span class="line">        <span class="keyword">return</span> (T) viewModel;<span class="comment">//如果是这个类型</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//noinspection StatementWithEmptyBody</span></span><br><span class="line">        <span class="keyword">if</span> (viewModel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> log a warning.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//viewmodel尚不存在</span></span><br><span class="line">    <span class="keyword">if</span> (mFactory <span class="keyword">instanceof</span> KeyedFactory) &#123;</span><br><span class="line">        viewModel = ((KeyedFactory) (mFactory)).create(key, modelClass);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        viewModel = (mFactory).create(modelClass);<span class="comment">//工厂创建</span></span><br><span class="line">    &#125;</span><br><span class="line">    mViewModelStore.put(key, viewModel);<span class="comment">//放入ViewModelStore</span></span><br><span class="line">    <span class="comment">//noinspection unchecked</span></span><br><span class="line">    <span class="keyword">return</span> (T) viewModel;<span class="comment">//返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里就很明确了，首先直接取<code>ViewModelStore</code>中通过key查找<code>ViewModel</code>，查找到了且类型正确就返回。不存则通过工厂进行创建，并且放入<code>ViewModelStore</code>中，这样就完成一个拿去<code>ViewModel</code>。</p><p>然后看下<code>ViewModelStore</code>的实现，一个很简单的<code>HashMap</code>存储</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewModelStore</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, ViewModel&gt; mMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, ViewModel viewModel)</span> </span>&#123;</span><br><span class="line">        ViewModel oldViewModel = mMap.put(key, viewModel);</span><br><span class="line">        <span class="keyword">if</span> (oldViewModel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            oldViewModel.onCleared();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> ViewModel <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Set&lt;String&gt; <span class="title">keys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HashSet&lt;&gt;(mMap.keySet());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Clears internal storage and notifies ViewModels that they are no longer used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (ViewModel vm : mMap.values()) &#123;</span><br><span class="line">            vm.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        mMap.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下工厂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NewInstanceFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"ClassNewInstance"</span>)</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends ViewModel&gt; <span class="function">T <span class="title">create</span><span class="params">(@NonNull Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//noinspection TryWithIdenticalCatches</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> modelClass.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Cannot create an instance of "</span> + modelClass, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Cannot create an instance of "</span> + modelClass, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调下默认最简单的工厂，就是直接反射创建实例，而<code>AndroidViewModelFactory</code>是它的子类，只是多了一个传入<code>Application</code>参数的功能，其它都没什么。</p><p>走到这里也大概明白的<code>ViewModel</code>的创建。我们平时使用中两个<code>fragment</code>可以共享<code>activity</code>的<code>viewmodel</code>，也正式因为通过<code>activity</code>的<code>ViewModelStore</code>进行获取的，也就完成了<code>ViewModel</code>局部单例的效果。这个效果基本上是靠<code>ViewModelProvider(xxx.getViewModelStore(), factory)</code>传入不同的<code>ViewModelStore</code>完成的。</p><p>一个activity可以有多个fragment，通过设置activity的<code>ViewModelStore</code>完成局部单例<code>viewmdoel</code>。换句话说只要设置是同一个<code>ViewModelStore</code>在这个范围就是单例的。Fragment的ViewModelStore则是实际来源于FragmentManager的。</p><h2 id="全局单例ViewModel"><a href="#全局单例ViewModel" class="headerlink" title="全局单例ViewModel"></a>全局单例ViewModel</h2><p>有这样的场景，有一个view数据基本在全局都会使用的到，这个时候我们就要实现一个全局的<code>ViewModel</code>，这个时候我们可以让Application来实现<code>ViewModelStoreOwner</code>提供出一个全局的<code>ViewModelStore</code>来存储全局的<code>ViewModel</code>，工厂的可以直接使用默认的实现。</p><h2 id="自定义工厂"><a href="#自定义工厂" class="headerlink" title="自定义工厂"></a>自定义工厂</h2><p>我们每个ViewModel一般来说都会有可能依赖数据仓库，数据仓库我们当然是希望是全局的单例，这个时候我们就要手动取实现工厂来构建。甚至会有其它的自定义参数，这个时候也是需要自定义工厂的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewModelFactory</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> dataRepository: DataRepository) :</span><br><span class="line">    ViewModelProvider.NewInstanceFactory() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ViewModel?&gt;</span> <span class="title">create</span><span class="params">(modelClass: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;)</span></span> =</span><br><span class="line">        with(modelClass) &#123;</span><br><span class="line">            <span class="keyword">when</span> &#123;</span><br><span class="line">                isAssignableFrom(LocalMusicViewModel::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>) -&gt;</span></span><br><span class="line">                LocalMusicViewModel(dataRepository)</span><br><span class="line">                <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"Unknown ViewModel class: <span class="subst">$&#123;modelClass.name&#125;</span>"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">as</span> T</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="meta">@Volatile</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> INSTANCE: ViewModelFactory? = <span class="literal">null</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getInstance</span><span class="params">(application: <span class="type">Application</span>)</span></span> =</span><br><span class="line">            INSTANCE ?: synchronized(ViewModelFactory::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>) </span>&#123;</span><br><span class="line">                INSTANCE</span><br><span class="line">                    ?: ViewModelFactory(Injection.provideDataRepository(application.applicationContext))</span><br><span class="line">                        .also &#123; INSTANCE = it &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Jetpacak之Room</title>
      <link href="/2019/08/05/Android-Jetpack%E4%B9%8BRoom/"/>
      <url>/2019/08/05/Android-Jetpack%E4%B9%8BRoom/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>google官方的数据库框架，可以无缝结合LiveData以及Rxjava结合使用。</p><p>文档：<a href="https://developer.android.google.cn/training/data-storage/room" target="_blank" rel="noopener">Romm doc</a></p><p>api详细：<a href="https://developer.android.google.cn/reference/androidx/room/package-summary" target="_blank" rel="noopener">Room summary</a></p><p>基础使用步骤</p><p>引入依赖，开启androidx哦</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="keyword">def</span> room_version = <span class="string">"2.2.0-alpha01"</span> <span class="comment">// 2.1.0 for latest stable version</span></span><br><span class="line"></span><br><span class="line">    implementation <span class="string">"androidx.room:room-runtime:$room_version"</span></span><br><span class="line">    annotationProcessor <span class="string">"androidx.room:room-compiler:$room_version"</span> <span class="comment">// For Kotlin use kapt instead of annotationProcessor</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - Kotlin Extensions and Coroutines support for Room</span></span><br><span class="line">    implementation <span class="string">"androidx.room:room-ktx:$room_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - RxJava support for Room</span></span><br><span class="line">    implementation <span class="string">"androidx.room:room-rxjava2:$room_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - Guava support for Room, including Optional and ListenableFuture</span></span><br><span class="line">    implementation <span class="string">"androidx.room:room-guava:$room_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Test helpers</span></span><br><span class="line">    testImplementation <span class="string">"androidx.room:room-testing:$room_version"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定义实体类 - <code>Entity</code></li><li>定义Dao类 - <code>Dao</code></li><li>定义抽象数据库类 - <code>Database</code></li><li>使用</li></ul><a id="more"></a><h3 id="定义实体"><a href="#定义实体" class="headerlink" title="定义实体"></a>定义实体</h3><p>实体类对应着一张表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PrimaryKey</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> uid;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ColumnInfo</span>(name = <span class="string">"first_name"</span>)</span><br><span class="line">    <span class="keyword">public</span> String firstName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ColumnInfo</span>(name = <span class="string">"last_name"</span>)</span><br><span class="line">    <span class="keyword">public</span> String lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义Dao"><a href="#定义Dao" class="headerlink" title="定义Dao"></a>定义Dao</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"SELECT * FROM user"</span>)</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"SELECT * FROM user WHERE uid IN (:userIds)"</span>)</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">loadAllByIds</span><span class="params">(<span class="keyword">int</span>[] userIds)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"SELECT * FROM user WHERE first_name LIKE :first AND "</span> +</span><br><span class="line">           <span class="string">"last_name LIKE :last LIMIT 1"</span>)</span><br><span class="line">    <span class="function">User <span class="title">findByName</span><span class="params">(String first, String last)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertAll</span><span class="params">(User... users)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delete</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(User user)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Updata</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义room数据库"><a href="#定义room数据库" class="headerlink" title="定义room数据库"></a>定义room数据库</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Database</span>(entities = &#123;User.class&#125;, version = <span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AppDatabase</span> <span class="keyword">extends</span> <span class="title">RoomDatabase</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> UserDao <span class="title">userDao</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AppDatabase db = Room.databaseBuilder(getApplicationContext(),</span><br><span class="line">        AppDatabase.class, <span class="string">"database-name"</span>).build();</span><br><span class="line">db.userDao().insert(<span class="keyword">new</span> User());</span><br></pre></td></tr></table></figure><h2 id="定义实体-1"><a href="#定义实体-1" class="headerlink" title="定义实体"></a>定义实体</h2><h3 id="基础注解"><a href="#基础注解" class="headerlink" title="基础注解"></a>基础注解</h3><ul><li><code>@Entity</code> 标注为实体</li><li><code>@PrimaryKey</code>标注为主键</li><li><code>@ColumnInfo</code>附加字段信息，比如字段名</li><li><code>@Ignore</code> 标注为忽略属性</li></ul><p>使用<code>@Entity</code>标注实体类，属性皆为对应表字段，前提是要<code>JavaBean</code>，要么属性public，要么提供set/get方法。</p><p>使用<code>@PrimaryKey</code>标注主键，<code>autoGenerate</code>值设置自增</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PrimaryKey</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String firstName;</span><br><span class="line">    <span class="keyword">public</span> String lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在<code>@Entity</code>中设置主键</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span>(primaryKeys = &#123;<span class="string">"firstName"</span>, <span class="string">"lastName"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String firstName;</span><br><span class="line">    <span class="keyword">public</span> String lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认是以类名为表名，可以自定义表名，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span>(tableName = <span class="string">"users"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>SQLite中表名忽略大小写的</strong></p></blockquote><p>自定属性对应字段名，使用<code>@ColumnInfo</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span>(tableName = <span class="string">"users"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PrimaryKey</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ColumnInfo</span>(name = <span class="string">"first_name"</span>)</span><br><span class="line">    <span class="keyword">public</span> String firstName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ColumnInfo</span>(name = <span class="string">"last_name"</span>)</span><br><span class="line">    <span class="keyword">public</span> String lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>忽略属性，从而不对应表字段，使用<code>@Ignore</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PrimaryKey</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String firstName;</span><br><span class="line">    <span class="keyword">public</span> String lastName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Ignore</span></span><br><span class="line">    Bitmap picture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样可以在<code>@Entity声明</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span>(ignoredColumns = <span class="string">"picture"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteUser</span> <span class="keyword">extends</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PrimaryKey</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> hasVpn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询支持"><a href="#查询支持" class="headerlink" title="查询支持"></a>查询支持</h3><h4 id="FTS支持"><a href="#FTS支持" class="headerlink" title="FTS支持"></a>FTS支持</h4><p>FTS：Full  Text Search 全文检索</p><p>要求：sdk大于16，Room2.1以上可以Fts3，Fts4</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use `@Fts3` only if your app has strict disk space requirements or if you</span></span><br><span class="line"><span class="comment">// require compatibility with an older SQLite version.</span></span><br><span class="line"><span class="meta">@Fts</span>4</span><br><span class="line"><span class="meta">@Entity</span>(tableName = <span class="string">"users"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Specifying a primary key for an FTS-table-backed entity is optional, but</span></span><br><span class="line">    <span class="comment">// if you include one, it must use this type and column name.</span></span><br><span class="line">    <span class="meta">@PrimaryKey</span></span><br><span class="line">    <span class="meta">@ColumnInfo</span>(name = <span class="string">"rowid"</span>)<span class="comment">//FTS开启后必须int主键名为rowid</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ColumnInfo</span>(name = <span class="string">"first_name"</span>)</span><br><span class="line">    <span class="keyword">public</span> String firstName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用languageId来指定字段来存储多语言信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Fts</span>4(languageId = <span class="string">"lid"</span>)</span><br><span class="line"><span class="meta">@Entity</span>(tableName = <span class="string">"users"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ColumnInfo</span>(name = <span class="string">"lid"</span>)</span><br><span class="line">    <span class="keyword">int</span> languageId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="索引支持"><a href="#索引支持" class="headerlink" title="索引支持"></a>索引支持</h4><p>如果app的sdk版本不支持FTS，为了加快查询速度，可以考虑使用索引，使用<code>@Index</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span>(indices = &#123;<span class="meta">@Index</span>(<span class="string">"name"</span>),<span class="meta">@Index</span>(value = &#123;<span class="string">"last_name"</span>, <span class="string">"address"</span>&#125;)&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PrimaryKey</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String firstName;</span><br><span class="line">    <span class="keyword">public</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ColumnInfo</span>(name = <span class="string">"last_name"</span>)</span><br><span class="line">    <span class="keyword">public</span> String lastName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Ignore</span></span><br><span class="line">    Bitmap picture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>索引唯一，添加unique属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span>(indices = &#123;<span class="meta">@Index</span>(value = &#123;<span class="string">"first_name"</span>, <span class="string">"last_name"</span>&#125;, unique = <span class="keyword">true</span>)&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PrimaryKey</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ColumnInfo</span>(name = <span class="string">"first_name"</span>)</span><br><span class="line">    <span class="keyword">public</span> String firstName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ColumnInfo</span>(name = <span class="string">"last_name"</span>)</span><br><span class="line">    <span class="keyword">public</span> String lastName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Ignore</span></span><br><span class="line">    Bitmap picture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="支持AutoValue对象"><a href="#支持AutoValue对象" class="headerlink" title="支持AutoValue对象"></a>支持AutoValue对象</h3><p>啥是AutoValue？</p><p><a href="https://github.com/google/auto/blob/master/value/userguide/index.md" target="_blank" rel="noopener">AutoValue说明</a>，我看了下文档，大概意思就是说书写JavaBean类，需要写很多get/set，equals等大量模板代码，通过使用<code>@AutoValue</code>注解一个抽象类，书写关键代码，模板代码交由注解处理器生成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.auto.value.AutoValue;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AutoValue</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Animal <span class="title">create</span><span class="params">(String name, <span class="keyword">int</span> numberOfLegs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AutoValue_Animal(name, numberOfLegs);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">abstract</span> String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">numberOfLegs</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过apt注解处理器帮你生成大量的模板代码。诶，这不是和kotlin的Data类挺像的吗。hia~~</p><p>而Room使用AutoValue也很简单，某些标注了注解的地方，一定要加上<code>@CopyAnnotations</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoValue</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Supported annotations must include `@CopyAnnotations`.</span></span><br><span class="line">    <span class="meta">@CopyAnnotations</span></span><br><span class="line">    <span class="meta">@PrimaryKey</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getFirstName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getLastName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Room uses this factory method to create User objects.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">create</span><span class="params">(<span class="keyword">long</span> id, String firstName, String lastName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AutoValue_User(id, firstName, lastName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义对象关系"><a href="#定义对象关系" class="headerlink" title="定义对象关系"></a>定义对象关系</h2><p>Room不允许对象引用</p><h3 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h3><p>一对多的话就是通过外键制约。比如说一个人可以有多本书，一本书只能属于一个人。</p><p>通过<code>@ForeignKey</code>定义外键，外键作用在于能够限定两条数据的级联操作</p><p><code>onUpdate</code> </p><p><code>onDelete</code></p><p>有这么几种值，也是数据库的知识，提下就行了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int NO_ACTION = 1;</span><br><span class="line"></span><br><span class="line">int RESTRICT = 2;</span><br><span class="line"></span><br><span class="line">int SET_NULL = 3;</span><br><span class="line"></span><br><span class="line">int SET_DEFAULT = 4;</span><br><span class="line"></span><br><span class="line">int CASCADE = 5;</span><br></pre></td></tr></table></figure><p>具体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span>(foreignKeys = <span class="meta">@ForeignKey</span>(entity = User.class,</span><br><span class="line">                                  parentColumns = <span class="string">"id"</span>,</span><br><span class="line">                                  childColumns = <span class="string">"user_id"</span>))</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PrimaryKey</span> <span class="keyword">public</span> <span class="keyword">int</span> bookId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ColumnInfo</span>(name = <span class="string">"user_id"</span>) <span class="keyword">public</span> <span class="keyword">int</span> userId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3><p>即比如一个歌单有n首歌，一首歌可以属于n个歌单</p><p>定义实体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Playlist</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PrimaryKey</span> <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String description;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Song</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PrimaryKey</span> <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String songName;</span><br><span class="line">    <span class="keyword">public</span> String artistName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多对多关联需要一个中间实体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span>(tableName = <span class="string">"playlist_song_join"</span>,</span><br><span class="line">        primaryKeys = &#123; <span class="string">"playlistId"</span>, <span class="string">"songId"</span> &#125;,</span><br><span class="line">        foreignKeys = &#123;</span><br><span class="line">                <span class="meta">@ForeignKey</span>(entity = Playlist.class,</span><br><span class="line">                            parentColumns = <span class="string">"id"</span>,</span><br><span class="line">                            childColumns = <span class="string">"playlistId"</span>),</span><br><span class="line">                <span class="meta">@ForeignKey</span>(entity = Song.class,</span><br><span class="line">                            parentColumns = <span class="string">"id"</span>,</span><br><span class="line">                            childColumns = <span class="string">"songId"</span>)</span><br><span class="line">                &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlaylistSongJoin</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> playlistId;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> songId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过中间实体来映射多对多操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlaylistSongJoinDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Insert</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(PlaylistSongJoin playlistSongJoin)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"SELECT * FROM playlist "</span> +</span><br><span class="line">           <span class="string">"INNER JOIN playlist_song_join "</span> +</span><br><span class="line">           <span class="string">"ON playlist.id=playlist_song_join.playlistId "</span> +</span><br><span class="line">           <span class="string">"WHERE playlist_song_join.songId=:songId"</span>)</span><br><span class="line">    <span class="function">List&lt;Playlist&gt; <span class="title">getPlaylistsForSong</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> songId)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"SELECT * FROM song "</span> +</span><br><span class="line">           <span class="string">"INNER JOIN playlist_song_join "</span> +</span><br><span class="line">           <span class="string">"ON song.id=playlist_song_join.songId "</span> +</span><br><span class="line">           <span class="string">"WHERE playlist_song_join.playlistId=:playlistId"</span>)</span><br><span class="line">    <span class="function">List&lt;Song&gt; <span class="title">getSongsForPlaylist</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> playlistId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内嵌对象"><a href="#内嵌对象" class="headerlink" title="内嵌对象"></a>内嵌对象</h3><p>试着想下这么一个实体，比如人的信息，可以在次分割成小的对象表示，比如通过邮编，街道，街牌标注地址对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String street;</span><br><span class="line">    <span class="keyword">public</span> String state;</span><br><span class="line">    <span class="keyword">public</span> String city;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ColumnInfo</span>(name = <span class="string">"post_code"</span>) <span class="keyword">public</span> <span class="keyword">int</span> postCode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PrimaryKey</span> <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String firstName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Embedded</span> <span class="keyword">public</span> Address address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样生成表结构也是一样的，更加解耦，更加好理解，以及使用了。</p><h2 id="创键视图"><a href="#创键视图" class="headerlink" title="创键视图"></a>创键视图</h2><p>sql 里面视图是用户查询使用的，实际生成的表结构也是通过查询的出来，实际上不存在。</p><p>使用<code>@DatabaseView</code>创键一个视图实体，只能用于<strong>查询</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DatabaseView</span>(<span class="string">"SELECT user.id, user.name, user.departmentId,"</span> +</span><br><span class="line">              <span class="string">"department.name AS departmentName FROM user "</span> +</span><br><span class="line">              <span class="string">"INNER JOIN department ON user.departmentId = department.id"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDetail</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> id;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> departmentId;</span><br><span class="line">    <span class="keyword">public</span> String departmentName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在数据库中关联</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Database</span>(entities = &#123;User.class&#125;, views = &#123;UserDetail.class&#125;,</span><br><span class="line">          version = <span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AppDatabase</span> <span class="keyword">extends</span> <span class="title">RoomDatabase</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> UserDao <span class="title">userDao</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用Dao"><a href="#使用Dao" class="headerlink" title="使用Dao"></a>使用Dao</h2><p><code>@Dao</code>可以注解接口和抽象类，取决于是否需要构造。默认dao的查询不能再主线程中，但是可以通过<code>allowMainThreadQueries()</code>再构建器中构建，或者异步的查询考虑返回<code>LiveData</code>或者<code>Flowable</code>。</p><h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><p>使用<code>@Insert</code>来标注插入操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Insert</span>(onConflict = OnConflictStrategy.REPLACE)<span class="comment">//冲突策略</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertUsers</span><span class="params">(User... users)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertBothUsers</span><span class="params">(User user1, User user2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertUsersAndFriends</span><span class="params">(User user, List&lt;User&gt; friends)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入方法可以返回long的值，这个值就是插入Id，如果是插入集合的话，返回的也就是<code>long[]或则List&lt;Long&gt;</code></p><h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><p>根据主键去匹配行，可以返回<code>int</code>表示所影响的行数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Update</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUsers</span><span class="params">(User... users)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><p>通过主键去匹配行，可以返回<code>int</code>表示所影响的行数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Delete</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUsers</span><span class="params">(User... users)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Query"><a href="#Query" class="headerlink" title="Query"></a>Query</h3><h4 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"SELECT * FROM user"</span>)</span><br><span class="line">    <span class="keyword">public</span> User[] loadAllUsers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="带参"><a href="#带参" class="headerlink" title="带参"></a>带参</h4><p>使用<code>:minAge</code>占位参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"SELECT * FROM user WHERE age &gt; :minAge"</span>)</span><br><span class="line">    <span class="keyword">public</span> User[] loadAllUsersOlderThan(<span class="keyword">int</span> minAge);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个占位参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"SELECT * FROM user WHERE age BETWEEN :minAge AND :maxAge"</span>)</span><br><span class="line">    <span class="keyword">public</span> User[] loadAllUsersBetweenAges(<span class="keyword">int</span> minAge, <span class="keyword">int</span> maxAge);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"SELECT * FROM user WHERE first_name LIKE :search "</span> +</span><br><span class="line">           <span class="string">"OR last_name LIKE :search"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findUserWithName</span><span class="params">(String search)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查询的部分字段"><a href="#查询的部分字段" class="headerlink" title="查询的部分字段"></a>查询的部分字段</h4><p>有时候你不需要获得全部字段，只需要部分字段</p><p>定义部分字段POJO，不需要用<code>@Entity</code>哟</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NameTuple</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ColumnInfo</span>(name = <span class="string">"first_name"</span>)</span><br><span class="line">    <span class="keyword">public</span> String firstName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ColumnInfo</span>(name = <span class="string">"last_name"</span>)</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">public</span> String lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"SELECT first_name, last_name FROM user"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;NameTuple&gt; <span class="title">loadFullName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="传入集合"><a href="#传入集合" class="headerlink" title="传入集合"></a>传入集合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"SELECT first_name, last_name FROM user WHERE region IN (:regions)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;NameTuple&gt; <span class="title">loadUsersFromRegions</span><span class="params">(List&lt;String&gt; regions)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="可观察数据"><a href="#可观察数据" class="headerlink" title="可观察数据"></a>可观察数据</h4><p>返回<code>LiveData</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"SELECT first_name, last_name FROM user WHERE region IN (:regions)"</span>)</span><br><span class="line">    <span class="keyword">public</span> LiveData&lt;List&lt;User&gt;&gt; loadUsersFromRegionsSync(List&lt;String&gt; regions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RxJava支持"><a href="#RxJava支持" class="headerlink" title="RxJava支持"></a>RxJava支持</h4><p>首先需要加入RxJava支持依赖</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="keyword">def</span> room_version = <span class="string">"2.1.0"</span></span><br><span class="line">    implementation <span class="string">'androidx.room:room-rxjava2:$room_version'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以返回被压<code>Flowable</code>，<code>Maybe</code>，<code>Completeable</code>，<code>Single</code>等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"SELECT * from user where id = :id LIMIT 1"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flowable&lt;User&gt; <span class="title">loadUserById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Emits the number of users added to the database.</span></span><br><span class="line">    <span class="meta">@Insert</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Maybe&lt;Integer&gt; <span class="title">insertLargeNumberOfUsers</span><span class="params">(List&lt;User&gt; users)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Makes sure that the operation finishes successfully.</span></span><br><span class="line">    <span class="meta">@Insert</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Completable <span class="title">insertLargeNumberOfUsers</span><span class="params">(User... users)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Emits the number of users removed from the database. Always emits at</span></span><br><span class="line"><span class="comment">       least one user. */</span></span><br><span class="line">    <span class="meta">@Delete</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Single&lt;Integer&gt; <span class="title">deleteUsers</span><span class="params">(List&lt;User&gt; users)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详情见 <a href="https://medium.com/google-developers/room-rxjava-acb0cd4f3757" target="_blank" rel="noopener">Room and RxJava</a></p><h4 id="返回Cursor"><a href="#返回Cursor" class="headerlink" title="返回Cursor"></a>返回Cursor</h4><p>当然了，对原来的Cursor游标也是支持返回的</p><p>非常不提倡使用<code>Cursor</code>，因为游标不保证能查询的行存在，以及行内元素存在，除非你的项目期待使用游标，或者重构困难才考虑返回游标</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"SELECT * FROM user WHERE age &gt; :minAge LIMIT 5"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cursor <span class="title">loadRawUsersOlderThan</span><span class="params">(<span class="keyword">int</span> minAge)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多表联合查询"><a href="#多表联合查询" class="headerlink" title="多表联合查询"></a>多表联合查询</h4><p>允许多表联合查询，同时允许返回<code>LiveData</code>和<code>Flowable</code>等可观察数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"SELECT * FROM book "</span> +</span><br><span class="line">           <span class="string">"INNER JOIN loan ON loan.book_id = book.id "</span> +</span><br><span class="line">           <span class="string">"INNER JOIN user ON user.id = loan.user_id "</span> +</span><br><span class="line">           <span class="string">"WHERE user.name LIKE :userName"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">findBooksBorrowedByNameSync</span><span class="params">(String userName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>允许使用POJO</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Query</span>(<span class="string">"SELECT user.name AS userName, pet.name AS petName "</span> +</span><br><span class="line">          <span class="string">"FROM user, pet "</span> +</span><br><span class="line">          <span class="string">"WHERE user.id = pet.user_id"</span>)</span><br><span class="line">   <span class="keyword">public</span> LiveData&lt;List&lt;UserPet&gt;&gt; loadUserAndPetNames();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// You can also define this class in a separate file, as long as you add the</span></span><br><span class="line">   <span class="comment">// "public" access modifier.</span></span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UserPet</span> </span>&#123;</span><br><span class="line">       <span class="keyword">public</span> String userName;</span><br><span class="line">       <span class="keyword">public</span> String petName;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用kotlin协程"><a href="#使用kotlin协程" class="headerlink" title="使用kotlin协程"></a>使用kotlin协程</h4><p><code>suspend</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Insert(onConflict = OnConflictStrategy.REPLACE)</span></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">insertUsers</span><span class="params">(<span class="keyword">vararg</span> users: <span class="type">User</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update</span></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateUsers</span><span class="params">(<span class="keyword">vararg</span> users: <span class="type">User</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delete</span></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">deleteUsers</span><span class="params">(<span class="keyword">vararg</span> users: <span class="type">User</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">"SELECT * FROM user"</span>)</span></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">loadAllUsers</span><span class="params">()</span></span>: Array&lt;User&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明事务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">UsersDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Transaction</span></span><br><span class="line">    <span class="function">open suspend fun <span class="title">setLoggedInUser</span><span class="params">(loggedInUser: User)</span> </span>&#123;</span><br><span class="line">        deleteUser(loggedInUser)</span><br><span class="line">        insertUser(loggedInUser)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"DELETE FROM users"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> fun <span class="title">deleteUser</span><span class="params">(user: User)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    @Insert</span></span><br><span class="line"><span class="function">    <span class="keyword">abstract</span> suspend fun <span class="title">insertUser</span><span class="params">(user: User)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="类型转换器"><a href="#类型转换器" class="headerlink" title="类型转换器"></a>类型转换器</h2><p>定义类型转化器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Converters</span> </span>&#123;</span><br><span class="line">    <span class="meta">@TypeConverter</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">fromTimestamp</span><span class="params">(Long value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value == <span class="keyword">null</span> ? <span class="keyword">null</span> : <span class="keyword">new</span> Date(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TypeConverter</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">dateToTimestamp</span><span class="params">(Date date)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> date == <span class="keyword">null</span> ? <span class="keyword">null</span> : date.getTime();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Database</span>(entities = &#123;User.class&#125;, version = <span class="number">1</span>)</span><br><span class="line"><span class="meta">@TypeConverters</span>(&#123;Converters.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AppDatabase</span> <span class="keyword">extends</span> <span class="title">RoomDatabase</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> UserDao <span class="title">userDao</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自动将Java的Date和数据库中的时间戳互相转化</p><h2 id="数据库迁移"><a href="#数据库迁移" class="headerlink" title="数据库迁移"></a>数据库迁移</h2><p>待补充</p><p>数据库测试</p><p>待补充</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> db Jetpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-排序算法复习</title>
      <link href="/2019/08/03/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/"/>
      <url>/2019/08/03/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>描述：相邻间的元素两两比较，依次交换，从一端到另一端冒出最大值，循环冒出最大值，完成排序。N^2^</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>描述：依次循环扫描出最大值，放在另一端。</p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>描述：和打牌类似，依次遍历元素，将元素，插入到合适的位置。</p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>描述：插入排序的变体，插入排序是相邻交换，而希尔排序是间隔为k的，通过大间隔的插入排序，在锐减到k=1即默认的插入排序。</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>描述：分治思想，将一个数组分为两部分，中间是基准值，左边的都是比基准值小，右边都是比基准值大。然后对左区间和右区间执行同样的划分。最终划分到最小的时候，就完成了排序。</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>描述：分治思想，借用存储空间，将一个数组划分两部分，左边排序，右边排序，将两个区间合并成一个有序。通过分治思想，左右两个区间同样可以进行排序归并，最终划分到最小区间。依次向上合并成有序。</p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>描述：堆是一种二叉树，某节点总是大于其子节点，利用这个特性，进行构建堆，然后将最顶上的值和最后的数进行交换，然后将交换后的堆进行下沉而维持堆的结构，重复交换堆顶元素和堆尾元素，从而构建有序。</p><h2 id="二叉树排序"><a href="#二叉树排序" class="headerlink" title="二叉树排序"></a>二叉树排序</h2><p>描述：利用BST的特性，父亲节点大于左节点，小于右节点，构建BST，通过中序遍历，得出有序序列</p><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>描述：非比较排序，通过借助数组存储，将元素的值映射到数组索引，来标记计数元素的重复个数，按照索引计数，得出有序序列</p><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>描述：计数排序的升级版，计数排序可以成是桶容量为1的桶排序。因为桶的容量为1，因此不需要桶内排序。所以正常的桶排序比计数排序更加的节省内存，通过特定的映射关系，将元素映射到桶内，此时映射完毕后每个桶是有序的。但是桶内需要通过其它的排序算法进行排序。</p><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>描述：巧妙的利用了计数排序，以及桶的思维，通过<strong>按位</strong>的数字进行计数排序，这里解释下按位，从低位到高位，比如123，低位到高位的位3，2，1。低位到高位是一个循环，循环里面将会根据位的数字进行计数排序，将数字分摊到10个桶中。执行到最高位的计数排序后，依次取出，后就是排好序的数组了。这个算法简单概括就是，根据数字的位数排序，比如一个数组内，我可以很轻松的通过借助10个数组排序好0-10的数字，接下来排序十位数的数字，之前的个位数，明显整除10为0，肯定会被有序的安排到0号桶里面去。继而排序十位数。依次类推。</p><p>偷张图来形象说明下。</p><p><img src="https://upload-images.jianshu.io/upload_images/944288-503476b174097dbc?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt></p><p>图来自简书：<a href="https://www.jianshu.com/p/367b0fe09c9b?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="noopener">https://www.jianshu.com/p/367b0fe09c9b?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation</a></p><p>参考：</p><p><a href="https://www.jianshu.com/p/367b0fe09c9b?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="noopener">https://www.jianshu.com/p/367b0fe09c9b?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android-MVVM之LiveData和ViewModel</title>
      <link href="/2019/08/01/Android-LiveData%20and%20ViewModel/"/>
      <url>/2019/08/01/Android-LiveData%20and%20ViewModel/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前归纳了databinding，说到底databinding也只是承载实体数据和UI进行关联，以及它们之间互通，转换。但是呢们开发过程中需要有中间人来控制逻辑，连接后台数据到绑定数据。这个时候ViewModel加上DataBinding以及LiveData就可以很好的组成一种架构模式。我们还是在了解LiveData和ViewModel之后，再结合之前的DataBinding来说MVVM吧。</p><h2 id="LiveData"><a href="#LiveData" class="headerlink" title="LiveData"></a>LiveData</h2><p>老规矩，首先附上官方文档地址：<a href="https://developer.android.google.cn/topic/libraries/architecture/livedata" target="_blank" rel="noopener">LiveData</a></p><p>看看官方怎么定义LiveData的：</p><blockquote><p>LiveData是一个可观察对象持有类，不同于平常的可观察对象，LiveData是有生命周期感知的，意味着它会关心app组件的生命周期，比如Activity，fragment，service。这种感知特性保证LiveData只会在生命周期活跃的时候进行观察更新。</p></blockquote><p>LiveData考虑将观察者，在生命周期为<code>started</code>和<code>resumed</code>下保持活跃。LiveData仅仅会通知活跃的观察者进行更新，不活跃的观察者不会收到任何通知。</p><p>你可以注册观察者并且给他配对实现了<a href="https://developer.android.google.cn/reference/androidx/lifecycle/LifecycleOwner.html" target="_blank" rel="noopener"><code>LifecycleOwner</code></a> 的接口的对象。在这层关系下，观察者会在<code>Lifecycle</code>对象进入<code>destory</code>时被移除，这个对于<code>fragment</code>和<code>activity</code>非常有用，它可以很安全的观察livedata对象，在<code>fragment</code>和<code>activity</code>生命周期销毁时，它们会立即解除订阅，不会产生内存泄漏。</p><a id="more"></a><h3 id="LiveData优点"><a href="#LiveData优点" class="headerlink" title="LiveData优点"></a>LiveData优点</h3><ul><li><p>确保UI和数据状态匹配</p><p>通过观察者模式，livedata会在生命周期发生改变通知观察者，通过书写固定更新UI代码，在数据发生改变时触发，而不是手动在数据改变时改变UI。</p></li><li><p>没有内存泄漏</p><p>观察者会被绑定到<code>Lifecycle</code>对象，在关联的生命周期被销毁时，观察者会被清理。</p></li><li><p>activity停止不会崩溃</p><p>如果观察者处于不活跃状态，比如activity在后台运行，观察者不会收到livedata的事件</p></li><li><p>不需要手动管理生命周期</p><p>UI组件只会观察数据，不会停止和恢复观察，这些都是交由livedata自动管理。因为livedata可以感知</p></li><li><p>保持数据最新</p><p>如果生命周期是不活跃的，它将在变为活跃是获取最新的数据。例如activity从后台来到前台将会收取最新的数据。</p></li><li><p>适配配置更改</p><p>activity和fragment因为配置更改而重建，它们会收到最新的数据</p></li><li><p>共享资源</p><p>使用单例模式继承LiveData，并且包裹系统服务，以便能够在在全局使用，一旦连接到系统服务，任何观察者都可以查看livedata。</p></li></ul><h3 id="使用LiveData"><a href="#使用LiveData" class="headerlink" title="使用LiveData"></a>使用LiveData</h3><p>一般来讲是要声明依赖</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="keyword">def</span> lifecycle_version = <span class="string">"2.0.0"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ViewModel and LiveData</span></span><br><span class="line">    implementation <span class="string">"androidx.lifecycle:lifecycle-extensions:$lifecycle_version"</span></span><br><span class="line">    <span class="comment">// alternatively - just ViewModel</span></span><br><span class="line">    implementation <span class="string">"androidx.lifecycle:lifecycle-viewmodel:$lifecycle_version"</span> <span class="comment">// For Kotlin use lifecycle-viewmodel-ktx</span></span><br><span class="line">    <span class="comment">// alternatively - just LiveData</span></span><br><span class="line">    implementation <span class="string">"androidx.lifecycle:lifecycle-livedata:$lifecycle_version"</span></span><br><span class="line">    <span class="comment">// alternatively - Lifecycles only (no ViewModel or LiveData). Some UI</span></span><br><span class="line">    <span class="comment">//     AndroidX libraries use this lightweight import for Lifecycle</span></span><br><span class="line">    implementation <span class="string">"androidx.lifecycle:lifecycle-runtime:$lifecycle_version"</span></span><br><span class="line"></span><br><span class="line">    annotationProcessor <span class="string">"androidx.lifecycle:lifecycle-compiler:$lifecycle_version"</span> <span class="comment">// For Kotlin use kapt instead of annotationProcessor</span></span><br><span class="line">    <span class="comment">// alternately - if using Java8, use the following instead of lifecycle-compiler</span></span><br><span class="line">    implementation <span class="string">"androidx.lifecycle:lifecycle-common-java8:$lifecycle_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - ReactiveStreams support for LiveData</span></span><br><span class="line">    implementation <span class="string">"androidx.lifecycle:lifecycle-reactivestreams:$lifecycle_version"</span> <span class="comment">// For Kotlin use lifecycle-reactivestreams-ktx</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - Test helpers for LiveData</span></span><br><span class="line">    testImplementation <span class="string">"androidx.arch.core:core-testing:$lifecycle_version"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是呢，我在AS3.4的基础上打开Databing后，这些LiveData和ViewModel都有了。。这些组件也是几年前就有了就，估计因为现在是9012年的原因，直接都给你集成好了。</p><p>一般来说是这样的步骤：</p><ul><li>在ViewModel中声明创键LiveData对象</li><li>在UI控制器中，比如activity，fragment中创键观察者<code>Observer</code>对象，实现<code>onChange</code>逻辑</li><li>通过在LiveData上调用<code>oberve</code>关联<code>Observer</code>和<code>LiveData</code>，需要传入<code>lifecycleOwner</code>，一般是在UI控制中执行</li></ul><blockquote><p>如果oberver和livedata之间没有关联lifecycleOwner，则默认考虑这个observer总是处于活跃状态，即总是接受通知发生调用。你可以通过<code>removeOberver()</code>移除它</p></blockquote><p>当livedata数据发生改变，将会触发附着在生命周期上活跃的oberver</p><p>livedata允许在控制器中订阅它，并且触发进行UI变化</p><h4 id="创键LiveData对象"><a href="#创键LiveData对象" class="headerlink" title="创键LiveData对象"></a>创键LiveData对象</h4><p>LiveData一个可以包装对象，包括了集合，一个LiveData通常是在ViewModel中声明的，同时提供getter方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NameViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Create a LiveData with a String</span></span><br><span class="line">    <span class="keyword">private</span> MutableLiveData&lt;String&gt; currentName;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> MutableLiveData&lt;String&gt; <span class="title">getCurrentName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (currentName == <span class="keyword">null</span>) &#123;</span><br><span class="line">            currentName = <span class="keyword">new</span> MutableLiveData&lt;String&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> currentName;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// Rest of the ViewModel...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>确保在ViewModel中存储UI的LiveData对象，第一，避免activity和fragment过度膨胀，它们的职责应该是负责UI显示而不是保存数据状态，第二、将LiveData实例和activity，fragment进行解耦，并且允许在配置发生改变时依然存活</p></blockquote><h4 id="观察LiveData对象"><a href="#观察LiveData对象" class="headerlink" title="观察LiveData对象"></a>观察LiveData对象</h4><p>在大多数情况下，在app组件的<code>onCreate</code>方法中开启<code>LiveData</code>观察是非常适合的，原因如下：</p><ul><li>onResume调用时不会产生冗余调用在</li><li>确保activity，fragment拥有数据，在处于活跃状态立即展示它，一旦进入<code>started</code>状态，立即收取最近的数据</li></ul><p>触发活跃状态下的oberver，例外，从非活跃转为活跃也会触发，如果第二次从非活跃到活跃，只有上次情况下的值发生改变了才会触发。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NameActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> NameViewModel model;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="comment">// Other code to setup the activity...</span></span><br><span class="line">        <span class="comment">// Get the ViewModel.</span></span><br><span class="line">        model = ViewModelProviders.of(<span class="keyword">this</span>).get(NameViewModel.class);</span><br><span class="line">        <span class="comment">// Create the observer which updates the UI.</span></span><br><span class="line">        <span class="keyword">final</span> Observer&lt;String&gt; nameObserver = <span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChanged</span><span class="params">(@Nullable <span class="keyword">final</span> String newName)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// Update the UI, in this case, a TextView.</span></span><br><span class="line">                nameTextView.setText(newName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// Observe the LiveData, passing in this activity as the LifecycleOwner and the observer.</span></span><br><span class="line">        model.getCurrentName().observe(<span class="keyword">this</span>, nameObserver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据改变，触发监听</p><h4 id="更新LiveData对象"><a href="#更新LiveData对象" class="headerlink" title="更新LiveData对象"></a>更新LiveData对象</h4><p>通过<code>setValue(T)</code>和<code>postValue</code>来更新数据，触发监听，更新UI</p><p><code>setValue</code>只能在主线程中更新数据</p><p><code>postValue</code>可以在子线程中，子线程中用它就对了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">button.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        String anotherName = <span class="string">"John Doe"</span>;</span><br><span class="line">        model.getCurrentName().setValue(anotherName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="Room中使用LiveData"><a href="#Room中使用LiveData" class="headerlink" title="Room中使用LiveData"></a>Room中使用LiveData</h4><p>Room支持可观察的查询，返回LiveData对象，通过LiveData，以及设置观察者，保持UI数据和数据库同步，具体以后看Room的学习吧</p><h4 id="LiveData使用协程"><a href="#LiveData使用协程" class="headerlink" title="LiveData使用协程"></a>LiveData使用协程</h4><p>支持kotlin的协程（呃呃，这个我还不是很会😭）</p><h3 id="扩展LiveData"><a href="#扩展LiveData" class="headerlink" title="扩展LiveData"></a>扩展LiveData</h3><p>LiveData会根据oberver生命周期宿主是否是<code>STARTED</code>和<code>RESUME</code>来认定oberver是否处于活跃和非活跃状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StockLiveData</span> <span class="keyword">extends</span> <span class="title">LiveData</span>&lt;<span class="title">BigDecimal</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> StockManager stockManager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SimplePriceListener listener = <span class="keyword">new</span> SimplePriceListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPriceChanged</span><span class="params">(BigDecimal price)</span> </span>&#123;</span><br><span class="line">            setValue(price);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StockLiveData</span><span class="params">(String symbol)</span> </span>&#123;</span><br><span class="line">        stockManager = <span class="keyword">new</span> StockManager(symbol);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stockManager.requestPriceUpdates(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onInactive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stockManager.removeUpdates(listener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>onActive 当LiveData拥有活跃的oberver，可以开始监听数据，调用</li><li>onInActive LiveData没有活跃的oberver，不会触发监听，调用</li></ul><p>通过扩展，可以加入自己的监听器</p><p>这些obsever会随着生命周期变化，比如活跃状态，消亡状态</p><p>通过单例进行分享</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StockLiveData</span> <span class="keyword">extends</span> <span class="title">LiveData</span>&lt;<span class="title">BigDecimal</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> StockLiveData sInstance;</span><br><span class="line">    <span class="keyword">private</span> StockManager stockManager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SimplePriceListener listener = <span class="keyword">new</span> SimplePriceListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPriceChanged</span><span class="params">(BigDecimal price)</span> </span>&#123;</span><br><span class="line">            setValue(price);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StockLiveData <span class="title">get</span><span class="params">(String symbol)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sInstance = <span class="keyword">new</span> StockLiveData(symbol);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StockLiveData</span><span class="params">(String symbol)</span> </span>&#123;</span><br><span class="line">        stockManager = <span class="keyword">new</span> StockManager(symbol);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stockManager.requestPriceUpdates(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onInactive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stockManager.removeUpdates(listener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后你可以在fragment使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        StockLiveData.get(symbol).observe(<span class="keyword">this</span>, price -&gt; &#123;</span><br><span class="line">            <span class="comment">// Update the UI.</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="变换LiveData"><a href="#变换LiveData" class="headerlink" title="变换LiveData"></a>变换LiveData</h3><p>当你想要在发送通知前改变<code>LiveData</code>的值，或者你需要基于原来的<code>LiveData</code>返回一个另一<code>LiveData</code>，<code>LifeCycle</code>包里面提供了这样的工具类<code>Transformations</code></p><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LiveData&lt;User&gt; userLiveData = ...;</span><br><span class="line">LiveData&lt;String&gt; userName = Transformations.map(userLiveData, user -&gt; &#123;</span><br><span class="line">    user.name + <span class="string">" "</span> + user.lastName</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="switchMap"><a href="#switchMap" class="headerlink" title="switchMap"></a>switchMap</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> LiveData&lt;User&gt; <span class="title">getUser</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">  ...;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LiveData&lt;String&gt; userId = ...;</span><br><span class="line">LiveData&lt;User&gt; user = Transformations.switchMap(userId, id -&gt; getUser(id) );</span><br></pre></td></tr></table></figure><p>变换是惰性的，只有在在正处于观察和返回数据时进行计算。</p><h3 id="合并多个LiveData源"><a href="#合并多个LiveData源" class="headerlink" title="合并多个LiveData源"></a>合并多个LiveData源</h3><p><code>MediatorLiveData</code>是一个包装了LiveData数据源集合的LiveData的，本质上是个包装类，也就是说完全可以当初LiveData使用，内部的话可以添加多个LiveData数据源，并且设置监听，一旦某数据源发生数据改变，可以触发监听，同时可以设置自身的数据，从而表现为一个LiveData。简单点说就是可以接受多个数据源，从而发生改变表现为一个数据源。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总的来讲LiveData对象，就是一个具有生命周期感知的，持有可观察数据，不仅仅局限于UI。使用它可以在MVVM的结构中使得ViewModel不依赖View这一层从而完成View的变化。</p><p>View-&gt;ViewModel-&gt;Model</p><h2 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h2><p>定义：在生命周期中，用于存储管理UI关联的数据。ViewModel允许在配置发生改变时存活</p><p>缘由：</p><p>Android framework管理者activity，fragment的生命周期，Android framework 也许会因为某些失控的事件和操作来进行销毁，重建activity，fragment。在发生这种情况下时候，瞬时的UI数据就会丢失，在之前的情况下我们会通过<code>onSaveInstanceState</code>去保存某些数据，以便下次重建时<code>onCreate</code>进行数据恢复，但是这个解决方式只适用于一些轻量的序列化数据，像那些<code>Bitmap</code>就不适用了。</p><p>再者，UI控制器会经常性去做一些异步调用，并且有可能返回数据，为了防止内存泄漏，UI控制器需要管理这些调用，在UI控制器销毁时去清理。这种方式需要大量的维护，并且在配置发生改变，某些需要重建的资源对象在重建时会消耗大量资源。</p><p>对于UI控制器来说，它的责任应该是UI展示，UI交互，处理和系统的交流比如权限请求。将过多的责任分配给UI控制器会导致代码臃肿。尝试将一些责任分配出去，也会便于测试。</p><h3 id="实现ViewModel"><a href="#实现ViewModel" class="headerlink" title="实现ViewModel"></a>实现ViewModel</h3><p>架构组件提供ViewModel来帮助UI控制器承担UI数据贮备的职责，并且它会在配置改变时自动保存，下次恢复时立马可用。</p><p>这个例子是用于加载用户列表数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MutableLiveData&lt;List&lt;User&gt;&gt; users;</span><br><span class="line">    <span class="keyword">public</span> LiveData&lt;List&lt;User&gt;&gt; getUsers() &#123;</span><br><span class="line">        <span class="keyword">if</span> (users == <span class="keyword">null</span>) &#123;</span><br><span class="line">            users = <span class="keyword">new</span> MutableLiveData&lt;List&lt;User&gt;&gt;();</span><br><span class="line">            loadUsers();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Do an asynchronous operation to fetch users.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在UI控制器中监听数据变化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Create a ViewModel the first time the system calls an activity's onCreate() method.</span></span><br><span class="line">        <span class="comment">// Re-created activities receive the same MyViewModel instance created by the first activity.</span></span><br><span class="line"></span><br><span class="line">        MyViewModel model = ViewModelProviders.of(<span class="keyword">this</span>).get(MyViewModel.class);</span><br><span class="line">        model.getUsers().observe(<span class="keyword">this</span>, users -&gt; &#123;</span><br><span class="line">            <span class="comment">// update UI</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ViewModel不允许持有View引用、Lifecycle以及任何持有了activity context的对象的引用</strong>，<strong>即UI无关</strong></p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>ViewModel的作用域是通过<code>Lifecycle</code>通过<code>ViewModelProvider</code>传递的，<code>ViewModel</code>会保留在内存中，直到<code>Lifecycle</code>的作用域消失，比如，activity的finish，fragment的detach，可以见下图</p><p><img src="https://developer.android.google.cn/images/topic/libraries/architecture/viewmodel-lifecycle.png" alt="ViewModel生命周期"></p><p>通常来讲实在第一次请求<code>onCreate</code>创键<code>ViewModel</code>，过程中可能多次<code>onCreate</code>，但是在第一次请求<code>ViewModel</code>直到activity finished and destroyed 之间都是存在的。</p><h3 id="在Fragment间共享数据，通信"><a href="#在Fragment间共享数据，通信" class="headerlink" title="在Fragment间共享数据，通信"></a>在Fragment间共享数据，通信</h3><p>通常一个activity会包含多个fragment，然而多个fragment之间会涉及相关联的数据以及操作，fragment之间需要通信，简单的解决方法是通过定义接口进行回调，但是很繁琐，每个都写那不得烦死，还得绑定，解绑，生命周期可见性，各种考虑。通过共享得ViewModel可以很好的解决这个问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SharedViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MutableLiveData&lt;Item&gt; selected = <span class="keyword">new</span> MutableLiveData&lt;Item&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">        selected.setValue(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LiveData&lt;Item&gt; <span class="title">getSelected</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> selected;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MasterFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SharedViewModel model;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        model = ViewModelProviders.of(getActivity()).get(SharedViewModel.class);</span><br><span class="line">        itemSelector.setOnClickListener(item -&gt; &#123;</span><br><span class="line">            model.select(item);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DetailFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        SharedViewModel model = ViewModelProviders.of(getActivity()).get(SharedViewModel.class);</span><br><span class="line">        model.getSelected().observe(<span class="keyword">this</span>, &#123; item -&gt;</span><br><span class="line">           <span class="comment">// Update the UI.</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个fragment共同处于一个activity，当然viewmodel也是同一个。</p><p>优点</p><ul><li>activity不需要了解任何事情，甚至通信内容</li><li>fragment只需要了解和Viewmodel之间的契约，其它的不需要了解，其中之一的fragment消失了，另一个还是会正常工作</li><li>每个fragment都有各自的生命周期，它们之间互不影响，如果一个fragment被替换了，UI还是会正常工作。</li></ul><h3 id="使用ViewModel替换loader进行加载"><a href="#使用ViewModel替换loader进行加载" class="headerlink" title="使用ViewModel替换loader进行加载"></a>使用ViewModel替换loader进行加载</h3><p>以前使用loader来同步UI和数据库的数据</p><p><img src="https://developer.android.google.cn/images/topic/libraries/architecture/viewmodel-loader.png" alt></p><p>现在这样用</p><p><img src="https://developer.android.google.cn/images/topic/libraries/architecture/viewmodel-replace-loader.png" alt></p><h3 id="ViewModel中使用协程"><a href="#ViewModel中使用协程" class="headerlink" title="ViewModel中使用协程"></a>ViewModel中使用协程</h3><p>待学习</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p> 随着数据变得复杂，考虑将数据加载分离出去，当当当，这一步走完不就是MVVM了吗？哈哈</p><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>其实从DataBind到LiveData，再到ViewModel就差不多是MVVM的雏形了</p><p>M：Model层，用于实际的数据加载，只负责加载数据</p><p>V：View层，负责UI展示，交互</p><p>VM：ViewMdoel层，负责View的数据，连通View和Model，负责获取Model的数据，转化为UI的数据，当然也包括了逻辑处理</p><p>如果感觉VM层太繁重，可以继续分离一层Presenter来处理逻辑，亦或者分离一层Mediator来处理验证</p><p>View -&gt; ViewModel -&gt; Model 现在的依赖单向，通过LiveData和双向绑定，ViewModel不需要依赖View了。</p><p>现在的架构变成这样了，简洁明了</p><p><img src="https://developer.android.google.cn/topic/libraries/architecture/images/final-architecture.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mvvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android-MVVM之DataBinding</title>
      <link href="/2019/07/30/Android-DataBinding/"/>
      <url>/2019/07/30/Android-DataBinding/</url>
      
        <content type="html"><![CDATA[<blockquote><p>MVVM一种android架构模式，谷歌官方架构中实现了，包括databinding，viewmodel，livedata，room，lifecycle，等一套用于mvvm架构的架构组件。</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>整体学习MVVM之前，我们可以先来单独看看DataBinding是干嘛的</p><p>首先附上官方文档地址：<a href="https://developer.android.google.cn/topic/libraries/data-binding" target="_blank" rel="noopener">Data Binding Library</a> ，以及<a href="https://github.com/googlesamples/android-databinding" target="_blank" rel="noopener">官方demo</a></p><p>官方是这么说的：</p><blockquote><p>数据绑定库是一种支持库，借助该库，您可以使用声明性格式（而非程序化地）将布局中的界面组件绑定到应用中的数据源。</p></blockquote><p>就像下面这样：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:text</span>=<span class="string">"@&#123;viewmodel.userName&#125;"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>诶，好像似曾相识，对了，和那个jsp的el表达式，以及spring中表达式有点像啊。这样就好理解了，xml UI通过某种数据绑定，可以通过这种声明式将数据传到UI中。不得不说有点亲切，哈哈。我下面的写东西也基本上是总结(翻译233)官方文档，所以结构也是一样的。</p><a id="more"></a><h2 id="初步"><a href="#初步" class="headerlink" title="初步"></a>初步</h2><blockquote><p>API要求14以上，gradle1.5以上</p></blockquote><h3 id="构建环境"><a href="#构建环境" class="headerlink" title="构建环境"></a>构建环境</h3><p>开启DataBinding</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    dataBinding &#123;</span><br><span class="line">        enabled = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AS对databinding的支持"><a href="#AS对databinding的支持" class="headerlink" title="AS对databinding的支持"></a>AS对databinding的支持</h3><ul><li>语法高亮</li><li>语法错误标记</li><li>xml代码完成</li><li>引用定位至导航和文档</li></ul><h2 id="布局和绑定表达式"><a href="#布局和绑定表达式" class="headerlink" title="布局和绑定表达式"></a>布局和绑定表达式</h2><p>这里开始啦啊</p><h3 id="包含DataBinding的layout"><a href="#包含DataBinding的layout" class="headerlink" title="包含DataBinding的layout"></a>包含DataBinding的layout</h3><p>在原本基础上外层套上以<code>layout</code>标签，以及内部紧跟着声明<code>data</code>标签，在data标签使用<code>variable</code>里面就可声明绑定变量了。在xml中使用绑定数据通过<code>@{user.firstName}</code>的形式使用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">type</span>=<span class="string">"com.example.User"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:text</span>=<span class="string">"@&#123;user.firstName&#125;"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:text</span>=<span class="string">"@&#123;user.lastName&#125;"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="声明数据对象"><a href="#声明数据对象" class="headerlink" title="声明数据对象"></a>声明数据对象</h3><p>使用pojo简单对象，或者老套路，get/set准备，然后<code>@{user.firstName}</code>会去调用<code>getFirstName()</code>或者<code>firstName()</code>，或者直接访问前提是public的<code>firstName</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> String firstName;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> String lastName;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String firstName, String lastName)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">      <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="绑定数据"><a href="#绑定数据" class="headerlink" title="绑定数据"></a>绑定数据</h3><p>通过上述声明layout文件，开始构建，会生成以xml文件开头，尾缀为Binding的类，比如<code>ActivityMainBinding.java</code>，下面看下如何将对象绑定到layout文件中的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">   ActivityMainBinding binding = DataBindingUtil.setContentView(<span class="keyword">this</span>, R.layout.activity_main);</span><br><span class="line">   User user = <span class="keyword">new</span> User(<span class="string">"Test"</span>, <span class="string">"User"</span>);</span><br><span class="line">   binding.setUser(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来数据就和layout绑定好了，layout就能通过表达是显示绑定数据</p><p>使用<code>LayoutInflater</code>获取binding</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ActivityMainBinding binding = ActivityMainBinding.inflate(getLayoutInflater());</span><br></pre></td></tr></table></figure><p>如果在<code>Fragment</code>，<code>ListView</code>，<code>RecyclerView adapter</code>中使用databinding，可以这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ListItemBinding binding = ListItemBinding.inflate(layoutInflater, viewGroup, <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">ListItemBinding binding = DataBindingUtil.inflate(layoutInflater, R.layout.list_item, viewGroup, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><h3 id="表达式语言"><a href="#表达式语言" class="headerlink" title="表达式语言"></a>表达式语言</h3><h4 id="通用表达"><a href="#通用表达" class="headerlink" title="通用表达"></a>通用表达</h4><p>表达式语言和代码很相似，可以使用以下的操作符和关键字</p><ul><li>算术符：<code>+ - / * %</code></li><li>字符串连接符：<code>+</code></li><li>逻辑符<code>&amp;&amp; ||</code></li><li>位操作符：<code>&amp; | ^</code></li><li>一元运算符：<code>+ - ! ~</code></li><li>移位符：<code>&gt;&gt; &gt;&gt;&gt; &lt;&lt;</code></li><li>比较符：== &gt; &lt; &gt;= &lt;=<code>(Note that</code>&lt;<code>needs to be escaped as</code>&lt;`)</li><li><code>instanceof</code></li><li>括号<code>()</code></li><li>字面量： character, String, numeric, <code>null</code></li><li>类型转换</li><li>方法调用</li><li>属性访问</li><li>数组访问 <code>[]</code></li><li>三元符 <code>?:</code></li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">android:text=<span class="string">"@&#123;String.valueOf(index + 1)&#125;"</span></span><br><span class="line">android:visibility=<span class="string">"@&#123;age &gt; 13 ? View.GONE : View.VISIBLE&#125;"</span></span><br><span class="line">android:transitionName=<span class="string">'@&#123;"image_" + id&#125;'</span></span><br></pre></td></tr></table></figure><h4 id="不可以用的操作符"><a href="#不可以用的操作符" class="headerlink" title="不可以用的操作符"></a>不可以用的操作符</h4><ul><li><code>this</code></li><li><code>super</code></li><li><code>new</code></li><li>Explicit generic invocation （我理解位泛型调用行吗？）</li></ul><h4 id="空合并运算符"><a href="#空合并运算符" class="headerlink" title="空合并运算符"></a>空合并运算符</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:text=<span class="string">"@&#123;user.displayName ?? user.lastName&#125;"</span></span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:text=<span class="string">"@&#123;user.displayName != null ? user.displayName : user.lastName&#125;"</span></span><br></pre></td></tr></table></figure><h4 id="属性访问"><a href="#属性访问" class="headerlink" title="属性访问"></a>属性访问</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:text=<span class="string">"@&#123;user.lastName&#125;"</span></span><br></pre></td></tr></table></figure><h4 id="防止空指针异常"><a href="#防止空指针异常" class="headerlink" title="防止空指针异常"></a>防止空指针异常</h4><p>生成的绑定代码自动检查<code>null</code>以及防止空指针异常，比如<code>@{user.name}</code>中如果user为空，那么name会被分配为null，如果是<code>@{user.age}</code>，则age分配为0</p><h4 id="运用集合"><a href="#运用集合" class="headerlink" title="运用集合"></a>运用集合</h4><p>自然是少不不了集合了的使用了，数组，list，sparse list ，map可以通过<code>[]</code>形式访问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;data&gt;</span><br><span class="line">    &lt;<span class="keyword">import</span> type=<span class="string">"android.util.SparseArray"</span>/&gt;</span><br><span class="line">    &lt;<span class="keyword">import</span> type=<span class="string">"java.util.Map"</span>/&gt;</span><br><span class="line">    &lt;<span class="keyword">import</span> type=<span class="string">"java.util.List"</span>/&gt;</span><br><span class="line">    &lt;variable name=<span class="string">"list"</span> type=<span class="string">"List&amp;lt;String&gt;"</span>/&gt;</span><br><span class="line">    &lt;variable name=<span class="string">"sparse"</span> type=<span class="string">"SparseArray&amp;lt;String&gt;"</span>/&gt;</span><br><span class="line">    &lt;variable name=<span class="string">"map"</span> type=<span class="string">"Map&amp;lt;String, String&gt;"</span>/&gt;</span><br><span class="line">    &lt;variable name=<span class="string">"index"</span> type=<span class="string">"int"</span>/&gt;</span><br><span class="line">    &lt;variable name=<span class="string">"key"</span> type=<span class="string">"String"</span>/&gt;</span><br><span class="line">&lt;/data&gt;</span><br><span class="line">…</span><br><span class="line">android:text=<span class="string">"@&#123;list[index]&#125;"</span></span><br><span class="line">…</span><br><span class="line">android:text=<span class="string">"@&#123;sparse[index]&#125;"</span></span><br><span class="line">…</span><br><span class="line">android:text=<span class="string">"@&#123;map[key]&#125;"</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：像<code>List&lt;String&gt;</code>这种带泛型需要写成<code>List&amp;lt;String&gt;</code>，其它的依次类推</p><h4 id="字符串字面量key"><a href="#字符串字面量key" class="headerlink" title="字符串字面量key"></a>字符串字面量key</h4><p>下面的两种形式也是可以的，通过字面量访问值，双引号，反引号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">android:text=<span class="string">'@&#123;map["firstName"]&#125;'</span></span><br><span class="line">android:text=<span class="string">"@&#123;map[`firstName`]&#125;"</span></span><br></pre></td></tr></table></figure><h4 id="访问资源"><a href="#访问资源" class="headerlink" title="访问资源"></a>访问资源</h4><p>结合表达式来访问资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:padding=<span class="string">"@&#123;large? @dimen/largePadding : @dimen/smallPadding&#125;"</span></span><br></pre></td></tr></table></figure><p>格式化字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">android:text=<span class="string">"@&#123;@string/nameFormat(firstName, lastName)&#125;"</span></span><br><span class="line">android:text=<span class="string">"@&#123;@plurals/banana(bananaCount)&#125;"</span></span><br></pre></td></tr></table></figure><h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextView android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">    android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">    android:text=<span class="string">"@&#123;user.firstName, default=my_default&#125;"</span>/&gt;</span><br></pre></td></tr></table></figure><h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p>Data Binding允许通过表达式来处理分发的view事件，例如点击事件，需要在onclick属性上写表达式。有三种需要特殊处理</p><table><thead><tr><th>Class</th><th>Listener setter</th><th>Attribute</th></tr></thead><tbody><tr><td><code>SearchView</code></td><td><code>setOnSearchClickListener(View.OnClickListener)</code></td><td><code>android:onSearchClick</code></td></tr><tr><td><code>ZoomControls</code></td><td><code>setOnZoomInClickListener(View.OnClickListener)</code></td><td><code>android:onZoomIn</code></td></tr><tr><td><code>ZoomControls</code></td><td><code>setOnZoomOutClickListener(View.OnClickListener)</code></td><td><code>android:onZoomOut</code></td></tr></tbody></table><p>有两种方式来处理事件：</p><ul><li>方法引用：通过调用具有相同签名的方法</li><li>监听器绑定: 通过lambda方式书写对象</li></ul><h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><p>类似于书写onClick属性关联到activity的同签名方法，不过这个方法引用会在编译时处理，即如果出现签名不一致等错误，会在编译时报错。<strong>签名必须与触发事件一致</strong></p><p>声明处理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandlers</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClickFriend</span><span class="params">(View view)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用，<code>::</code> <code>.</code>两种都行，最好别用吧，因为被废弃了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"handlers"</span> <span class="attr">type</span>=<span class="string">"com.example.MyHandlers"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">type</span>=<span class="string">"com.example.User"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:text</span>=<span class="string">"@&#123;user.firstName&#125;"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:onClick</span>=<span class="string">"@&#123;handlers::onClickFriend&#125;"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="监听器绑定"><a href="#监听器绑定" class="headerlink" title="监听器绑定"></a>监听器绑定</h4><p>实际处理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Presenter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSaveClick</span><span class="params">(Task task)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>@{() -&gt; presenter.onSaveClick(task)}</code>类似lambda表示式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"task"</span> <span class="attr">type</span>=<span class="string">"com.android.example.Task"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"presenter"</span> <span class="attr">type</span>=<span class="string">"com.android.example.Presenter"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span> <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Button</span> <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span> <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:onClick</span>=<span class="string">"@&#123;() -&gt; presenter.onSaveClick(task)&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>监听器的实现是数据绑定时被创键的，和方法引用类似，<strong>但是监听器绑定的处理方法不要求签名完全一致，只需要保证返回值一致就行了</strong></p><p>当然你也可以使用view参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:onClick=<span class="string">"@&#123;(view) -&gt; presenter.onSaveClick(task)&#125;"</span></span><br></pre></td></tr></table></figure><p>也可以继续传入到处理方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Presenter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSaveClick</span><span class="params">(View view, Task task)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">android:onClick=<span class="string">"@&#123;(theView) -&gt; presenter.onSaveClick(theView, task)&#125;"</span></span><br></pre></td></tr></table></figure><p>当然某些事件不止一个参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Presenter &#123;</span><br><span class="line">    public void onCompletedChanged(Task task, boolean completed)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;CheckBox android:layout_width=<span class="string">"wrap_content"</span> android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">      android:onCheckedChanged=<span class="string">"@&#123;(cb, isChecked) -&gt; presenter.completeChanged(task, isChecked)&#125;"</span> /&gt;</span><br></pre></td></tr></table></figure><p>结合三元表达式使用默认返回值，<code>null</code>，<code>0</code>等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:onClick=<span class="string">"@&#123;(v) -&gt; v.isVisible() ? doSomething() : void&#125;"</span></span><br></pre></td></tr></table></figure><p>使用过程要保证监听器简洁，不宜过度复杂。</p><h3 id="import-和-variable，includes"><a href="#import-和-variable，includes" class="headerlink" title="import 和 variable，includes"></a>import 和 variable，includes</h3><h4 id="import"><a href="#import" class="headerlink" title="import"></a>import</h4><p>和java文件中的导包一样。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">"android.view.View"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:text</span>=<span class="string">"@&#123;user.lastName&#125;"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:visibility</span>=<span class="string">"@&#123;user.isAdult ? View.VISIBLE : View.GONE&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>使用别名，类名冲突时使用别名</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">"android.view.View"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">"com.example.real.estate.View"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">alias</span>=<span class="string">"Vista"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>反正和java中怎么导入怎么用基本一样，包括了静态方法，嗯，真香</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">"com.example.MyStringUtils"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">type</span>=<span class="string">"com.example.User"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">…</span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:text</span>=<span class="string">"@&#123;MyStringUtils.capitalize(user.lastName)&#125;"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="variable"><a href="#variable" class="headerlink" title="variable"></a>variable</h4><p>声明变量，这些变量都是会在编译时进行类型检查的。binding会为每个变量分配默认值，参考java类属性默认值。</p><p>有一个特殊的变量<code>context</code>，即<code>view.getContext</code></p><h4 id="include"><a href="#include" class="headerlink" title="include"></a>include</h4><p>传递变量到其它布局</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:bind</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">type</span>=<span class="string">"com.example.User"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">"@layout/name"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">bind:user</span>=<span class="string">"@&#123;user&#125;"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">"@layout/contact"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">bind:user</span>=<span class="string">"@&#123;user&#125;"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不支持直接的merge子节点</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:bind</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">type</span>=<span class="string">"com.example.User"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">merge</span>&gt;</span><span class="comment">&lt;!-- Doesn't work --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">"@layout/name"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">bind:user</span>=<span class="string">"@&#123;user&#125;"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">"@layout/contact"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">bind:user</span>=<span class="string">"@&#123;user&#125;"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">merge</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="使用可观察对象"><a href="#使用可观察对象" class="headerlink" title="使用可观察对象"></a>使用可观察对象</h2><p>databinding库允许数据是可观察的。在可观察性下，数据发生改变会自动更新与之绑定的UI数据。当然后续会使用自带<strong>生命周期感知的</strong><code>LiveDta</code>来替换Obervable增强功能</p><h3 id="Observable-fields"><a href="#Observable-fields" class="headerlink" title="Observable fields"></a>Observable fields</h3><p>当你不需要观察整体时，考虑使用可观察字段，有以下的选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ObservableBoolean</span><br><span class="line">ObservableByte</span><br><span class="line">ObservableChar</span><br><span class="line">ObservableShort</span><br><span class="line">ObservableInt</span><br><span class="line">ObservableLong</span><br><span class="line">ObservableFloat</span><br><span class="line">ObservableDouble</span><br><span class="line">ObservableParcelable</span><br><span class="line">ObservableField&lt;T&gt;</span><br><span class="line">ObservableArrayMap</span><br><span class="line">ObservableArrayList</span><br></pre></td></tr></table></figure><p>声明为final</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ObservableField&lt;String&gt; firstName = <span class="keyword">new</span> ObservableField&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ObservableField&lt;String&gt; lastName = <span class="keyword">new</span> ObservableField&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ObservableInt age = <span class="keyword">new</span> ObservableInt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过get，set访问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user.firstName.set(<span class="string">"Google"</span>);</span><br><span class="line"><span class="keyword">int</span> age = user.age.get();</span><br></pre></td></tr></table></figure><h3 id="Observable-objects"><a href="#Observable-objects" class="headerlink" title="Observable objects"></a>Observable objects</h3><p>整体声明为可观察对象，通过继承<code>BaseObservable</code>，通过在set方法中调用<code>notifyPropertyChanged();</code>来通知UI变化，对了get方法需要使用<code>@Bindle</code>来注解，不然无法从<code>BR</code>找到字段资源ID，这个ID是和UI关联的，通过ID定位到UI数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">BaseObservable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="meta">@Bindable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.firstName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bindable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.lastName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirstName</span><span class="params">(String firstName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">        notifyPropertyChanged(BR.firstName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastName</span><span class="params">(String lastName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">        notifyPropertyChanged(BR.lastName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生成绑定类"><a href="#生成绑定类" class="headerlink" title="生成绑定类"></a>生成绑定类</h2><p>可以定制化的生成banding类</p><h3 id="创键banding类"><a href="#创键banding类" class="headerlink" title="创键banding类"></a>创键banding类</h3><h4 id="通过inflate注入"><a href="#通过inflate注入" class="headerlink" title="通过inflate注入"></a>通过<code>inflate</code>注入</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    MyLayoutBinding binding = MyLayoutBinding.inflate(getLayoutInflater());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加到父viewgroup"><a href="#添加到父viewgroup" class="headerlink" title="添加到父viewgroup"></a>添加到父viewgroup</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyLayoutBinding binding = MyLayoutBinding.inflate(getLayoutInflater(), viewGroup, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><h4 id="绑定view"><a href="#绑定view" class="headerlink" title="绑定view"></a>绑定view</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyLayoutBinding binding = MyLayoutBinding.bind(viewRoot);</span><br></pre></td></tr></table></figure><h4 id="不知类型的情况下绑定view"><a href="#不知类型的情况下绑定view" class="headerlink" title="不知类型的情况下绑定view"></a>不知类型的情况下绑定view</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">View viewRoot = LayoutInflater.from(<span class="keyword">this</span>).inflate(layoutId, parent, attachToParent);</span><br><span class="line">ViewDataBinding binding = DataBindingUtil.bind(viewRoot);</span><br></pre></td></tr></table></figure><h4 id="在fragment，listview，recyclerview-adpter，优先使用inflate"><a href="#在fragment，listview，recyclerview-adpter，优先使用inflate" class="headerlink" title="在fragment，listview，recyclerview adpter，优先使用inflate"></a>在fragment，listview，recyclerview adpter，优先使用inflate</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ListItemBinding binding = ListItemBinding.inflate(layoutInflater, viewGroup, <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">ListItemBinding binding = DataBindingUtil.inflate(layoutInflater, R.layout.list_item, viewGroup, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><h4 id="setContentView"><a href="#setContentView" class="headerlink" title="setContentView"></a>setContentView</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ActivityMainBinding binding = DataBindingUtil.setContentView(<span class="keyword">this</span>, R.layout.activity_main);</span><br></pre></td></tr></table></figure><h3 id="通过id定位view"><a href="#通过id定位view" class="headerlink" title="通过id定位view"></a>通过id定位view</h3><p>以前没有databinding时总是需要手动<code>findViewById</code>，或者通过<code>ButterKnife</code>来辅助，现在有了DataBinding后可以直接通过<code>xxxBinding.id</code>的形式来获得view对象(不过用kotlin来写话的天然直接通过id引用对象233)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"to viewmodel activity"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/btn_to_viewmodel_activity"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>会将下划线式的命名规则转变为小驼峰式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binding.btnToViewmodelActivity.setOnclcikListener();</span><br></pre></td></tr></table></figure><h3 id="立即执行绑定"><a href="#立即执行绑定" class="headerlink" title="立即执行绑定"></a>立即执行绑定</h3><p>原本在可观察数据变化时，会在下一帧进行ui变化，如果你想强制立即执行调用 <a href="https://developer.android.google.cn/reference/androidx/databinding/ViewDataBinding.html#executePendingBindings()" target="_blank" rel="noopener"><code>executePendingBindings()</code></a></p><h3 id="动态变量"><a href="#动态变量" class="headerlink" title="动态变量"></a>动态变量</h3><p>例如在RecyclerView.Adapter中你可能不知道Banding是那个。通过以下方式通知修改数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(BindingHolder holder, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> T item = items.get(position);</span><br><span class="line">    holder.getBinding().setVariable(BR.item, item);</span><br><span class="line">    holder.getBinding().executePendingBindings();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多线程问题"><a href="#多线程问题" class="headerlink" title="多线程问题"></a>多线程问题</h3><p>在databinding中，修改数据可以在任何线程，数据在UI的上的改变会自动在本地化的UI线程进行更新。需要注意的是不能在后台线程操纵集合数据</p><h3 id="自定义binding类的名字"><a href="#自定义binding类的名字" class="headerlink" title="自定义binding类的名字"></a>自定义binding类的名字</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">data</span> <span class="attr">class</span>=<span class="string">"ContactItem"</span>&gt;</span></span><br><span class="line">    …</span><br><span class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="绑定适配器"><a href="#绑定适配器" class="headerlink" title="绑定适配器"></a>绑定适配器</h2><p>绑定适配负责通过适当的方式来调用并且设置值，比如我们在设置属性的时候实际是通过setText来完成的，设置监听器是通过setOnclickListener来完成的。databing库允许我们指定方法调用来设置值，提供绑定逻辑，指定返回类型。</p><h3 id="设置属性值"><a href="#设置属性值" class="headerlink" title="设置属性值"></a>设置属性值</h3><h4 id="自动选择方法"><a href="#自动选择方法" class="headerlink" title="自动选择方法"></a>自动选择方法</h4><p>通过名称和返回值类型来匹配对应的方法调用。比如<code>app:scrimColor=@{@color/scrim}</code>会调用<code>setScrimColor(int)</code>诸如此类，自动选择方法调用</p><h4 id="指定属性触发方法"><a href="#指定属性触发方法" class="headerlink" title="指定属性触发方法"></a>指定属性触发方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingMethods</span>(&#123;</span><br><span class="line">       <span class="meta">@BindingMethod</span>(type = <span class="string">"android.widget.ImageView"</span>,</span><br><span class="line">                      attribute = <span class="string">"android:tint"</span>,</span><br><span class="line">                      method = <span class="string">"setImageTintList"</span>),</span><br><span class="line">&#125;)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyBindingMethods</span></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingMethods</span>(</span><br><span class="line">        <span class="meta">@BindingMethod</span>(type = ImageView.class,</span><br><span class="line">                attribute = <span class="string">"app:srcCompat"</span>,</span><br><span class="line">                method = <span class="string">"setImageResource"</span>))</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyBindingMethods</span></span></span><br></pre></td></tr></table></figure><p>在这样的声明下，通过给app:srcCompat设置属性值，会触发调用setImageResource方法</p><h4 id="自定义触发方法逻辑"><a href="#自定义触发方法逻辑" class="headerlink" title="自定义触发方法逻辑"></a>自定义触发方法逻辑</h4><p>设置<code>android:paddingLeft</code>就会调用自定义的<code>setPaddingLeft</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter</span>(<span class="string">"android:paddingLeft"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setPaddingLeft</span><span class="params">(View view, <span class="keyword">int</span> padding)</span> </span>&#123;</span><br><span class="line">  view.setPadding(padding,</span><br><span class="line">                  view.getPaddingTop(),</span><br><span class="line">                  view.getPaddingRight(),</span><br><span class="line">                  view.getPaddingBottom());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样支持自定义属性，和多属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@BindingAdapter(&#123;&quot;imageUrl&quot;, &quot;error&quot;&#125;)</span><br><span class="line">public static void loadImage(ImageView view, String url, Drawable error) &#123;</span><br><span class="line">  Picasso.get().load(url).error(error).into(view);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageView</span> <span class="attr">app:imageUrl</span>=<span class="string">"@&#123;venue.imageUrl&#125;"</span> <span class="attr">app:error</span>=<span class="string">"@&#123;@drawable/venueError&#125;"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>databing 库会忽略自定义属性的命名空间，所以不写也没事</p><p>可以设置不要求所有属性有值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter</span>(value=&#123;<span class="string">"imageUrl"</span>, <span class="string">"placeholder"</span>&#125;, requireAll=<span class="keyword">false</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setImageUrl</span><span class="params">(ImageView imageView, String url, Drawable placeHolder)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">    imageView.setImageDrawable(placeholder);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    MyImageLoader.loadInto(imageView, url, placeholder);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提供新值，旧值参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter</span>(<span class="string">"android:paddingLeft"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setPaddingLeft</span><span class="params">(View view, <span class="keyword">int</span> oldPadding, <span class="keyword">int</span> newPadding)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (oldPadding != newPadding) &#123;</span><br><span class="line">      view.setPadding(newPadding,</span><br><span class="line">                      view.getPaddingTop(),</span><br><span class="line">                      view.getPaddingRight(),</span><br><span class="line">                      view.getPaddingBottom());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>甚至新旧监听器参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter</span>(<span class="string">"android:onLayoutChange"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setOnLayoutChangeListener</span><span class="params">(View view, View.OnLayoutChangeListener oldValue,</span></span></span><br><span class="line"><span class="function"><span class="params">       View.OnLayoutChangeListener newValue)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">      view.removeOnLayoutChangeListener(oldValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">      view.addOnLayoutChangeListener(newValue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用监听器绑定</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">View</span> <span class="attr">android:onLayoutChange</span>=<span class="string">"@&#123;() -&gt; handler.layoutChanged()&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>对于一个监听器中有多个监听方法的需要拆分出来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TargetApi</span>(VERSION_CODES.HONEYCOMB_MR1)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnViewDetachedFromWindow</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onViewDetachedFromWindow</span><span class="params">(View v)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@TargetApi</span>(VERSION_CODES.HONEYCOMB_MR1)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnViewAttachedToWindow</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onViewAttachedToWindow</span><span class="params">(View v)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@BindingAdapter</span>(&#123;<span class="string">"android:onViewDetachedFromWindow"</span>, <span class="string">"android:onViewAttachedToWindow"</span>&#125;, requireAll=<span class="keyword">false</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setListener</span><span class="params">(View view, OnViewDetachedFromWindow detach, OnViewAttachedToWindow attach)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (VERSION.SDK_INT &gt;= VERSION_CODES.HONEYCOMB_MR1) &#123;</span><br><span class="line">        OnAttachStateChangeListener newListener;</span><br><span class="line">        <span class="keyword">if</span> (detach == <span class="keyword">null</span> &amp;&amp; attach == <span class="keyword">null</span>) &#123;</span><br><span class="line">            newListener = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newListener = <span class="keyword">new</span> OnAttachStateChangeListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewAttachedToWindow</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (attach != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        attach.onViewAttachedToWindow(v);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewDetachedFromWindow</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (detach != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        detach.onViewDetachedFromWindow(v);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        OnAttachStateChangeListener oldListener = ListenerUtil.trackListener(view, newListener,</span><br><span class="line">                R.id.onAttachStateChangeListener);</span><br><span class="line">        <span class="keyword">if</span> (oldListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">            view.removeOnAttachStateChangeListener(oldListener);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">            view.addOnAttachStateChangeListener(newListener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象转换"><a href="#对象转换" class="headerlink" title="对象转换"></a>对象转换</h3><p>一般情况下会有自动转换，比如<code>android:text=&quot;@{String}&quot;</code>，string就会转换为<code>CharSequence</code>以供setText使用</p><p>我们也可以使用自定义对象转换比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">View</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:background</span>=<span class="string">"@&#123;isError ? @color/red : @color/white&#125;"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>我们的参数值是一个<code>int</code>，但是最后起作用的是<code>Drawable</code>，所以我们需要将<code>int</code>转换为<code>ColorDrawable</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingConversion</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ColorDrawable <span class="title">convertColorToDrawable</span><span class="params">(<span class="keyword">int</span> color)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ColorDrawable(color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就会执行转换</p><h2 id="结合架构组件"><a href="#结合架构组件" class="headerlink" title="结合架构组件"></a>结合架构组件</h2><h3 id="使用LiveData"><a href="#使用LiveData" class="headerlink" title="使用LiveData"></a>使用LiveData</h3><p>和ObservableField相似，LiveData数据也是可观察的，但是LiveData更加优秀的是<strong>感知生命周期</strong>，即在某些不应该触发通知的生命周期中是不会触发通知的。要求AS版本3.1以上，详情见之后的LiveData介绍</p><p>使用LiveData需要设定生命周期的承载者来保持LiveData作用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewModelActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Inflate view and obtain an instance of the binding class.</span></span><br><span class="line">        UserBinding binding = DataBindingUtil.setContentView(<span class="keyword">this</span>, R.layout.user);</span><br><span class="line">        <span class="comment">// 指定生命周期承载者是此activity</span></span><br><span class="line">        binding.setLifecycleOwner(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再数据类中使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScheduleViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    LiveData username;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScheduleViewModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String result = Repository.userName;</span><br><span class="line">        userName = Transformations.map(result, result -&gt; result.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用ViewModel管理UI关联数据"><a href="#使用ViewModel管理UI关联数据" class="headerlink" title="使用ViewModel管理UI关联数据"></a>使用ViewModel管理UI关联数据</h3><p>viewModel用于管控UI行为，以及存储绑定数据，在某些屏幕旋转情况下，activity会重建，而viewmodel可以一直存在，保存于UI的关联的重量级数据，同时作为逻辑沟通的桥梁，连接UI，连接Model。具体见后续的ViewModel</p><h3 id="ViewModel实现Obervable"><a href="#ViewModel实现Obervable" class="headerlink" title="ViewModel实现Obervable"></a>ViewModel实现Obervable</h3><p>在某种不需要使用LiveData进行生命周期感知的情况下，可以进行实现Observable，使得ViewModel具有被观察的特性。</p><p>首先继承ViewModel，实现Observable，添加属性监听。</p><p>重写<code>addOnPropertyChangedCallback</code> <code>removeOnPropertyChangedCallback</code>，可以参看BaseObservable的基本实现范例</p><p>这样一个ViewModel就具有观察特性了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A ViewModel that is also an Observable,</span></span><br><span class="line"><span class="comment"> * to be used with the Data Binding Library.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObservableViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> <span class="keyword">implements</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PropertyChangeRegistry callbacks = <span class="keyword">new</span> PropertyChangeRegistry();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addOnPropertyChangedCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Observable.OnPropertyChangedCallback callback)</span> </span>&#123;</span><br><span class="line">        callbacks.add(callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">removeOnPropertyChangedCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Observable.OnPropertyChangedCallback callback)</span> </span>&#123;</span><br><span class="line">        callbacks.remove(callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Notifies observers that all properties of this instance have changed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notifyChange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        callbacks.notifyCallbacks(<span class="keyword">this</span>, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Notifies observers that a specific property has changed. The getter for the</span></span><br><span class="line"><span class="comment">     * property that changes should be marked with the <span class="doctag">@Bindable</span> annotation to</span></span><br><span class="line"><span class="comment">     * generate a field in the BR class to be used as the fieldId parameter.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fieldId The generated BR id for the Bindable field.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notifyPropertyChanged</span><span class="params">(<span class="keyword">int</span> fieldId)</span> </span>&#123;</span><br><span class="line">        callbacks.notifyCallbacks(<span class="keyword">this</span>, fieldId, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>终于来到大名鼎鼎的双向绑定了。之前我们的普通操作都是修改绑定数据，触发UI变化。</p><p>单向绑定过程：<code>data set</code>-&gt; <code>data notify</code> -&gt; <code>UI get</code>-&gt;<code>UI change</code></p><p>双向绑定过程：<code>UI set</code> -&gt; <code>data set</code> -&gt; <code>data notify</code> -&gt; <code>UI get</code> -&gt; <code>UI change</code></p><p>简单来讲就是以前是通过直接修改绑定数据来影响UI值，现在双向绑定修改UI值来触发绑定数据改变。</p><p>单向绑定</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">CheckBox</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/rememberMeCheckBox"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:checked</span>=<span class="string">"@&#123;viewmodel.rememberMe&#125;"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:onCheckedChanged</span>=<span class="string">"@&#123;viewmodel.rememberMeChanged&#125;"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><p>通过reemberMeChanged来触发改变事件，继而自行书写修改绑定数据逻辑</p><p>现在双向绑定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;CheckBox</span><br><span class="line">    android:id=<span class="string">"@+id/rememberMeCheckBox"</span></span><br><span class="line">    android:checked=<span class="string">"@=&#123;viewmodel.rememberMe&#125;"</span></span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><p>使用<code>@={viewmodel.rememberMe}</code>来表示双向绑定，意思是在checkbox UI属性变化时会去调用<code>setRememberMe</code>方法，UI数据和绑定数据互相可以影响，但是需要通过一些判断来防止进入无限的循环调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginViewModel</span> <span class="keyword">extends</span> <span class="title">BaseObservable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// private Model data = ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bindable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">getRememberMe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.rememberMe;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRememberMe</span><span class="params">(Boolean value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Avoids infinite loops.</span></span><br><span class="line">        <span class="keyword">if</span> (data.rememberMe != value) &#123;</span><br><span class="line">            data.rememberMe = value;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// React to the change.</span></span><br><span class="line">            saveData();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Notify observers of a new value.</span></span><br><span class="line">            notifyPropertyChanged(BR.remember_me);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用于自定义属性"><a href="#用于自定义属性" class="headerlink" title="用于自定义属性"></a>用于自定义属性</h3><p>自定义属性也可以进行双向绑定</p><p>使用<code>@BindingAdapter</code>绑定set方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter</span>(<span class="string">"time"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setTime</span><span class="params">(MyView view, Time newValue)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Important to break potential infinite loops.</span></span><br><span class="line">    <span class="keyword">if</span> (view.time != newValue) &#123;</span><br><span class="line">        view.time = newValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>@InverseBindingAdapter</code>绑定get方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@InverseBindingAdapter</span>(<span class="string">"time"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Time <span class="title">getTime</span><span class="params">(MyView view)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> view.getTime();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置同用的监听</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter</span>(<span class="string">"app:timeAttrChanged"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setListeners</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        MyView view, <span class="keyword">final</span> InverseBindingListener attrChange)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Set a listener for click, focus, touch, etc.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h3><p>在双向绑定中的转换就会涉及到反向转换，比如原来我们是date to string，现在反向转换就是string to date了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Converter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@InverseMethod</span>(<span class="string">"stringToDate"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">dateToString</span><span class="params">(EditText view, <span class="keyword">long</span> oldValue,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">long</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Converts long to String.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">stringToDate</span><span class="params">(EditText view, String oldValue,</span></span></span><br><span class="line"><span class="function"><span class="params">            String value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Converts String to long.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>xml中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/birth_date"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"@=&#123;Converter.dateToString(viewmodel.birthDate)&#125;"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="避免无限循环"><a href="#避免无限循环" class="headerlink" title="避免无限循环"></a>避免无限循环</h3><p>在双向绑定中因为涉及两个值循环变化，需要通过比较值来，避免无限循环的调用</p><h3 id="databing-提供的双向绑定属性"><a href="#databing-提供的双向绑定属性" class="headerlink" title="databing 提供的双向绑定属性"></a>databing 提供的双向绑定属性</h3><p>这个就是说它内部实现一些双向绑定的Adapter，就是不用我们自己写，当然自定义的属性双向绑定还是得自己写咯</p><p>我就直接从官网拷啦</p><table><thead><tr><th>Class</th><th>Attribute(s)</th><th>Binding adapter</th></tr></thead><tbody><tr><td><a href="https://developer.android.google.cn/reference/android/widget/AdapterView" target="_blank" rel="noopener"><code>AdapterView</code></a></td><td><code>android:selectedItemPosition</code> <code>android:selection</code></td><td><a href="https://android.googlesource.com/platform/frameworks/data-binding/+/refs/heads/studio-master-dev/extensions/baseAdapters/src/main/java/androidx/databinding/adapters/AdapterViewBindingAdapter.java" target="_blank" rel="noopener"><code>AdapterViewBindingAdapter</code></a></td></tr><tr><td><a href="https://developer.android.google.cn/reference/android/widget/CalendarView" target="_blank" rel="noopener"><code>CalendarView</code></a></td><td><code>android:date</code></td><td><a href="https://android.googlesource.com/platform/frameworks/data-binding/+/refs/heads/studio-master-dev/extensions/baseAdapters/src/main/java/androidx/databinding/adapters/CalendarViewBindingAdapter.java" target="_blank" rel="noopener"><code>CalendarViewBindingAdapter</code></a></td></tr><tr><td><a href="https://developer.android.google.cn/reference/android/widget/CompoundButton" target="_blank" rel="noopener"><code>CompoundButton</code></a></td><td><a href="https://developer.android.google.cn/reference/android/R.attr#checked" target="_blank" rel="noopener"><code>android:checked</code></a></td><td><a href="https://android.googlesource.com/platform/frameworks/data-binding/+/refs/heads/studio-master-dev/extensions/baseAdapters/src/main/java/androidx/databinding/adapters/CompoundButtonBindingAdapter.java" target="_blank" rel="noopener"><code>CompoundButtonBindingAdapter</code></a></td></tr><tr><td><a href="https://developer.android.google.cn/reference/android/widget/DatePicker" target="_blank" rel="noopener"><code>DatePicker</code></a></td><td><code>android:year</code> <code>android:month</code> <code>android:day</code></td><td><a href="https://android.googlesource.com/platform/frameworks/data-binding/+/refs/heads/studio-master-dev/extensions/baseAdapters/src/main/java/androidx/databinding/adapters/DatePickerBindingAdapter.java" target="_blank" rel="noopener"><code>DatePickerBindingAdapter</code></a></td></tr><tr><td><a href="https://developer.android.google.cn/reference/android/widget/NumberPicker" target="_blank" rel="noopener"><code>NumberPicker</code></a></td><td><a href="https://developer.android.google.cn/reference/android/R.attr#value" target="_blank" rel="noopener"><code>android:value</code></a></td><td><a href="https://android.googlesource.com/platform/frameworks/data-binding/+/refs/heads/studio-master-dev/extensions/baseAdapters/src/main/java/androidx/databinding/adapters/NumberPickerBindingAdapter.java" target="_blank" rel="noopener"><code>NumberPickerBindingAdapter</code></a></td></tr><tr><td><a href="https://developer.android.google.cn/reference/android/widget/RadioButton" target="_blank" rel="noopener"><code>RadioButton</code></a></td><td><a href="https://developer.android.google.cn/reference/android/R.attr#checkedButton" target="_blank" rel="noopener"><code>android:checkedButton</code></a></td><td><a href="https://android.googlesource.com/platform/frameworks/data-binding/+/refs/heads/studio-master-dev/extensions/baseAdapters/src/main/java/androidx/databinding/adapters/RadioGroupBindingAdapter.java" target="_blank" rel="noopener"><code>RadioGroupBindingAdapter</code></a></td></tr><tr><td><a href="https://developer.android.google.cn/reference/android/widget/RatingBar" target="_blank" rel="noopener"><code>RatingBar</code></a></td><td><a href="https://developer.android.google.cn/reference/android/R.attr#rating" target="_blank" rel="noopener"><code>android:rating</code></a></td><td><a href="https://android.googlesource.com/platform/frameworks/data-binding/+/refs/heads/studio-master-dev/extensions/baseAdapters/src/main/java/androidx/databinding/adapters/RatingBarBindingAdapter.java" target="_blank" rel="noopener"><code>RatingBarBindingAdapter</code></a></td></tr><tr><td><a href="https://developer.android.google.cn/reference/android/widget/SeekBar" target="_blank" rel="noopener"><code>SeekBar</code></a></td><td><a href="https://developer.android.google.cn/reference/android/R.attr#progress" target="_blank" rel="noopener"><code>android:progress</code></a></td><td><a href="https://android.googlesource.com/platform/frameworks/data-binding/+/refs/heads/studio-master-dev/extensions/baseAdapters/src/main/java/androidx/databinding/adapters/SeekBarBindingAdapter.java" target="_blank" rel="noopener"><code>SeekBarBindingAdapter</code></a></td></tr><tr><td><a href="https://developer.android.google.cn/reference/android/widget/TabHost" target="_blank" rel="noopener"><code>TabHost</code></a></td><td><code>android:currentTab</code></td><td><a href="https://android.googlesource.com/platform/frameworks/data-binding/+/refs/heads/studio-master-dev/extensions/baseAdapters/src/main/java/androidx/databinding/adapters/TabHostBindingAdapter.java" target="_blank" rel="noopener"><code>TabHostBindingAdapter</code></a></td></tr><tr><td><a href="https://developer.android.google.cn/reference/android/widget/TextView" target="_blank" rel="noopener"><code>TextView</code></a></td><td><a href="https://developer.android.google.cn/reference/android/R.attr#text" target="_blank" rel="noopener"><code>android:text</code></a></td><td><a href="https://android.googlesource.com/platform/frameworks/data-binding/+/refs/heads/studio-master-dev/extensions/baseAdapters/src/main/java/androidx/databinding/adapters/TextViewBindingAdapter.java" target="_blank" rel="noopener"><code>TextViewBindingAdapter</code></a></td></tr><tr><td><a href="https://developer.android.google.cn/reference/android/widget/TimePicker" target="_blank" rel="noopener"><code>TimePicker</code></a></td><td><code>android:hour</code> <code>android:minute</code></td><td><a href="https://android.googlesource.com/platform/frameworks/data-binding/+/refs/heads/studio-master-dev/extensions/baseAdapters/src/main/java/androidx/databinding/adapters/TimePickerBindingAdapter.java" target="_blank" rel="noopener"><code>TimePickerBindingAdapter</code></a></td></tr></tbody></table><p>这些都是已经帮你写好得双向绑定属性</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>总结下来就是，可以将数据绑定到UI页面的操作。方便了书写，不用写过多的样版代码，同时也解耦了，耦合性高的都被APT自动生成了，不用我们管。反正写的时候我还是遇见了各种问题，尤其是用Kotlin写的时候，一样的代码都跑不通，kotlin还是得好好琢磨琢磨啊。这个文章基本算是简单得翻译了官方文档吧，有时间还是写个demo好了。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mvvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式归纳</title>
      <link href="/2019/07/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BD%92%E7%BA%B3/"/>
      <url>/2019/07/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BD%92%E7%BA%B3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>根据《Android源码设计模式解析与实战》总结归纳学习</p></blockquote><h2 id="面向对象的的六大原则"><a href="#面向对象的的六大原则" class="headerlink" title="面向对象的的六大原则"></a>面向对象的的六大原则</h2><h3 id="单一职责"><a href="#单一职责" class="headerlink" title="单一职责"></a>单一职责</h3><p>一个类应该是一些相关性很高的函数和数据的集合。例如根据功能进行具体划分，每个个体完成自己相应的事。</p><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>开放扩展，关闭修改。在软件生命周期迭代过程中，如果对原有代码进行了修改，很有可能引入新的错误，导致整个项目需要重构，并且需要重新测试啥的。所有要通过扩展的形式来，而不是修改。</p><h3 id="里氏代换"><a href="#里氏代换" class="headerlink" title="里氏代换"></a>里氏代换</h3><p>子类可以扩展父类功能，但不能改变原有父类的功能</p><h3 id="依赖倒置"><a href="#依赖倒置" class="headerlink" title="依赖倒置"></a>依赖倒置</h3><p>高层模块不依赖底层模块细节，应该依赖抽象。这个也就是申明使用抽象，实现使用细节。</p><h3 id="接口隔离"><a href="#接口隔离" class="headerlink" title="接口隔离"></a>接口隔离</h3><p>客户端不应当依赖它不需要的接口，类之间的依赖关系应该建立在最小的接口上，不要将过多的功能加在一个接口上。接口的设计粒度越小，系统越灵活，维护降低</p><h3 id="迪米特原则"><a href="#迪米特原则" class="headerlink" title="迪米特原则"></a>迪米特原则</h3><p>一个类应该只和自己关心的类进行通信。最少知道原则，降低类与类之间的耦合。</p><a id="more"></a><h2 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h2><p>创建对象实例化，这类模式的特点是不让用户依赖对象的创键。</p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>一个类只有一个单例，而且自动实例化并向整个系统提供。</p><p>特点：构造器私有，实例静态私有，提供get实例的静态方法</p><h4 id="饿汉单例"><a href="#饿汉单例" class="headerlink" title="饿汉单例"></a>饿汉单例</h4><p>线程安全，类加载时进行实例化，没有并发问题，但是空间换取时间，不必要提前装载的实例会导致性能问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="懒汉单例"><a href="#懒汉单例" class="headerlink" title="懒汉单例"></a>懒汉单例</h4><p>线程不安全，附带延迟加载和缓存思想</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(INSTANCE == <span class="keyword">null</span>)</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的懒汉单例可能存在线程安全问题</p><h4 id="懒汉单例-同步方法"><a href="#懒汉单例-同步方法" class="headerlink" title="懒汉单例+同步方法"></a>懒汉单例+同步方法</h4><p>线程安全，锁住整个方法导致，访问速度下降</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(INSTANCE == <span class="keyword">null</span>)</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双重校验锁单例"><a href="#双重校验锁单例" class="headerlink" title="双重校验锁单例"></a>双重校验锁单例</h4><p>只是在实例为空的情况才加锁，内部创键实例加锁，既保证了线程安全，也提升的访问速度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">                INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态单例"><a href="#静态单例" class="headerlink" title="静态单例"></a>静态单例</h4><p>线程安全，延迟加载，推荐</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="枚举单例"><a href="#枚举单例" class="headerlink" title="枚举单例"></a>枚举单例</h4><p>线程安全，简单，任何情况下都是一个实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SingletonEnum &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="容器单例"><a href="#容器单例" class="headerlink" title="容器单例"></a>容器单例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,Object&gt; objMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonManager</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerService</span><span class="params">(String key, Object instance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!objMap.containKey(key))</span><br><span class="line">            objMap.put(key,instance);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getService</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> objMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="序列化破坏单例"><a href="#序列化破坏单例" class="headerlink" title="序列化破坏单例"></a>序列化破坏单例</h4><p>以上单例在除了枚举单例，在反序列化的情况下是会生成新的实例的，如何杜绝，重写以下方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> throw ObjectStreamException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在android源码中体现"><a href="#在android源码中体现" class="headerlink" title="在android源码中体现"></a>在android源码中体现</h4><p>单例模式很常见，比如获得各种系统服务，它们都是以单例的形式注册到Manager的。</p><h3 id="Builder模式"><a href="#Builder模式" class="headerlink" title="Builder模式"></a>Builder模式</h3><p>对象的构建交给构建器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Car</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = builder.name;</span><br><span class="line">        <span class="keyword">this</span>.color = builder.color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> class <span class="title">Builder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> String color;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">name</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">color</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.color = color;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Car <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Car(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在源码中体现"><a href="#在源码中体现" class="headerlink" title="在源码中体现"></a>在源码中体现</h4><p>比如<code>AlertDialog</code>，<code>OkHttp</code>中的<code>Request</code>，<code>RequestBody</code>，都挺常见的</p><h3 id="工厂"><a href="#工厂" class="headerlink" title="工厂"></a>工厂</h3><p>用于生产对象</p><h4 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h4><p>也称作静态工厂方法模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Option</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OptionA</span> <span class="keyword">implements</span> <span class="title">Option</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acion</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OptionB</span> <span class="keyword">implements</span> <span class="title">Option</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Option <span class="title">getOption</span><span class="params">(String optionName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(optionName) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"A"</span>: <span class="keyword">return</span> <span class="keyword">new</span> OptionA();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"B"</span>: <span class="keyword">return</span> <span class="keyword">new</span> OptionB();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Option a = Factory.getOption(<span class="string">"A"</span>);</span><br><span class="line">        Option b = Factory.getOption(<span class="string">"B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以产出多个不同类型的实例，但是对于后续如果需要加生产出其它的对象，就要对代码进行修改，很明显，这是不符合开闭原则的。对维护和扩展不利</p><h4 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Option</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OptionA</span> <span class="keyword">implements</span> <span class="title">Option</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acion</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OptionB</span> <span class="keyword">implements</span> <span class="title">Option</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Option <span class="title">createOption</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OptionAFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Option <span class="title">createOption</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OptionA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OptionBFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Option <span class="title">createOption</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OptionB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IFactory factory = <span class="keyword">new</span> OptionAFactory();</span><br><span class="line">        Option a = factory.createOption();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的方式是完全符合开闭原则的，这样的话需要扩展，就直接实现需要的工厂就行了，有良好的灵活性和扩展性，但是随着代码迭代，工厂越来越多，就会在一定程度增加系统复杂度。</p><h4 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h4><p>以上两种工厂，一个灵活，一个便于扩展，抽象工厂模式就是二者折中的考虑了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AAA</span> <span class="keyword">implements</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AA</span> <span class="keyword">implements</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BBB</span> <span class="keyword">implements</span> <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BB</span> <span class="keyword">implements</span> <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">getA</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">B <span class="title">getB</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleFactory</span> <span class="keyword">implements</span> <span class="title">Facotry</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> A <span class="title">getA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AA();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> B <span class="title">getB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TripleFactory</span> <span class="title">implement</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> A <span class="title">getA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AAA();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> B <span class="title">getB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BBB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="体现"><a href="#体现" class="headerlink" title="体现"></a>体现</h4><p>这个也是挺常见的，比如BitmapFactory</p><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>通过原型实例来创键新的对象</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>类初始化需要消耗大量资源，包括数据资源和硬件资源，通过原型拷贝来避免这些消耗</li><li>通过new来产生实例需要配置繁琐的数据和访问权限</li><li>一个对象需要提供给其它对象使用，而且各个调用者都有可能改变其值，考虑使用原型拷贝对象提供调用，保护下拷贝</li></ul><h4 id="how"><a href="#how" class="headerlink" title="how"></a>how</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scratch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        WordDocument prototype = <span class="keyword">new</span> WordDocument();</span><br><span class="line">        prototype.mText = <span class="string">"hello"</span>;</span><br><span class="line">        WordDocument copy = prototype.clone();</span><br><span class="line">        System.out.println(prototype);</span><br><span class="line">        System.out.println(copy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WordDocument</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">        String mText;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">WordDocument</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> WordDocument <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                WordDocument obj = (WordDocument) <span class="keyword">super</span>.clone();</span><br><span class="line">                obj.mText = <span class="keyword">this</span>.mText;</span><br><span class="line">                <span class="keyword">return</span> obj;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h4><p>为了避免拷贝时产生的副本影响原型，尽量使用深拷贝。</p><ul><li>浅拷贝：内部对象只是复制引用</li><li>深拷贝：内部对象需要层层拷贝，而不是引用同一个对象，需要手动clone</li></ul><h2 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h2><h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><h4 id="what"><a href="#what" class="headerlink" title="what"></a>what</h4><p>每个对象可以处理同一请求，从而避免了请求的发送者和接受者之间的耦合，将这些对象构成一条链，沿着链传递请求，直到有对象处理它为止</p><h4 id="体现-1"><a href="#体现-1" class="headerlink" title="体现"></a>体现</h4><h5 id="android事件传递"><a href="#android事件传递" class="headerlink" title="android事件传递"></a>android事件传递</h5><p>这个典型的例子就是<code>android的事件传递</code>：从Activity的<code>dispatchTouchEvent</code>传递到window，DoecView，再到ViewGroup的<code>dispatchTouchEvent</code>，通过<code>onInterceptTouchEvent</code>判断是否拦截，拦截则自身处理事件，否则传递事件区域的子View，这个View有可能是ViewGroup，如同前面的步骤一样分发，拦截，分发。如果是View通过事件onTouchEvent消费，onTouchEven返回值为true代表消费，表示此次事件处理完毕，返回为false则交由父View消费处理，依次类推。</p><h5 id="有序广播"><a href="#有序广播" class="headerlink" title="有序广播"></a>有序广播</h5><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>定义：将请求封装成对象，让不同的用户使用不同的请求来把客户端参数化，对请求排队或者记录请求日志，以及支持可撤销操作。</p><h3 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h3><p>定义：给定一个语言，定义它的文法表示，并定义一个解释器，使用解释器来解释语句</p><p>体现：PMS对Manifest文件的解析</p><h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p>定义：提供一种方法顺序访问一个容器对象中的各个元素，而又不需要暴露该对象的内部表示。</p><p>体现：java中Map，List，Set都有，以及android 数据库Cursor游标对象也是迭代器的体现</p><h3 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h3><p>定义：包含一系列对象的相互作用的方式，中介者使各对象不需要显示的相互引用，从而实现耦合松散，而且可以独立的改变它们之间的交互</p><p>体现：</p><h3 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h3><p>定义：在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以后可以将该对象恢复到原先保存的状态。</p><p>体现：android中Activity的状态保存</p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>定义：定义对象间的一种一对多的依赖关系，使得当一个对象改变状态，所有依赖它的对象会的到某到通知并且做出反应。</p><p>体现：RxJava，各种响应事件，事件总线，回调，都是应用观察者模式。</p><h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><p>定义：当一个对象的内在状态发生改变时允许做出行为的变更。</p><p>体现：android系统源码中的状态机，比如蓝牙实体，会有很多状态，在不同的状态间做出不同的响应行为，以及变换状态。</p><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>定义：策略模式定义了一系列算法，并将每一个算法进行包装起来，而它们还可以相互替换。策略模式让算法独立于使用的它的客户端而独立变化。</p><p>体现：android中动画中的插值器，通过定义不同的插值器使得动画的效果发生改变。</p><h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p>定义：定义一个操作的算法的框架，而将一些步骤延迟到子类，使得子类不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><p>体现：AsyncTask的实现，子类只需要实现固定的几个方法即可完成一个异步任务。</p><h3 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h3><p>定义：封装一些作用于某些数据结构中的各元素的操作，它可以在不改变这个数据结构的前提下定义总用于这些元素的擦操作。</p><h2 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h2><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>定义：把一个类的接口变换成客户端所期待的另一种接口，从而使得原本接口不匹配而无法工作在一起的两个类共同工作。</p><p>体现：RecyclerView的Adapter，以及Retrofit的数据转换和Call转换的Adapter</p><h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><p>定义：将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</p><p>体现：android View和ViewGroup的view体系</p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>定义：为其他对象提供一种代理以控制对这个对象的访问。</p><p>体现：ActivityManagerProxy，以及Retrofit的接口动态代理</p><h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p>定义：运用共享技术可以有效的支持大量细粒度的对象，对象池，重用对象，减少内存使用</p><p>体现：Andorid消息机制中Message，其实就是一个长度50不断复用的消息对象池</p><h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><p>定义：要求子系统的外部与其内部通信必须通过一个统一的对象进行。提供统一接口进行调用</p><p>体现：</p><ul><li>Context将许多功能的具体实现是AMS，PMS等，但是外部大家只需要通过context来调用就行了。</li><li>代码开发中三级缓存，从内存，数据库，网络请求，但是用户不需要了解细节</li></ul><h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><p>定义：将抽象与实现分离，使得它们独立的进行变化</p><h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>定义：动态的给对象添加一些额外的职责，就功能来说，装饰模式比生成子类更加灵活</p><p>体现：Context 和 ContextWrapper和ContextImpl，我觉得RxJava得中层层Observable和Oberver也是经过包装得。</p><h2 id="大话设计模式阅读"><a href="#大话设计模式阅读" class="headerlink" title="大话设计模式阅读"></a>大话设计模式阅读</h2><ol><li>代码可维护、可扩展、可复用、灵活。</li><li>面向对象的编程，并不是类越多越好，类的划分是为了封装，但分类的基础是抽象，具有相同属性和功能的对象的抽象集合才是类。</li></ol><p><img src="C:%5CUsers%5Chu.jie2%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1575949287741.png" alt="1575949287741"></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android-事件分发机制</title>
      <link href="/2019/07/22/Android-%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/07/22/Android-%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>从Activity：dispatchTouchEvent，</p><p>调用Window：dispatchTouchEvent，</p><p>调用DecorView：dispatchTouchEvent</p><p>调用ViewGroup：dispatchTouchEvent</p><p>参考：<a href="https://www.jianshu.com/p/d3758eef1f72" target="_blank" rel="noopener">https://www.jianshu.com/p/d3758eef1f72</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一篇搞懂AsynsTask</title>
      <link href="/2019/07/17/Android-%E4%B8%80%E7%AF%87%E6%90%9E%E6%87%82AsynsTask/"/>
      <url>/2019/07/17/Android-%E4%B8%80%E7%AF%87%E6%90%9E%E6%87%82AsynsTask/</url>
      
        <content type="html"><![CDATA[<h2 id="what"><a href="#what" class="headerlink" title="what"></a>what</h2><p>android 使用模板模式，封装用于执行异步任务。在android中通常情况下需要实现多线程任务以及UI的更新，但是UI通常情况下只能由UI线程来更新，我们一般简单点可能会使用handler啊，runOnUI方法啊，其实本质也是使用UI主线程的handler。但是写起来很好看不方便，所以android使用handler和线程池封装了一个用于执行异步的AsyncTask。</p><h2 id="how"><a href="#how" class="headerlink" title="how"></a>how</h2><p>首先看看怎么用吧，巨简单。</p><a id="more"></a><h3 id="继承AsyncTask"><a href="#继承AsyncTask" class="headerlink" title="继承AsyncTask"></a>继承AsyncTask</h3><p>三泛型代表：</p><ul><li>Params 输入参数类型</li><li>Result 执行结果类型</li><li>Progress 进度量类型</li></ul><p>依次重写构造方法:</p><ul><li><code>doInBackground</code> 具体任务执行</li><li><code>onPreExecute</code> 任务之前，UI线程，一般用于添加执行开始提示</li><li><code>onPostExecute</code> 任务执行之后，UI线程，用于添加执行完成提示</li><li><code>onProgressUpdate</code> 进度变化回调，UI线程，用于添加进度提示</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeleteAsyncTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">ArrayList</span>&lt;<span class="title">Model</span>&gt;, <span class="title">Integer</span>, <span class="title">Boolean</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DeleteAsyncTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Boolean <span class="title">doInBackground</span><span class="params">(ArrayList&lt;Model&gt;... lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> delete(lists[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPreExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(Boolean succeed)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onProgressUpdate</span><span class="params">(Integer[] values)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="新建实例，执行"><a href="#新建实例，执行" class="headerlink" title="新建实例，执行"></a>新建实例，执行</h3><p>这个是使用默认线程池，会去排队的哦（串行执行）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> DeleteAsyncTask().execute(mSelectedList);</span><br></pre></td></tr></table></figure><p>你要觉得不爽，或者你的任务很特别是那种IO任务啊，或者计算任务啊。指定你的线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> DeleteAsyncTask().executeOnExecutor(executor,mSelectedList);</span><br></pre></td></tr></table></figure><h2 id="why"><a href="#why" class="headerlink" title="why"></a>why</h2><p>首先讲下为啥以<code>execute(paramm)</code>的方式执行AsyncTask是串行的执行的。为啥呢，因为AsyncTask内部是维持了两个线程池，<code>SERIAL_EXECUTOR</code>：用于任务排队即所有任务顺序执行的线程池。<code>THREAD_POOL_EXECUTOR</code>:用于实际执行任务的线程池，调用execute时会通过<code>SERIAL_EXECUTOR</code>来执行，而这个则是入队列，然后调用<code>THREAD_POOL_EXECUTOR</code>来实际执行任务。对了他们都是静态的。</p><h3 id="AsyncTask状态"><a href="#AsyncTask状态" class="headerlink" title="AsyncTask状态"></a>AsyncTask状态</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Status &#123;</span><br><span class="line">    PENDING,<span class="comment">//即将</span></span><br><span class="line">    RUNNING,<span class="comment">//正在执行</span></span><br><span class="line">    FINISHED,<span class="comment">//结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SERIAL-EXECUTOR线程池"><a href="#SERIAL-EXECUTOR线程池" class="headerlink" title="SERIAL_EXECUTOR线程池"></a>SERIAL_EXECUTOR线程池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ArrayDeque&lt;Runnable&gt; mTasks = <span class="keyword">new</span> ArrayDeque&lt;Runnable&gt;();</span><br><span class="line">        Runnable mActive;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable r)</span> </span>&#123;</span><br><span class="line">            mTasks.offer(<span class="keyword">new</span> Runnable() &#123;<span class="comment">//包装一层入队列</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        r.run();<span class="comment">//执行</span></span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        scheduleNext();<span class="comment">//执行下一个</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">if</span> (mActive == <span class="keyword">null</span>) &#123;</span><br><span class="line">                scheduleNext();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">scheduleNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ((mActive = mTasks.poll()) != <span class="keyword">null</span>) &#123;<span class="comment">//出队</span></span><br><span class="line">                THREAD_POOL_EXECUTOR.execute(mActive);<span class="comment">//调用实际的线程池</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="THREAD-POOL-EXECUTOR-线程池"><a href="#THREAD-POOL-EXECUTOR-线程池" class="headerlink" title="THREAD_POOL_EXECUTOR 线程池"></a>THREAD_POOL_EXECUTOR 线程池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor THREAD_POOL_EXECUTOR;</span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">       ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">               CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,</span><br><span class="line">               sPoolWorkQueue, sThreadFactory);</span><br><span class="line">       threadPoolExecutor.allowCoreThreadTimeOut(<span class="keyword">true</span>);</span><br><span class="line">       THREAD_POOL_EXECUTOR = threadPoolExecutor;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="InternalHandler"><a href="#InternalHandler" class="headerlink" title="InternalHandler"></a>InternalHandler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InternalHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(looper);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"RawUseOfParameterizedType"</span>&#125;)</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> MESSAGE_POST_RESULT:</span><br><span class="line">                    <span class="comment">// There is only one result</span></span><br><span class="line">                    result.mTask.finish(result.mData[<span class="number">0</span>]);<span class="comment">//发送结果</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> MESSAGE_POST_PROGRESS:</span><br><span class="line">                    result.mTask.onProgressUpdate(result.mData);<span class="comment">//执行进度更新回调</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="首先从构造方法看"><a href="#首先从构造方法看" class="headerlink" title="首先从构造方法看"></a>首先从构造方法看</h3><p>最终都会调用参数为Looper的构造方法，在构造方法里面进行获得UI handler，以及初始化CallAble和FutureTask</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>((Looper) <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">(@Nullable Handler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(handler != <span class="keyword">null</span> ? handler.getLooper() : <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">(@Nullable Looper callbackLooper)</span> </span>&#123;</span><br><span class="line">        mHandler = callbackLooper == <span class="keyword">null</span> || callbackLooper == Looper.getMainLooper()</span><br><span class="line">            ? getMainHandler()<span class="comment">//自定义的主线程handler，返回的静态的UI handler</span></span><br><span class="line">            : <span class="keyword">new</span> Handler(callbackLooper);<span class="comment">//handler</span></span><br><span class="line">        <span class="comment">//构建callable</span></span><br><span class="line">        mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                mTaskInvoked.set(<span class="keyword">true</span>);<span class="comment">//被调用标志</span></span><br><span class="line">                Result result = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);<span class="comment">//设置进程优先级</span></span><br><span class="line">                    <span class="comment">//noinspection unchecked</span></span><br><span class="line">                    result = doInBackground(mParams);<span class="comment">//执行任务</span></span><br><span class="line">                    Binder.flushPendingCommands();<span class="comment">//</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable tr) &#123;</span><br><span class="line">                    mCancelled.set(<span class="keyword">true</span>);<span class="comment">//设置取消标志</span></span><br><span class="line">                    <span class="keyword">throw</span> tr;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    postResult(result);<span class="comment">//发送结果，也就最终会触发OnPostExecute</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    <span class="comment">//构建FutureTask保存结果</span></span><br><span class="line">        mFuture = <span class="keyword">new</span> FutureTask&lt;Result&gt;(mWorker) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    postResultIfNotInvoked(get());<span class="comment">//发送结果</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    android.util.Log.w(LOG_TAG, e);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"An error occurred while executing doInBackground()"</span>,</span><br><span class="line">                            e.getCause());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</span><br><span class="line">                    postResultIfNotInvoked(<span class="keyword">null</span>);<span class="comment">//发送结果</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="看execute执行"><a href="#看execute执行" class="headerlink" title="看execute执行"></a>看execute执行</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">execute</span><span class="params">(Params... params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> executeOnExecutor(sDefaultExecutor, params);<span class="comment">//启用默认串行线程池</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>走向executeOnExecutor，当然我们也可以调，这个就是说让任务在传入的线程池中运行</p><p>首先判断标志位是否合格，也就是执行过的或者执行完的都不能再次执行了。回调onPreExecute，然后添加参数进入线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">executeOnExecutor</span><span class="params">(Executor exec,</span></span></span><br><span class="line"><span class="function"><span class="params">        Params... params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mStatus != Status.PENDING) &#123;<span class="comment">//Async任务执行执行前状态必须为PENDING</span></span><br><span class="line">        <span class="keyword">switch</span> (mStatus) &#123;</span><br><span class="line">            <span class="keyword">case</span> RUNNING:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span></span><br><span class="line">                        + <span class="string">" the task is already running."</span>);</span><br><span class="line">            <span class="keyword">case</span> FINISHED:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span></span><br><span class="line">                        + <span class="string">" the task has already been executed "</span></span><br><span class="line">                        + <span class="string">"(a task can be executed only once)"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mStatus = Status.RUNNING;<span class="comment">//修改状态</span></span><br><span class="line">    onPreExecute();<span class="comment">//回调执行前</span></span><br><span class="line">    mWorker.mParams = params;<span class="comment">//添加参数</span></span><br><span class="line">    exec.execute(mFuture);<span class="comment">//进入线程池</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="来到串行线程池"><a href="#来到串行线程池" class="headerlink" title="来到串行线程池"></a>来到串行线程池</h3><p>将任务入队列，顺序执行，调用实际的线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ArrayDeque&lt;Runnable&gt; mTasks = <span class="keyword">new</span> ArrayDeque&lt;Runnable&gt;();</span><br><span class="line">        Runnable mActive;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable r)</span> </span>&#123;</span><br><span class="line">            mTasks.offer(<span class="keyword">new</span> Runnable() &#123;<span class="comment">//包装一层入队列</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        r.run();<span class="comment">//执行</span></span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        scheduleNext();<span class="comment">//执行下一个</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">if</span> (mActive == <span class="keyword">null</span>) &#123;</span><br><span class="line">                scheduleNext();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">scheduleNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ((mActive = mTasks.poll()) != <span class="keyword">null</span>) &#123;<span class="comment">//出队</span></span><br><span class="line">                THREAD_POOL_EXECUTOR.execute(mActive);<span class="comment">//调用实际的线程池</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="几个回调"><a href="#几个回调" class="headerlink" title="几个回调"></a>几个回调</h3><h4 id="doInBackground"><a href="#doInBackground" class="headerlink" title="doInBackground"></a>doInBackground</h4><p>在Callable中执行的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                mTaskInvoked.set(<span class="keyword">true</span>);<span class="comment">//被调用标志</span></span><br><span class="line">                Result result = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);<span class="comment">//设置进程优先级</span></span><br><span class="line">                    <span class="comment">//noinspection unchecked</span></span><br><span class="line">                    result = doInBackground(mParams);<span class="comment">//执行任务</span></span><br><span class="line">                    Binder.flushPendingCommands();<span class="comment">//</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable tr) &#123;</span><br><span class="line">                    mCancelled.set(<span class="keyword">true</span>);<span class="comment">//设置取消标志</span></span><br><span class="line">                    <span class="keyword">throw</span> tr;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    postResult(result);<span class="comment">//发送结果，也就最终会触发OnPostExecute</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><h4 id="onPreExecute"><a href="#onPreExecute" class="headerlink" title="onPreExecute"></a>onPreExecute</h4><p>在任务进入线程池之前执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mStatus = Status.RUNNING;<span class="comment">//修改状态</span></span><br><span class="line">onPreExecute();<span class="comment">//回调执行前</span></span><br><span class="line">mWorker.mParams = params;<span class="comment">//添加参数</span></span><br><span class="line">exec.execute(mFuture);<span class="comment">//进入线程池</span></span><br></pre></td></tr></table></figure><h4 id="onPostExecute"><a href="#onPostExecute" class="headerlink" title="onPostExecute"></a>onPostExecute</h4><p>handler发送结果后finish中执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(Result result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isCancelled()) &#123;</span><br><span class="line">            onCancelled(result);<span class="comment">//触发取消</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            onPostExecute(result);<span class="comment">//结束</span></span><br><span class="line">        &#125;</span><br><span class="line">        mStatus = Status.FINISHED;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="onProgressUpdate"><a href="#onProgressUpdate" class="headerlink" title="onProgressUpdate"></a>onProgressUpdate</h4><p>在手动调用publishProgress，handler发送消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">publishProgress</span><span class="params">(Progress... values)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!isCancelled()) &#123;</span><br><span class="line">           getHandler().obtainMessage(MESSAGE_POST_PROGRESS,</span><br><span class="line">                   <span class="keyword">new</span> AsyncTaskResult&lt;Progress&gt;(<span class="keyword">this</span>, values)).sendToTarget();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">           AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</span><br><span class="line">           <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">               <span class="keyword">case</span> MESSAGE_POST_RESULT:</span><br><span class="line">                   <span class="comment">// There is only one result</span></span><br><span class="line">                   result.mTask.finish(result.mData[<span class="number">0</span>]);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> MESSAGE_POST_PROGRESS:</span><br><span class="line">                   result.mTask.onProgressUpdate(result.mData);<span class="comment">//触发</span></span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><h4 id="onCancelled"><a href="#onCancelled" class="headerlink" title="onCancelled"></a>onCancelled</h4><p>使用cancel，取消任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">        mCancelled.set(<span class="keyword">true</span>);<span class="comment">//设置判断位</span></span><br><span class="line">        <span class="keyword">return</span> mFuture.cancel(mayInterruptIfRunning);<span class="comment">//中断任务执行</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dagger2学习</title>
      <link href="/2019/07/14/Android-Dagger%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/07/14/Android-Dagger%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="What"><a href="#What" class="headerlink" title="What"></a>What</h2><p>关于<code>IOC（控制反转）</code>和<code>DI（依赖注入）</code>，<code>DI</code>只是<code>IOC</code>的实现的一种方式，另一种是<code>依赖查找</code>，详细见 <a href="[https://zh.wikipedia.org/zh-cn/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC](https://zh.wikipedia.org/zh-cn/控制反转)">控制反转维基百科</a></p><p>完全静态的依赖注入框架。依赖注入的概念真的是到哪都有，以前学Spring的就天天看它，到了android还是跑不了，现在的dagger是以半静态注入的形式，说白了，通过注解处理器分析注解，生成java代码，将对象池和需要对象的地方连接起来，其实就和自己创键差不多，我就简单总结下怎么用吧(里面的概念我也挺晕乎的，注解处理器那里我也是挺头疼的。)</p><p>官网：  <a href="https://dagger.dev/users-guide" target="_blank" rel="noopener">Dagger users-guide</a> （果然还是还是官方文档讲的好呃呃）</p><h2 id="How"><a href="#How" class="headerlink" title="How"></a>How</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">'com.google.dagger:dagger:2.20'</span></span><br><span class="line">annotationProcessor <span class="string">'com.google.dagger:dagger-compiler:2.20'</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="最简单的例子"><a href="#最简单的例子" class="headerlink" title="最简单的例子"></a>最简单的例子</h3><p>首先需求是我需要一个对象。使用<code>@Inject</code>注解构造方法表示构造器注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Apple</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写注入器，用<code>@Component</code>注解的一个接口即可，里面有一个<code>inject</code>方法，参数类型是你要注入的地方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AppleComponet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(TestActivity activity)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注入，构建项目，然后生成许多类，我们只用在意形如DaggerAppleComponet这样以Dagger开头的生成器就行了。</p><p>同样用<code>@Inject</code>注解我要注入的对象，<code>DaggerAppleComponet.builder().build().inject(this);</code>这样就完成注入了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Inject</span> Apple mApple;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        DaggerAppleComponet.builder().build().inject(<span class="keyword">this</span>);</span><br><span class="line">        Log.d(<span class="string">"TestActivity"</span>, <span class="string">"onCreate: "</span> + mApple);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在依赖注入里面是会自动解决依赖的。比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Inject</span> A(B)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">   <span class="meta">@Inject</span> B()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时A依赖B，在注入A的时候会自动取注入B。只需要二者存在注入形式就行。</p><h3 id="使用module注入"><a href="#使用module注入" class="headerlink" title="使用module注入"></a>使用module注入</h3><p>构造器注入挺简单方便，但是不是所有的对象都能够构造器注入，比如第三方类实例，你就无法添加注解，还有比如Retrofit中动态生成的接口API对象，也不能。所以<code>注入module</code>登场，在这里面用于产出对象。</p><p>使用<code>@Module</code>注解类名，就表示这是一个module，可以有构造函数传入我们需要的依赖，比如<code>Context</code>。</p><p>使用<code>@Provides</code>修饰方法，命名为：<code>providesXX</code>，就表示产出对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonModule</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CommonModule</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        mContext = context;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function">TextView <span class="title">providesTextView</span><span class="params">(Context context, Cat cat)</span></span>&#123;</span><br><span class="line">        TextView textView = <span class="keyword">new</span> TextView(context);</span><br><span class="line">        textView.setText(cat.sayHello());</span><br><span class="line">        <span class="keyword">return</span> textView;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function">Context <span class="title">providesContextContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mContext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function">Cat <span class="title">providesCat</span><span class="params">(Hello hello)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Cat(hello);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function">Hello <span class="title">providesHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样需要声明注入器</p><p>和上面不同的是需要，写入Module类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(modules = &#123;CommonModule.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloCompont</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(TestDagger2Activity activity)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDagger2Activity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = TestDagger2Activity.class.getSimpleName();</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    TextView mTextView;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        DaggerHelloCompont.builder().commonModule(<span class="keyword">new</span> CommonModule(<span class="keyword">this</span>)).build().inject(<span class="keyword">this</span>);</span><br><span class="line">        setContentView(mTextView);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这只是另一种注入方式而已。</p><h3 id="注解说明"><a href="#注解说明" class="headerlink" title="注解说明"></a>注解说明</h3><h4 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h4><p>注解接口，标注为注入器，构建后会生成前缀Dagger的类，用于注入</p><h4 id="Module"><a href="#Module" class="headerlink" title="@Module"></a>@Module</h4><p>注解类，标注为注入模型，用于生成模型注入对象</p><h4 id="Inject"><a href="#Inject" class="headerlink" title="@Inject"></a>@Inject</h4><ul><li><p>注解构造方法表示，构造器注入</p></li><li><p>注解变量，表示被注入的引用，访问限定不能为private</p></li><li><p><strong>不可以修饰接口，即使是通过Provides产出的接口类型，也只是能够通过方法依赖传递，并不能注入到标注了@Inject的引用上去</strong></p><p>因为我遇到了过这个问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//大概举例</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">//通过Retrofit生成A</span></span><br><span class="line"><span class="function">A <span class="title">providesA</span><span class="params">(Retrofit retrofit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> retrofit.create(A.class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此时我们是无法通过@Inject获得A的</span></span><br><span class="line"><span class="meta">@Inject</span> A;<span class="comment">//无效</span></span><br><span class="line"><span class="comment">//包装下</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataModel</span> </span>&#123;</span><br><span class="line">    A mA;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    DataModel(A a) &#123;</span><br><span class="line">        mA = a;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> A <span class="title">getA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时我就可以这样</span></span><br><span class="line"><span class="meta">@Inject</span> DataModel mModel;</span><br><span class="line">A a = mModel.getA();</span><br></pre></td></tr></table></figure></li></ul><h4 id="Provides"><a href="#Provides" class="headerlink" title="@Provides"></a>@Provides</h4><p>在模型中，注解方法，一般规范以provides前缀开头方法，表示产出某对象</p><h4 id="Named"><a href="#Named" class="headerlink" title="@Named"></a>@Named</h4><p>可能存在同种类型的对象，需要通过命名区分，其实@Named也是通过@Qualifier定义的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Named</span>(<span class="string">"one"</span>)</span><br><span class="line"><span class="meta">@Provides</span></span><br><span class="line"><span class="function">Hello <span class="title">providesHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Hello();<span class="comment">//产出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Named</span>(<span class="string">"tow"</span>)</span><br><span class="line"><span class="meta">@Provides</span></span><br><span class="line"><span class="function">Hello <span class="title">providesHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Hello();<span class="comment">//产出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法可以是静态的，这就意味着Module不需要实例化传入compoent</p><h4 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h4><p>修饰注解，来标注具体那个对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Qualifier</span></span><br><span class="line"><span class="meta">@interface</span> A&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Qualifier</span></span><br><span class="line"><span class="meta">@interface</span> B&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@A</span></span><br><span class="line"><span class="meta">@Provides</span></span><br><span class="line"><span class="function">Hello <span class="title">providesHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Hello();<span class="comment">//产出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@B</span></span><br><span class="line"><span class="meta">@Provides</span></span><br><span class="line"><span class="function">Hello <span class="title">providesHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Hello();<span class="comment">//产出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Scope"><a href="#Scope" class="headerlink" title="@Scope"></a>@Scope</h4><p>修饰注解，用于生成标注注入对象的作用域单例的注解</p><p>例如以下就生成了一个@PerFragment的作用域注解，在这个作用域内，@PerFragment修饰的对象为单例，即局部单例，亦或者搭配限定符使用，产出不同限定的单例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> PerFragment &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将该注解用于修饰注入器，和产出对象的地方</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PerFragment</span></span><br><span class="line"><span class="meta">@Subcomponent</span>(modules = HomeFragmentModule.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HomeFragmentComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(HomeFragment homeFragment)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeArticlesFragmentModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PerFragment</span></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function">List&lt;Article&gt; <span class="title">providesArticles</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Singleton"><a href="#Singleton" class="headerlink" title="@Singleton"></a>@Singleton</h4><p>这个注解也是官方通过@Scope实现的，直接表明单例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Singleton &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><p>默认会在调用前就将对象注入到引用，使用以下形式可以懒加载，不会立马注入对象，只有在lazy.get()时才会去获得对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inject</span></span><br><span class="line">Lazy&lt;Object&gt; object;</span><br></pre></td></tr></table></figure><h3 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h3><p>有时候许多要不断注入同一类型的对象比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inject</span> A a1;</span><br><span class="line"><span class="meta">@Inject</span> A a2;</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">List&lt;A&gt; list;</span><br><span class="line"></span><br><span class="line">list.add(a1);</span><br><span class="line">list.add(a2);</span><br></pre></td></tr></table></figure><p>像这样需要不止一个对象，这时候就需要使用Provider了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inject</span> Provider&lt;Filter&gt; filterProvider;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">brew</span><span class="params">(<span class="keyword">int</span> numberOfPots)</span> </span>&#123;</span><br><span class="line"> ...</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; numberOfPots; p++) &#123;</span><br><span class="line">     maker.addFilter(filterProvider.get()); <span class="comment">//每次都会去获得新的对象</span></span><br><span class="line">     maker.addCoffee(...);</span><br><span class="line">     maker.percolate();</span><br><span class="line">     ...</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="Componet注入器之间关系"><a href="#Componet注入器之间关系" class="headerlink" title="Componet注入器之间关系"></a>Componet注入器之间关系</h3><p>之前的简单场景都是仅限于当前注入环境，倘若我们又这个需求，比如Fragment需要用到Activity的对象，亦或者全局环境需要用到全局注入对象，这个时候前面的基础操作就不管用了。因为它只关心注入的当前环境T<code>inject(T)</code>，离开了这个环境你也就无法获得注入对象了。</p><p>所有我们就得需要以下几个概念</p><h4 id="注入器之间相互依赖"><a href="#注入器之间相互依赖" class="headerlink" title="注入器之间相互依赖"></a>注入器之间相互依赖</h4><p>依赖就是，A的工作需要B的帮忙，也就能名正言顺的获得B注入器的注入对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A(B b);</span><br></pre></td></tr></table></figure><p>在注入器我们可这样声明依赖的注入器，通过在@Componet添加依赖的注入器，可以添加很多的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PerFragment</span></span><br><span class="line"><span class="meta">@Component</span>(modules = LoginFragmentModule.class, dependencies = AppComponent.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoginFragmentComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(LoginFragment fragment)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注入过程，既然是已依赖的方式注入，就得要拿到依赖的注入器对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DaggerLoginFragmentComponent.builder()</span><br><span class="line">    .appComponent(App.getAppComponent())</span><br><span class="line">    .build()</span><br><span class="line">    .inject(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>如果你想获得依赖的对象，必须要在注入器暴露接口，才能打开一个通往注入器依赖的入口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="meta">@Component</span>(modules = AppModule.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AppComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(App app)</span></span>;</span><br><span class="line">    <span class="function">App <span class="title">getApp</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">DataModel <span class="title">getDataModel</span><span class="params">()</span></span>;<span class="comment">//暴露</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就能名正言顺的使用依赖注入器的依赖对象了。</p><h4 id="注入器继承"><a href="#注入器继承" class="headerlink" title="注入器继承"></a>注入器继承</h4><p>第二种方式，比如一个Activity有很多的Fragment，这个时候使用继承关系来获取注入器内容更好，不需要暴露依赖对象接口</p><p>看父注入器声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PerActivity</span></span><br><span class="line"><span class="meta">@Component</span>(dependencies = AppComponent.class, modules = MainActivityModule.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MainActivityComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(MainActivity mainActivity)</span></span>;</span><br><span class="line">    <span class="function">HomeFragmentComponent <span class="title">getHomeFragmentComponent</span><span class="params">(HomeFragmentModule homeFragmentModule)</span></span>;<span class="comment">//提供子注入器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子注入器声明，使用@SubComponet表明这个子注入器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PerFragment</span></span><br><span class="line"><span class="meta">@Subcomponent</span>(modules = HomeFragmentModule.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HomeFragmentComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(HomeFragment homeFragment)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">((MainActivity) mActivity)</span><br><span class="line">.getComponent()<span class="comment">//通过Activity获得父注入器</span></span><br><span class="line">    .getHomeFragmentComponent(<span class="keyword">new</span> HomeFragmentModule())<span class="comment">//通过父注入器获得子注入器并且传入Modele</span></span><br><span class="line">    .inject(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>通过继承的方式将应用对象图谱分割成不同的部分，子注入器可以依赖祖先注入器的绑定对象，反之父注入器不能依赖子注入器绑定对象，同级注入器也无法依赖。换句话说父注入器的对象图是子注入器的对象图的子对象图。</p><p>呃呃好像官方文档使用Builder另一种方式写的SubComponent</p><p>这种基于Builder写起来真麻烦啊</p><h4 id="在Component提供依赖"><a href="#在Component提供依赖" class="headerlink" title="在Component提供依赖"></a>在Component提供依赖</h4><p>这样主动暴露依赖，其实去工厂里拿</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Componet</span><br><span class="line">public interface AComponet&#123;</span><br><span class="line">Apple getApple();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Multibindings"><a href="#Multibindings" class="headerlink" title="Multibindings"></a>Multibindings</h3><p>允许将绑定对象进集合</p><h4 id="绑定进Set"><a href="#绑定进Set" class="headerlink" title="绑定进Set"></a>绑定进Set</h4><p>使用<code>@IntoSet</code>表示将绑定对象输入set</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyModuleA</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Provides</span> <span class="meta">@IntoSet</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> String <span class="title">provideOneString</span><span class="params">(DepA depA, DepB depB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"ABC"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>@ElementsIntoSet</code>表示将一个set输送进set</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyModuleB</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Provides</span> <span class="meta">@ElementsIntoSet</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> Set&lt;String&gt; <span class="title">provideSomeStrings</span><span class="params">(DepA depA, DepB depB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HashSet&lt;String&gt;(Arrays.asList(<span class="string">"DEF"</span>, <span class="string">"GHI"</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绑定好的set可以解决set的依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Inject</span> Bar(Set&lt;String&gt; strings) &#123;</span><br><span class="line">    <span class="keyword">assert</span> strings.contains(<span class="string">"ABC"</span>);</span><br><span class="line">    <span class="keyword">assert</span> strings.contains(<span class="string">"DEF"</span>);</span><br><span class="line">    <span class="keyword">assert</span> strings.contains(<span class="string">"GHI"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者这样使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(modules = &#123;MyModuleA.class, MyModuleB.class&#125;)</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyComponent</span> </span>&#123;</span><br><span class="line">  <span class="function">Set&lt;String&gt; <span class="title">strings</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span> <span class="function"><span class="keyword">void</span> <span class="title">testMyComponent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  MyComponent myComponent = DaggerMyComponent.create();</span><br><span class="line">  assertThat(myComponent.strings()).containsExactly(<span class="string">"ABC"</span>, <span class="string">"DEF"</span>, <span class="string">"GHI"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以结合 <code>Set&lt;Foo&gt;</code>以及 <code>Provider&lt;Set&lt;Foo&gt;&gt;</code> or <code>Lazy&lt;Set&lt;Foo&gt;&gt;</code>这样的形式，但是不能<code>Set&lt;Provider&lt;Foo&gt;&gt;</code></p><p>同样可以结合<code>@Qualifier</code>来限定</p><h4 id="绑定进Map"><a href="#绑定进Map" class="headerlink" title="绑定进Map"></a>绑定进Map</h4><p>还可以绑定进map，好吧本来我想看到上面就写的。下面其实就是看到官方文档上的23333</p><h5 id="普通使用"><a href="#普通使用" class="headerlink" title="普通使用"></a>普通使用</h5><p>使用<code>@IntoMap</code>注解进入map的对象，使用<code>@StringKey</code>表示String类型的key，使用<code>@ClassKey</code>表示Class类型的key</p><p>之后我们就可获得<code>Map&lt;String, Long&gt;</code>的Map</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyModule</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Provides</span> <span class="meta">@IntoMap</span></span><br><span class="line">  <span class="meta">@StringKey</span>(<span class="string">"foo"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Long <span class="title">provideFooValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100L</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Provides</span> <span class="meta">@IntoMap</span></span><br><span class="line">  <span class="meta">@ClassKey</span>(Thing.class)</span><br><span class="line">  <span class="function"><span class="keyword">static</span> String <span class="title">provideThingValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"value for Thing"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(modules = MyModule.class)</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyComponent</span> </span>&#123;</span><br><span class="line">  <span class="function">Map&lt;String, Long&gt; <span class="title">longsByString</span><span class="params">()</span></span>;</span><br><span class="line">  Map&lt;Class&lt;?&gt;, String&gt; stringsByClass();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span> <span class="function"><span class="keyword">void</span> <span class="title">testMyComponent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  MyComponent myComponent = DaggerMyComponent.create();</span><br><span class="line">  assertThat(myComponent.longsByString().get(<span class="string">"foo"</span>)).isEqualTo(<span class="number">100L</span>);</span><br><span class="line">  assertThat(myComponent.stringsByClass().get(Thing.class))</span><br><span class="line">      .isEqualTo(<span class="string">"value for Thing"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="枚举和带泛型的KEY"><a href="#枚举和带泛型的KEY" class="headerlink" title="枚举和带泛型的KEY"></a>枚举和带泛型的KEY</h5><p>通过<code>@MapKey</code>来自定以枚举key，以及符合泛型通配的key</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> MyEnum &#123;</span><br><span class="line">  ABC, DEF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MapKey</span></span><br><span class="line"><span class="meta">@interface</span> MyEnumKey &#123;</span><br><span class="line">  <span class="function">MyEnum <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MapKey</span></span><br><span class="line"><span class="meta">@interface</span> MyNumberClassKey &#123;</span><br><span class="line">  Class&lt;? extends Number&gt; value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyModule</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Provides</span> <span class="meta">@IntoMap</span></span><br><span class="line">  <span class="meta">@MyEnumKey</span>(MyEnum.ABC)</span><br><span class="line">  <span class="function"><span class="keyword">static</span> String <span class="title">provideABCValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"value for ABC"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Provides</span> <span class="meta">@IntoMap</span></span><br><span class="line">  <span class="meta">@MyNumberClassKey</span>(BigDecimal.class)</span><br><span class="line">  <span class="function"><span class="keyword">static</span> String <span class="title">provideBigDecimalValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"value for BigDecimal"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(modules = MyModule.class)</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyComponent</span> </span>&#123;</span><br><span class="line">  <span class="function">Map&lt;MyEnum, String&gt; <span class="title">myEnumStringMap</span><span class="params">()</span></span>;</span><br><span class="line">  Map&lt;Class&lt;? extends Number&gt;, String&gt; stringsByNumberClass();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span> <span class="function"><span class="keyword">void</span> <span class="title">testMyComponent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  MyComponent myComponent = DaggerMyComponent.create();</span><br><span class="line">  assertThat(myComponent.myEnumStringMap().get(MyEnum.ABC)).isEqualTo(<span class="string">"value for ABC"</span>);</span><br><span class="line">  assertThat(myComponent.stringsByNumberClass.get(BigDecimal.class))</span><br><span class="line">      .isEqualTo(<span class="string">"value for BigDecimal"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="更加复杂的KEY"><a href="#更加复杂的KEY" class="headerlink" title="更加复杂的KEY"></a>更加复杂的KEY</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MapKey</span>(unwrapValue = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@interface</span> MyKey &#123;</span><br><span class="line">  <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">  Class&lt;?&gt; implementingClass();</span><br><span class="line">  <span class="keyword">int</span>[] thresholds();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyModule</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Provides</span> <span class="meta">@IntoMap</span></span><br><span class="line">  <span class="meta">@MyKey</span>(name = <span class="string">"abc"</span>, implementingClass = Abc.class, thresholds = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>&#125;)</span><br><span class="line">  <span class="function"><span class="keyword">static</span> String <span class="title">provideAbc1510Value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"foo"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(modules = MyModule.class)</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyComponent</span> </span>&#123;</span><br><span class="line">  <span class="function">Map&lt;MyKey, String&gt; <span class="title">myKeyStringMap</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于复杂的Key来说，编译时是无法具体确认的，考虑使用<code>Set&lt;Map.KeyEntry&gt;</code>来完成同样可以达到map效果</p><p>上面的只是讲了个大概目前用到，其实还有关于子注入器更多的知识和Producers的内容，以后再补充吧。</p><h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><p>参考</p><ul><li><a href="https://www.jianshu.com/p/26d9f99ea3bb" target="_blank" rel="noopener">https://www.jianshu.com/p/26d9f99ea3bb</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Retrofit学习</title>
      <link href="/2019/07/14/Android-Retrofit%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/07/14/Android-Retrofit%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="what"><a href="#what" class="headerlink" title="what"></a>what</h2><p>网络请求框架，底层是使用OkHttp请求实现的。通过动态代理来创键创键解耦的请求，具体的请求交给OkHttp。同时支持Rxjava，以及各种格式的转换。官方文档地址：<a href="https://square.github.io/retrofit/" target="_blank" rel="noopener">Retrofit</a></p><h2 id="how"><a href="#how" class="headerlink" title="how"></a>how</h2><h3 id="定义请求API"><a href="#定义请求API" class="headerlink" title="定义请求API"></a>定义请求API</h3><p>创键接口，以及请求定义方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> okhttp3.ResponseBody;</span><br><span class="line"><span class="keyword">import</span> retrofit2.Call;</span><br><span class="line"><span class="keyword">import</span> retrofit2.http.GET;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestApi</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"article/list/0/json"</span>)</span><br><span class="line">    <span class="function">Call&lt;ResponseBody&gt; <span class="title">getArticle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder().baseUrl(url).build();</span><br><span class="line">TestApi testApi = retrofit.create(TestApi.class);</span><br><span class="line">Response&lt;ResponseBody&gt; response = testApi.getArticle().execute();</span><br><span class="line">System.out.println(response.code());</span><br><span class="line">System.out.println(response.isSuccessful());</span><br><span class="line">System.out.println(response.body().string());</span><br><span class="line"></span><br><span class="line"><span class="comment">//ouput</span></span><br><span class="line"><span class="number">200</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line">数据</span><br></pre></td></tr></table></figure><h3 id="请求方法声明"><a href="#请求方法声明" class="headerlink" title="请求方法声明"></a>请求方法声明</h3><h4 id="GET"><a href="#GET" class="headerlink" title="@GET"></a>@GET</h4><p>get请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GET</span>(<span class="string">"article/list/0/json"</span>)</span><br><span class="line"><span class="function">Call&lt;ResponseBody&gt; <span class="title">getArticle</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="POST"><a href="#POST" class="headerlink" title="@POST"></a>@POST</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@POST</span>(<span class="string">"login"</span>)</span><br><span class="line"><span class="function">Call&lt;ResponseBody&gt; <span class="title">login</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="其它的请求方式"><a href="#其它的请求方式" class="headerlink" title="其它的请求方式"></a>其它的请求方式</h4><p> <code>PUT</code>, <code>DELETE</code>, and <code>HEAD</code></p><h3 id="Url构建"><a href="#Url构建" class="headerlink" title="Url构建"></a>Url构建</h3><h4 id="Path"><a href="#Path" class="headerlink" title="@Path"></a>@Path</h4><p>当我们需要对路径进行动态参数，比如`/page/1/json，这种带参路径，好像和springMVC的挺像，这样就会替换了</p><p><strong>如果路径种出现了多个参数，映射形参一定要按照顺序写，不然会出问题</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GET</span>(<span class="string">"article/list/&#123;pageNum&#125;/json"</span>)</span><br><span class="line"><span class="function">Call&lt;ResponseBody&gt; <span class="title">getArticle</span><span class="params">(@Path(<span class="string">"pageNum"</span>)</span> <span class="keyword">int</span> pageNum)</span>;</span><br><span class="line"><span class="comment">//article/list/0/json</span></span><br></pre></td></tr></table></figure><h4 id="Query"><a href="#Query" class="headerlink" title="@Query"></a>@Query</h4><p>url查询参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GET</span>(<span class="string">"article/list/0/json"</span>)</span><br><span class="line">Observable&lt;BaseResponse&lt;Articles&gt;&gt; getArticlesByCid(<span class="meta">@Query</span>(<span class="string">"cid"</span>) <span class="keyword">int</span> cid);</span><br><span class="line"></span><br><span class="line"><span class="comment">//article/list/0/json?cid=1</span></span><br></pre></td></tr></table></figure><p><strong>@Path和@Query共同出现时，映射形参一定要先path再query的写，不然真的会出问题呃呃</strong></p><h4 id="QueryMap"><a href="#QueryMap" class="headerlink" title="@QueryMap"></a>@QueryMap</h4><p>这个和@Query类似，传入map表示查询参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GET</span>(<span class="string">"group/&#123;id&#125;/users"</span>)</span><br><span class="line">Call&lt;List&lt;User&gt;&gt; groupList(<span class="meta">@Path</span>(<span class="string">"id"</span>) <span class="keyword">int</span> groupId, <span class="meta">@QueryMap</span> Map&lt;String, String&gt; options);</span><br></pre></td></tr></table></figure><h3 id="请求体构建"><a href="#请求体构建" class="headerlink" title="请求体构建"></a>请求体构建</h3><h4 id="Field和-FormUrlEncoded"><a href="#Field和-FormUrlEncoded" class="headerlink" title="@Field和@FormUrlEncoded"></a>@Field和@FormUrlEncoded</h4><p>post提交表单得这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@POST</span>(<span class="string">"user/login"</span>)</span><br><span class="line"><span class="meta">@FormUrlEncoded</span></span><br><span class="line">Observable&lt;BaseResponse&lt;Login&gt;&gt; login(</span><br><span class="line">    <span class="meta">@Field</span>(<span class="string">"username"</span>) String userName,</span><br><span class="line">    <span class="meta">@Field</span>(<span class="string">"password"</span>) String password</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><h4 id="Body"><a href="#Body" class="headerlink" title="@Body"></a>@Body</h4><p>标注请求体</p><p>自定义RequestBody，参看OkHttp，这里不需要FormUrlEncoded</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@POST</span>(<span class="string">"xxxxxxx"</span>)   </span><br><span class="line"><span class="function">Call&lt;Object&gt; <span class="title">login</span><span class="params">( @Body RequestBody body)</span></span>;</span><br></pre></td></tr></table></figure><p>如果没有加入转化器的话就只能修饰RequestBody</p><p>请求体为json对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@POST</span>(<span class="string">"xxxxxxx"</span>)   </span><br><span class="line"><span class="function">Call&lt;Object&gt; <span class="title">login</span><span class="params">( @Body JSONObject parmas )</span></span>;</span><br></pre></td></tr></table></figure><h4 id="Multipart-和-Part"><a href="#Multipart-和-Part" class="headerlink" title="@Multipart 和 @Part"></a>@Multipart 和 @Part</h4><p>其实也是完全对应OkHttp的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Multipart</span></span><br><span class="line"><span class="meta">@PUT</span>(<span class="string">"user/photo"</span>)</span><br><span class="line"><span class="function">Call&lt;User&gt; <span class="title">updateUser</span><span class="params">(@Part(<span class="string">"photo"</span>)</span> RequestBody photo, @<span class="title">Part</span><span class="params">(<span class="string">"description"</span>)</span> RequestBody description)</span>;</span><br></pre></td></tr></table></figure><h3 id="请求头构建"><a href="#请求头构建" class="headerlink" title="请求头构建"></a>请求头构建</h3><h4 id="Headers-和-Headers-HeaderMap"><a href="#Headers-和-Headers-HeaderMap" class="headerlink" title="@Headers 和 @Headers @HeaderMap"></a>@Headers 和 @Headers @HeaderMap</h4><p>添加单个Header头</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Headers</span>(<span class="string">"Cache-Control: max-age=640000"</span>)</span><br><span class="line"><span class="meta">@GET</span>(<span class="string">"widget/list"</span>)</span><br><span class="line">Call&lt;List&lt;Widget&gt;&gt; widgetList();</span><br></pre></td></tr></table></figure><p>添加多个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Headers</span>(&#123;</span><br><span class="line">    <span class="string">"Accept: application/vnd.github.v3.full+json"</span>,</span><br><span class="line">    <span class="string">"User-Agent: Retrofit-Sample-App"</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="meta">@GET</span>(<span class="string">"users/&#123;username&#125;"</span>)</span><br><span class="line"><span class="function">Call&lt;User&gt; <span class="title">getUser</span><span class="params">(@Path(<span class="string">"username"</span>)</span> String username)</span>;</span><br></pre></td></tr></table></figure><p>动态赋值Header</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GET</span>(<span class="string">"user"</span>)</span><br><span class="line"><span class="function">Call&lt;User&gt; <span class="title">getUser</span><span class="params">(@Header(<span class="string">"Authorization"</span>)</span> String authorization)</span></span><br></pre></td></tr></table></figure><p>动态添加多个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GET</span>(<span class="string">"user"</span>)</span><br><span class="line"><span class="function">Call&lt;User&gt; <span class="title">getUser</span><span class="params">(@HeaderMap Map&lt;String, String&gt; headers)</span></span></span><br></pre></td></tr></table></figure><p>基本上一一对应着OkHttp，真好用啊</p><h3 id="转换器"><a href="#转换器" class="headerlink" title="转换器"></a>转换器</h3><p>默认Retrofit是响应构建是发出<code>RequestBody</code>和响应<code>ResponseBody</code>，如果需要进一步对响应进行转换处理就需要用到转换器了。</p><p>大概有这么几种把：（官网拷的）</p><ul><li><a href="https://github.com/google/gson" target="_blank" rel="noopener">Gson</a>: <code>com.squareup.retrofit2:converter-gson</code></li><li><a href="http://wiki.fasterxml.com/JacksonHome" target="_blank" rel="noopener">Jackson</a>: <code>com.squareup.retrofit2:converter-jackson</code></li><li><a href="https://github.com/square/moshi/" target="_blank" rel="noopener">Moshi</a>: <code>com.squareup.retrofit2:converter-moshi</code></li><li><a href="https://developers.google.com/protocol-buffers/" target="_blank" rel="noopener">Protobuf</a>: <code>com.squareup.retrofit2:converter-protobuf</code></li><li><a href="https://github.com/square/wire" target="_blank" rel="noopener">Wire</a>: <code>com.squareup.retrofit2:converter-wire</code></li><li><a href="http://simple.sourceforge.net/" target="_blank" rel="noopener">Simple XML</a>: <code>com.squareup.retrofit2:converter-simplexml</code></li><li>Scalars (primitives, boxed, and String): <code>com.squareup.retrofit2:converter-scalars</code></li></ul><h4 id="Gson"><a href="#Gson" class="headerlink" title="Gson"></a>Gson</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">    .baseUrl(<span class="string">"https://api.github.com"</span>)</span><br><span class="line">    .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">GitHubService service = retrofit.create(GitHubService.class);</span><br></pre></td></tr></table></figure><h3 id="call适配器"><a href="#call适配器" class="headerlink" title="call适配器"></a>call适配器</h3><h4 id="联动Rxjava"><a href="#联动Rxjava" class="headerlink" title="联动Rxjava"></a>联动Rxjava</h4><p>导入依赖</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">'com.squareup.retrofit2:converter-gson:2.5.0'</span></span><br><span class="line">implementation <span class="string">'com.squareup.retrofit2:adapter-rxjava2:2.5.0'</span></span><br></pre></td></tr></table></figure><p>添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Provides</span></span><br><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="function">Retrofit <span class="title">provideRetrofit</span><span class="params">(OkHttpClient client)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">        .baseUrl(Constant.BASE_URL)</span><br><span class="line">        .client(client)</span><br><span class="line">        .addConverterFactory(GsonConverterFactory.create())<span class="comment">//Gson</span></span><br><span class="line">        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())<span class="comment">//Rxjava</span></span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Gson和Rxajva结合后，接着我们请求API就可以这样写了</p><p>定义和响应对应的实体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseResponse</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> errorCode;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="keyword">private</span> String errorMsg;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getErrorCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> errorCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setErrorCode</span><span class="params">(<span class="keyword">int</span> errorCode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.errorCode = errorCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getErrorMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setErrorMsg</span><span class="params">(String errorMsg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.errorMsg = errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"BaseResponse&#123;"</span> + <span class="string">"errorCode="</span> + errorCode + <span class="string">", data="</span> + data + <span class="string">", errorMsg='"</span> + errorMsg + <span class="string">'\''</span> + <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HomeApis</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"article/list/&#123;pageNum&#125;/json"</span>)</span><br><span class="line">    Observable&lt;BaseResponse&lt;Articles&gt;&gt; getArticles(<span class="meta">@Path</span>(<span class="string">"pageNum"</span>) <span class="keyword">int</span> pageNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送请求处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">addRxSubscribe( mModel.getArticles(pageNum)</span><br><span class="line">               .compose(RxUtil.rxSchedulerhelper())</span><br><span class="line">               .compose(RxUtil.handleResult())</span><br><span class="line">               .subscribeWith(<span class="keyword">new</span> BaseObserver&lt;Articles&gt;(getView()) &#123;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Articles articles)</span> </span>&#123;</span><br><span class="line">                       <span class="keyword">super</span>.onNext(articles);</span><br><span class="line">                       getView().showArticles(articles.getDatas());</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;));</span><br></pre></td></tr></table></figure><p>顺带着我们可以将线程变换，以及初步的响应处理进行复用，使用Rxjava进行流处理就行，甚至我们可以再重写一个Observer等等(我也是看别人代码这样学的写的哈哈)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RxUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ObservableTransformer&lt;T, T&gt; <span class="title">rxSchedulerhelper</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> observable -&gt; observable.subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ObservableTransformer&lt;BaseResponse&lt;T&gt;,T&gt; handleResult() &#123;</span><br><span class="line">        <span class="keyword">return</span> upstream -&gt;</span><br><span class="line">            upstream.flatMap(baseResponse -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (baseResponse.getErrorCode() == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> createObservable(baseResponse.getData());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> Observable.error(<span class="keyword">new</span> ApiException(baseResponse.getErrorCode(), baseResponse.getErrorMsg()));</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">createObservable</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Observable.create(emitter -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                emitter.onNext(data);</span><br><span class="line">                emitter.onComplete();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                emitter.onError(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="why"><a href="#why" class="headerlink" title="why"></a>why</h2><p>这个大概的原理就是通过动态代理取生成api，读取注解，组装request，构建成真正的OkHttp的Call，继而调用。</p><p>创键API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">    .baseUrl(<span class="string">"https://api.github.com"</span>)</span><br><span class="line">    .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">    .build();</span><br><span class="line">GitHubService service = retrofit.create(GitHubService.class);</span><br></pre></td></tr></table></figure><p>上面的Builder模式就先不看了，直接从create开始</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class="line">  Utils.validateServiceInterface(service);<span class="comment">//校验是否是接口</span></span><br><span class="line">  <span class="keyword">if</span> (validateEagerly) &#123;</span><br><span class="line">    eagerlyValidateMethods(service);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//动态代理</span></span><br><span class="line">  <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">      <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Object[] emptyArgs = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">          <span class="comment">// If the method is a method from Object then defer to normal invocation.</span></span><br><span class="line">          <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;<span class="comment">//肯定不等</span></span><br><span class="line">            <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (platform.isDefaultMethod(method)) &#123;<span class="comment">//默认就返回fasle</span></span><br><span class="line">            <span class="keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> loadServiceMethod(method).invoke(args != <span class="keyword">null</span> ? args : emptyArgs);<span class="comment">//真正调用这里</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态代理返回的对象，实际调用的调用是根据具体的methdo去构建的ServiceMethod.invoke方法。</p><p>先看下<code>loadServiceMethod(method)</code>吧，首先去map查询，没查询到就解析构建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ServiceMethod&lt;?&gt; loadServiceMethod(Method method) &#123;</span><br><span class="line">  ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);<span class="comment">//从缓存map拿去</span></span><br><span class="line">  <span class="keyword">if</span> (result != <span class="keyword">null</span>) <span class="keyword">return</span> result;<span class="comment">//拿到返回</span></span><br><span class="line">  <span class="keyword">synchronized</span> (serviceMethodCache) &#123;</span><br><span class="line">    result = serviceMethodCache.get(method);<span class="comment">//继续拿</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">      result = ServiceMethod.parseAnnotations(<span class="keyword">this</span>, method);<span class="comment">//解析注解构建</span></span><br><span class="line">      serviceMethodCache.put(method, result);<span class="comment">//入缓存map</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;<span class="comment">//返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着到<code>ServiceMethod#parseAnnotations</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">ServiceMethod&lt;T&gt; <span class="title">parseAnnotations</span><span class="params">(Retrofit retrofit, Method method)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//解析注解并获得Request工厂</span></span><br><span class="line">    RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);</span><br><span class="line">    Type returnType = method.getGenericReturnType();</span><br><span class="line">    <span class="keyword">if</span> (Utils.hasUnresolvableType(returnType)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> methodError(method,</span><br><span class="line">          <span class="string">"Method return type must not include a type variable or wildcard: %s"</span>, returnType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (returnType == <span class="keyword">void</span>.class) &#123;</span><br><span class="line">      <span class="keyword">throw</span> methodError(method, <span class="string">"Service methods cannot return void."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>接着走向RequestFactory#parseAnnotations去解析注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> RequestFactory <span class="title">parseAnnotations</span><span class="params">(Retrofit retrofit, Method method)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Builder(retrofit, method).build();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>直接看build方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RequestFactory <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (Annotation annotation : methodAnnotations) &#123;</span><br><span class="line">    parseMethodAnnotation(annotation);<span class="comment">//遍历每个注解，解析</span></span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">//。。。省略</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RequestFactory(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>parseMethodAnnotation</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseMethodAnnotation</span><span class="params">(Annotation annotation)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> DELETE) &#123;</span><br><span class="line">     parseHttpMethodAndPath(<span class="string">"DELETE"</span>, ((DELETE) annotation).value(), <span class="keyword">false</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> GET) &#123;</span><br><span class="line">     parseHttpMethodAndPath(<span class="string">"GET"</span>, ((GET) annotation).value(), <span class="keyword">false</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> HEAD) &#123;</span><br><span class="line">     parseHttpMethodAndPath(<span class="string">"HEAD"</span>, ((HEAD) annotation).value(), <span class="keyword">false</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> PATCH) &#123;</span><br><span class="line">     parseHttpMethodAndPath(<span class="string">"PATCH"</span>, ((PATCH) annotation).value(), <span class="keyword">true</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> POST) &#123;</span><br><span class="line">     parseHttpMethodAndPath(<span class="string">"POST"</span>, ((POST) annotation).value(), <span class="keyword">true</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> PUT) &#123;</span><br><span class="line">     parseHttpMethodAndPath(<span class="string">"PUT"</span>, ((PUT) annotation).value(), <span class="keyword">true</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> OPTIONS) &#123;</span><br><span class="line">     parseHttpMethodAndPath(<span class="string">"OPTIONS"</span>, ((OPTIONS) annotation).value(), <span class="keyword">false</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> HTTP) &#123;</span><br><span class="line">     HTTP http = (HTTP) annotation;</span><br><span class="line">     parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> retrofit2.http.Headers) &#123;</span><br><span class="line">     String[] headersToParse = ((retrofit2.http.Headers) annotation).value();</span><br><span class="line">     <span class="keyword">if</span> (headersToParse.length == <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">throw</span> methodError(method, <span class="string">"@Headers annotation is empty."</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     headers = parseHeaders(headersToParse);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> Multipart) &#123;</span><br><span class="line">     <span class="keyword">if</span> (isFormEncoded) &#123;</span><br><span class="line">       <span class="keyword">throw</span> methodError(method, <span class="string">"Only one encoding annotation is allowed."</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     isMultipart = <span class="keyword">true</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> FormUrlEncoded) &#123;</span><br><span class="line">     <span class="keyword">if</span> (isMultipart) &#123;</span><br><span class="line">       <span class="keyword">throw</span> methodError(method, <span class="string">"Only one encoding annotation is allowed."</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     isFormEncoded = <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在这里就很明显，根据不同的注解进行解析。反正都是去获得注解的值啊生成，最终在invoke组建真正的call尽调用。</p><p>后面都是直接装配之前解析的东西了</p><p>最后看看<code>HttpServiceMethod#invoke</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function">ReturnT <span class="title">invoke</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> callAdapter.adapt(</span><br><span class="line">        <span class="keyword">new</span> OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里的话就会去返回<code>OkHttpCall</code>里面调用产生的原生的<code>OkHttp</code>的<code>Call</code>，外面包裹着<code>callAdapter</code>，这里是用于转换Call的，即又进行了一次适配，不过这次的对象是call，这个为啥要适配呢，默认的话我们返回的是<code>Call&lt;&gt;</code>这种样子的，但是我们可以给定Adapteri进行对Call进一步处理，比如RxJava适配器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Retrofit <span class="title">provideRetrofit</span><span class="params">(OkHttpClient client)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">                .baseUrl(Constant.BASE_URL)</span><br><span class="line">                .client(client)</span><br><span class="line">                .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">                .addCallAdapterFactory(RxJava2CallAdapterFactory.create())<span class="comment">//这个</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后我们就能产生<code>Observale&lt;&gt;</code>的东西了。</p><p>继续看OkHttpCall是个啥东西。它实现了Retrofi的Call，里面包裹着真正的OkHttp的Call。所以形式很明了了。</p><p>通过调Retorfit的Call的execute或者enqueue，去组建真正的Call然后调用到OkHttp了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response&lt;T&gt; <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    okhttp3.Call call;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already executed."</span>);</span><br><span class="line">      executed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (creationFailure != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (creationFailure <span class="keyword">instanceof</span> IOException) &#123;</span><br><span class="line">          <span class="keyword">throw</span> (IOException) creationFailure;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (creationFailure <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">          <span class="keyword">throw</span> (RuntimeException) creationFailure;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> (Error) creationFailure;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      call = rawCall;</span><br><span class="line">      <span class="keyword">if</span> (call == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          call = rawCall = createRawCall();<span class="comment">//组建真正的OkHttp的Call</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | RuntimeException | Error e) &#123;</span><br><span class="line">          throwIfFatal(e); <span class="comment">//  Do not assign a fatal error to creationFailure.</span></span><br><span class="line">          creationFailure = e;</span><br><span class="line">          <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (canceled) &#123;</span><br><span class="line">      call.cancel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> parseResponse(call.execute());<span class="comment">//调用</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>原理呢就大概是这样。适配器和转换器也很明了</p><p>Gson相应体转换器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GsonResponseBodyConverter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">ResponseBody</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Gson gson;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> TypeAdapter&lt;T&gt; adapter;</span><br><span class="line"></span><br><span class="line">  GsonResponseBodyConverter(Gson gson, TypeAdapter&lt;T&gt; adapter) &#123;</span><br><span class="line">    <span class="keyword">this</span>.gson = gson;</span><br><span class="line">    <span class="keyword">this</span>.adapter = adapter;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> T <span class="title">convert</span><span class="params">(ResponseBody value)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    JsonReader jsonReader = gson.newJsonReader(value.charStream());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      T result = adapter.read(jsonReader);</span><br><span class="line">      <span class="keyword">if</span> (jsonReader.peek() != JsonToken.END_DOCUMENT) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> JsonIOException(<span class="string">"JSON document was not fully consumed."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      value.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RxJava Call适配器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RxJava2CallAdapter</span>&lt;<span class="title">R</span>&gt; <span class="keyword">implements</span> <span class="title">CallAdapter</span>&lt;<span class="title">R</span>, <span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Type responseType;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> Scheduler scheduler;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isAsync;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isResult;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isBody;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isFlowable;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isSingle;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isMaybe;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isCompletable;</span><br><span class="line"></span><br><span class="line">  RxJava2CallAdapter(Type responseType, <span class="meta">@Nullable</span> Scheduler scheduler, <span class="keyword">boolean</span> isAsync,</span><br><span class="line">      <span class="keyword">boolean</span> isResult, <span class="keyword">boolean</span> isBody, <span class="keyword">boolean</span> isFlowable, <span class="keyword">boolean</span> isSingle, <span class="keyword">boolean</span> isMaybe,</span><br><span class="line">      <span class="keyword">boolean</span> isCompletable) &#123;</span><br><span class="line">    <span class="keyword">this</span>.responseType = responseType;</span><br><span class="line">    <span class="keyword">this</span>.scheduler = scheduler;</span><br><span class="line">    <span class="keyword">this</span>.isAsync = isAsync;</span><br><span class="line">    <span class="keyword">this</span>.isResult = isResult;</span><br><span class="line">    <span class="keyword">this</span>.isBody = isBody;</span><br><span class="line">    <span class="keyword">this</span>.isFlowable = isFlowable;</span><br><span class="line">    <span class="keyword">this</span>.isSingle = isSingle;</span><br><span class="line">    <span class="keyword">this</span>.isMaybe = isMaybe;</span><br><span class="line">    <span class="keyword">this</span>.isCompletable = isCompletable;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Type <span class="title">responseType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> responseType;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Object <span class="title">adapt</span><span class="params">(Call&lt;R&gt; call)</span> </span>&#123;</span><br><span class="line">    Observable&lt;Response&lt;R&gt;&gt; responseObservable = isAsync</span><br><span class="line">        ? <span class="keyword">new</span> CallEnqueueObservable&lt;&gt;(call)</span><br><span class="line">        : <span class="keyword">new</span> CallExecuteObservable&lt;&gt;(call);</span><br><span class="line">    Observable&lt;?&gt; observable;</span><br><span class="line">    <span class="keyword">if</span> (isResult) &#123;</span><br><span class="line">      observable = <span class="keyword">new</span> ResultObservable&lt;&gt;(responseObservable);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isBody) &#123;</span><br><span class="line">      observable = <span class="keyword">new</span> BodyObservable&lt;&gt;(responseObservable);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      observable = responseObservable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (scheduler != <span class="keyword">null</span>) &#123;</span><br><span class="line">      observable = observable.subscribeOn(scheduler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isFlowable) &#123;</span><br><span class="line">      <span class="keyword">return</span> observable.toFlowable(BackpressureStrategy.LATEST);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isSingle) &#123;</span><br><span class="line">      <span class="keyword">return</span> observable.singleOrError();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isMaybe) &#123;</span><br><span class="line">      <span class="keyword">return</span> observable.singleElement();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isCompletable) &#123;</span><br><span class="line">      <span class="keyword">return</span> observable.ignoreElements();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(observable);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OkHttp学习</title>
      <link href="/2019/07/13/Android-OkHttp%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/07/13/Android-OkHttp%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="what"><a href="#what" class="headerlink" title="what"></a>what</h2><p>非常好用的请求库，还是附上<a href="https://square.github.io/okhttp/calls/" target="_blank" rel="noopener">官方文档</a></p><h2 id="how"><a href="#how" class="headerlink" title="how"></a>how</h2><p>正常步骤就是</p><ol><li>构建键Client<ol><li>添加header</li><li>拦截器</li><li>缓存</li><li>dns</li><li>代理</li><li>超时</li><li>监听事件</li></ol></li><li>构建请求Request<ol><li>url</li><li>header</li><li>请求方式</li><li>请求体</li></ol></li><li>发送请求Call</li><li>获得响应Response</li><li>处理响应</li></ol><a id="more"></a><h3 id="简单同步请求"><a href="#简单同步请求" class="headerlink" title="简单同步请求"></a>简单同步请求</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">    .url(<span class="string">"https://www.wanandroid.com/article/list/0/json"</span>)</span><br><span class="line">    .build();</span><br><span class="line">Call call = client.newCall(request);</span><br><span class="line"><span class="keyword">try</span>(Response response = call.execute()) &#123;</span><br><span class="line">    System.out.println(response.code());</span><br><span class="line">    System.out.println(response.message());</span><br><span class="line">    System.out.println(response.body().string());</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="number">200</span></span><br><span class="line">OK</span><br><span class="line">(相应体数据)</span><br></pre></td></tr></table></figure><h3 id="简单异步请求"><a href="#简单异步请求" class="headerlink" title="简单异步请求"></a>简单异步请求</h3><p>就是简单的将execute换成了enqueue传入回调，这是异步的哦，会切换线程。但是再Test测试方法中，需要让外面的线程等待下，不然是看不到的结果的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">  OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">        Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">                .url(<span class="string">"https://www.wanandroid.com/article/list/0/json"</span>)</span><br><span class="line">                .build();</span><br><span class="line">        Call call = client.newCall(request);</span><br><span class="line">        call.enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, IOException e)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"onFailure"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(&#123;<span class="string">"in "</span>+Thread.currentThread().getId());</span><br><span class="line">                System.out.println(response.code());</span><br><span class="line">                System.out.println(response.message());</span><br><span class="line">                System.out.println(response.body().string());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println( <span class="string">"out "</span>+ Thread.currentThread().getId());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">out <span class="number">1</span></span><br><span class="line">in <span class="number">13</span></span><br><span class="line"><span class="number">200</span></span><br><span class="line">OK</span><br><span class="line">(相应体数据)</span><br></pre></td></tr></table></figure><h3 id="发送Post请求"><a href="#发送Post请求" class="headerlink" title="发送Post请求"></a>发送Post请求</h3><p>如果不对Request进行设置，默认就是get请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RequestBody requestBody = <span class="keyword">new</span> Request.Builder().addHeader().build();</span><br><span class="line">Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">    .url(<span class="string">"https://www.wanandroid.com/login"</span>)</span><br><span class="line">    .post(requestBody)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>所以主要就是看RequestBody的构建了</p><h4 id="通过静态方法create进行构建"><a href="#通过静态方法create进行构建" class="headerlink" title="通过静态方法create进行构建"></a>通过静态方法create进行构建</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MediaType contentType = MediaType.parse(<span class="string">"text/x-markdown; charset=utf-8"</span>);</span><br><span class="line">RequestBody requestBody = RequestBody.create(contentType, <span class="string">"hello"</span>);</span><br></pre></td></tr></table></figure><p>大概有这么几种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create(<span class="meta">@Nullable</span> MediaType contentType, String content);<span class="comment">//字符串</span></span><br><span class="line">create(<span class="keyword">final</span> <span class="meta">@Nullable</span> MediaType contentType, <span class="keyword">final</span> ByteString content);</span><br><span class="line">create(<span class="keyword">final</span> <span class="meta">@Nullable</span> MediaType contentType, <span class="keyword">final</span> <span class="keyword">byte</span>[] content);<span class="comment">//字节数组</span></span><br><span class="line">create(<span class="keyword">final</span> <span class="meta">@Nullable</span> MediaType contentType, <span class="keyword">final</span> <span class="keyword">byte</span>[] content,<span class="keyword">final</span> <span class="keyword">int</span> offset, <span class="keyword">final</span> <span class="keyword">int</span> byteCount);</span><br><span class="line">create(<span class="keyword">final</span> <span class="meta">@Nullable</span> MediaType contentType, <span class="keyword">final</span> File file);<span class="comment">//文件</span></span><br></pre></td></tr></table></figure><p>所以也可以直接构建提交文件RequestBody的。</p><h4 id="实现RequestBody"><a href="#实现RequestBody" class="headerlink" title="实现RequestBody"></a>实现RequestBody</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RequestBody requestBody1 = <span class="keyword">new</span> RequestBody() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> MediaType <span class="title">contentType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeTo</span><span class="params">(BufferedSink sink)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><h4 id="发送普通表单"><a href="#发送普通表单" class="headerlink" title="发送普通表单"></a>发送普通表单</h4><p>RequestBody有一个实现类FormBody</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FormBody formBody = <span class="keyword">new</span> FormBody.Builder()</span><br><span class="line">               .add(<span class="string">"name"</span>, <span class="string">"zhangsan"</span>)</span><br><span class="line">               .add(<span class="string">"password"</span>, <span class="string">"123"</span>)</span><br><span class="line">               .build();</span><br></pre></td></tr></table></figure><h4 id="发送Multi表单"><a href="#发送Multi表单" class="headerlink" title="发送Multi表单"></a>发送Multi表单</h4><p>RequestBody另一个一个实现类MultipartBody，添加许多Part</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MultipartBody body = <span class="keyword">new</span> MultipartBody.Builder()</span><br><span class="line">               .addFormDataPart(<span class="string">"name"</span>, <span class="string">"zhangsan"</span>)</span><br><span class="line">               .addPart(MultipartBody.Part.create(<span class="keyword">null</span>))</span><br><span class="line">               .build();</span><br></pre></td></tr></table></figure><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>OkHttp的核心可以就在于拦截器，内部通过拦截器链式调用。监听，重写，重试call</p><p>看下官网给的例子，用于测试请求消耗的时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Interceptor.Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Request request = chain.request();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">    logger.info(String.format(<span class="string">"Sending request %s on %s%n%s"</span>,</span><br><span class="line">        request.url(), chain.connection(), request.headers()));</span><br><span class="line"></span><br><span class="line">    Response response = chain.proceed(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> t2 = System.nanoTime();</span><br><span class="line">    logger.info(String.format(<span class="string">"Received response for %s in %.1fms%n%s"</span>,</span><br><span class="line">        response.request().url(), (t2 - t1) / <span class="number">1e6</span>d, response.headers()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拦截分为两种：</p><ul><li><p>全局拦截器 通过<code>OkHttpClient.Builder#addInterceptor(Interceptor)</code>加入</p></li><li><p>网络拦截器 通过 <code>OkHttpClient.Builder#addNetworkInterceptor(Interceptor)</code>加入，真正发起网络请求调用</p></li></ul><p><img src="https://square.github.io/okhttp/images/interceptors@2x.png" alt></p><h4 id="Application-Interceptors"><a href="#Application-Interceptors" class="headerlink" title="Application Interceptors"></a>Application Interceptors</h4><p>全局拦截器：</p><ul><li>不用关心重连，重定向</li><li>总是调用一次，即使http响应是来自缓存。</li><li>可以观察原始请求意图，</li><li>允许短路，不调用<code>Chain.proceed()</code></li><li>允许多次调用<code>Chain.proceed()</code></li></ul><p>一般我们可比如：从本地取出并注入cookie，以及取出cookie持久化到本地</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取并设置cookie</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadCookiesInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReadCookiesInterceptor</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        mContext = context;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Request.Builder builder = chain.request().newBuilder();</span><br><span class="line">        SharedPreferences pref = PreferenceManager.getDefaultSharedPreferences(mContext);</span><br><span class="line">        HashSet&lt;String&gt; cookies = (HashSet&lt;String&gt;) pref.getStringSet(<span class="string">"cookies"</span>, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">        <span class="keyword">for</span> (String cookie : cookies) &#123;</span><br><span class="line">            builder.addHeader(<span class="string">"Cookie"</span>, cookie);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chain.proceed(builder.build());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 保存cookie</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaveCookiesInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SaveCookiesInterceptor</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        mContext = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Response originalResponse = chain.proceed(chain.request());</span><br><span class="line">        <span class="keyword">if</span> (!originalResponse.headers(<span class="string">"Set-Cookie"</span>).isEmpty()) &#123;</span><br><span class="line">            HashSet&lt;String&gt; cookies = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            cookies.addAll(originalResponse.headers(<span class="string">"Set-Cookie"</span>));</span><br><span class="line">            SharedPreferences.Editor editor = PreferenceManager.getDefaultSharedPreferences(mContext).edit();</span><br><span class="line">            editor.putStringSet(<span class="string">"cookies"</span>, cookies).apply();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> originalResponse;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Network-Interceptors"><a href="#Network-Interceptors" class="headerlink" title="Network Interceptors"></a>Network Interceptors</h4><ul><li>能够操纵中间响应，重定向，重试</li><li>缓存中响应不会调用</li><li>可观察网络传输数据</li><li>可以获得具体Connection进行操作，比如IP，TLS等</li></ul><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>首先看下各个类的概念</p><ul><li>OkHttpClient 客户端：维持了线程池，避免重复创键消耗资源，最好使用复用一个</li><li>Dispatcher 线程池抽象聚合：维护一个核心线程为了0，上限Int最大数，存活时间60s的线程池</li><li>Response 请求的封装：包含了请求url，请求头，请求体</li><li>Response 响应的封装：包含了状态码，响应头，响应体</li><li>Call 一次请求的具体对象，分为同步和异步</li><li>Interceptor 拦截器，拦截并处理，交下个拦截器</li><li>Chain 请求链，和拦截器一起构成责任链模式</li></ul><h3 id="构建Client"><a href="#构建Client" class="headerlink" title="构建Client"></a>构建Client</h3><p>Builder模式，构建client，有默认配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">OkHttpClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> Builder());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构建请求"><a href="#构建请求" class="headerlink" title="构建请求"></a>构建请求</h3><p>同样Builder模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Request(Builder builder) &#123;</span><br><span class="line">  <span class="keyword">this</span>.url = builder.url;</span><br><span class="line">  <span class="keyword">this</span>.method = builder.method;</span><br><span class="line">  <span class="keyword">this</span>.headers = builder.headers.build();</span><br><span class="line">  <span class="keyword">this</span>.body = builder.body;</span><br><span class="line">  <span class="keyword">this</span>.tags = Util.immutableMap(builder.tags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="newCall"><a href="#newCall" class="headerlink" title="newCall"></a>newCall</h3><p>实例出RealCall</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Call <span class="title">newCall</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RealCall.newRealCall(<span class="keyword">this</span>, request, <span class="keyword">false</span> <span class="comment">/* for web socket */</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> RealCall <span class="title">newRealCall</span><span class="params">(OkHttpClient client, Request originalRequest, <span class="keyword">boolean</span> forWebSocket)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Safely publish the Call instance to the EventListener.</span></span><br><span class="line">    RealCall call = <span class="keyword">new</span> RealCall(client, originalRequest, forWebSocket);</span><br><span class="line">    call.transmitter = <span class="keyword">new</span> Transmitter(client, call);</span><br><span class="line">    <span class="keyword">return</span> call;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="同步请求"><a href="#同步请求" class="headerlink" title="同步请求"></a>同步请求</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);<span class="comment">//执行过不能执行</span></span><br><span class="line">        executed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    transmitter.timeoutEnter();<span class="comment">//Okio超时，我还没搞懂233</span></span><br><span class="line">    transmitter.callStart();<span class="comment">//触发监听</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        client.dispatcher().executed(<span class="keyword">this</span>);<span class="comment">//RealCall入dispatcher的runningCall队列</span></span><br><span class="line">        <span class="keyword">return</span> getResponseWithInterceptorChain();<span class="comment">//进入</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        client.dispatcher().finished(<span class="keyword">this</span>);<span class="comment">//继续调用其它异步call</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>call入队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">executed</span><span class="params">(RealCall call)</span> </span>&#123;  runningSyncCalls.add(call);&#125;</span><br></pre></td></tr></table></figure><p>进行请求返回响应</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">  List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  interceptors.addAll(client.interceptors());<span class="comment">//全局拦截器</span></span><br><span class="line">  interceptors.add(<span class="keyword">new</span> RetryAndFollowUpInterceptor(client));<span class="comment">//请求重连拦截器</span></span><br><span class="line">  interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar()));<span class="comment">//构建网络请求</span></span><br><span class="line">  interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));<span class="comment">//cache</span></span><br><span class="line">  interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client));<span class="comment">//封装httpCodec</span></span><br><span class="line">  <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">    interceptors.addAll(client.networkInterceptors());</span><br><span class="line">  &#125;</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> CallServerInterceptor(forWebSocket));<span class="comment">//发送具体网络请求</span></span><br><span class="line"></span><br><span class="line">  Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(interceptors, transmitter, <span class="keyword">null</span>, <span class="number">0</span>,</span><br><span class="line">      originalRequest, <span class="keyword">this</span>, client.connectTimeoutMillis(),</span><br><span class="line">      client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> calledNoMoreExchanges = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Response response = chain.proceed(originalRequest);<span class="comment">//进入拦截器链</span></span><br><span class="line">    <span class="keyword">if</span> (transmitter.isCanceled()) &#123;</span><br><span class="line">      closeQuietly(response);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    calledNoMoreExchanges = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">throw</span> transmitter.noMoreExchanges(e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!calledNoMoreExchanges) &#123;</span><br><span class="line">      transmitter.noMoreExchanges(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入拦截器链</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request, Transmitter transmitter, @Nullable Exchange exchange)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= interceptors.size()) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line"></span><br><span class="line">    calls++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we already have a stream, confirm that the incoming request will use it.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.exchange != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.exchange.connection().supportsUrl(request.url())) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptors.get(index - <span class="number">1</span>)</span><br><span class="line">          + <span class="string">" must retain the same host and port"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we already have a stream, confirm that this is the only call to chain.proceed().</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.exchange != <span class="keyword">null</span> &amp;&amp; calls &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptors.get(index - <span class="number">1</span>)</span><br><span class="line">          + <span class="string">" must call proceed() exactly once"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call the next interceptor in the chain.重新构建链</span></span><br><span class="line">    RealInterceptorChain next = <span class="keyword">new</span> RealInterceptorChain(interceptors, transmitter, exchange,</span><br><span class="line">        index + <span class="number">1</span>, request, call, connectTimeout, readTimeout, writeTimeout);</span><br><span class="line">    Interceptor interceptor = interceptors.get(index);</span><br><span class="line">    Response response = interceptor.intercept(next);<span class="comment">//进入下一个拦截器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Confirm that the next interceptor made its required call to chain.proceed().</span></span><br><span class="line">    <span class="keyword">if</span> (exchange != <span class="keyword">null</span> &amp;&amp; index + <span class="number">1</span> &lt; interceptors.size() &amp;&amp; next.calls != <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptor</span><br><span class="line">          + <span class="string">" must call proceed() exactly once"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Confirm that the intercepted response isn't null.</span></span><br><span class="line">    <span class="keyword">if</span> (response == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"interceptor "</span> + interceptor + <span class="string">" returned null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (response.body() == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">          <span class="string">"interceptor "</span> + interceptor + <span class="string">" returned a response with no body"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>经历重重拦截器，通过Okio库进行对Socket进行流的读写，就完成一次请求。</p><h3 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h3><p>和同步请求不一样，具体是AsyncCall，将请求提交给线程池，触发回调。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</span><br><span class="line">        executed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    transmitter.callStart();<span class="comment">//触发事件监听</span></span><br><span class="line">    client.dispatcher().enqueue(<span class="keyword">new</span> AsyncCall(responseCallback));<span class="comment">//入队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        readyAsyncCalls.add(call);<span class="comment">//入队列</span></span><br><span class="line">        <span class="comment">// Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to</span></span><br><span class="line">        <span class="comment">// the same host.</span></span><br><span class="line">        <span class="keyword">if</span> (!call.get().forWebSocket) &#123;</span><br><span class="line">            AsyncCall existingCall = findExistingCallWithHost(call.host());</span><br><span class="line">            <span class="keyword">if</span> (existingCall != <span class="keyword">null</span>) call.reuseCallsPerHostFrom(existingCall);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    promoteAndExecute();<span class="comment">//执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">promoteAndExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> (!Thread.holdsLock(<span class="keyword">this</span>));</span><br><span class="line">    List&lt;AsyncCall&gt; executableCalls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span> isRunning;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;<span class="comment">//遍历准备队列</span></span><br><span class="line">        AsyncCall asyncCall = i.next();</span><br><span class="line">        <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">break</span>; <span class="comment">// Max capacity.运行队列满</span></span><br><span class="line">        <span class="comment">//请求Host的数量超出</span></span><br><span class="line">        <span class="keyword">if</span> (asyncCall.callsPerHost().get() &gt;= maxRequestsPerHost) <span class="keyword">continue</span>; <span class="comment">// Host max capacity.</span></span><br><span class="line">        i.remove();<span class="comment">//出准备队列</span></span><br><span class="line">        asyncCall.callsPerHost().incrementAndGet();</span><br><span class="line">        executableCalls.add(asyncCall);<span class="comment">//入执行队列</span></span><br><span class="line">        runningAsyncCalls.add(asyncCall);<span class="comment">//入运行队列</span></span><br><span class="line">      &#125;</span><br><span class="line">      isRunning = runningCallsCount() &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = executableCalls.size(); i &lt; size; i++) &#123;</span><br><span class="line">      AsyncCall asyncCall = executableCalls.get(i);</span><br><span class="line">      asyncCall.executeOn(executorService());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isRunning;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>AsnycCall是个Runaable实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">executeOn</span><span class="params">(ExecutorService executorService)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">assert</span> (!Thread.holdsLock(client.dispatcher()));</span><br><span class="line">      <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        executorService.execute(<span class="keyword">this</span>);<span class="comment">//提交到线程池</span></span><br><span class="line">        success = <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">        InterruptedIOException ioException = <span class="keyword">new</span> InterruptedIOException(<span class="string">"executor rejected"</span>);</span><br><span class="line">        ioException.initCause(e);</span><br><span class="line">        transmitter.noMoreExchanges(ioException);</span><br><span class="line">        responseCallback.onFailure(RealCall.<span class="keyword">this</span>, ioException);<span class="comment">//触发失败回调</span></span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">          client.dispatcher().finished(<span class="keyword">this</span>); <span class="comment">// This call is no longer running!</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>线程具体执行的地方</p><p>走到这里就和同步请求一致了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> signalledCallback = <span class="keyword">false</span>;</span><br><span class="line">    transmitter.timeoutEnter();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Response response = getResponseWithInterceptorChain();<span class="comment">//请求响应</span></span><br><span class="line">        signalledCallback = <span class="keyword">true</span>;</span><br><span class="line">        responseCallback.onResponse(RealCall.<span class="keyword">this</span>, response);<span class="comment">//成功回调</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (signalledCallback) &#123;</span><br><span class="line">            <span class="comment">// Do not signal the callback twice!</span></span><br><span class="line">            Platform.get().log(INFO, <span class="string">"Callback failure for "</span> + toLoggableString(), e);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            responseCallback.onFailure(RealCall.<span class="keyword">this</span>, e);<span class="comment">//失败回调</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ul><li>Response读取一次内容会关闭，所以只能读取一次</li><li>Response读取byteStream时，需要手动close它</li></ul><p>参考：</p><ul><li><a href="https://square.github.io/okhttp/" target="_blank" rel="noopener">https://square.github.io/okhttp/</a></li><li><a href="https://www.jianshu.com/p/9ed2c2f2a52c" target="_blank" rel="noopener">https://www.jianshu.com/p/9ed2c2f2a52c</a></li><li><a href="https://www.jianshu.com/p/da4a806e599b" target="_blank" rel="noopener">https://www.jianshu.com/p/da4a806e599b</a></li><li><a href="https://www.jianshu.com/p/70dfa335916c" target="_blank" rel="noopener">OkHttp踩坑记：为何 response.body().string() 只能调用一次</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习使用Rxjava</title>
      <link href="/2019/07/10/Android-RxJava%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/07/10/Android-RxJava%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="RxJava"><a href="#RxJava" class="headerlink" title="RxJava"></a>RxJava</h2><h3 id="What"><a href="#What" class="headerlink" title="What:"></a>What:</h3><p>异步</p><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>Observable 通用的被观察者</li><li>Observer  通用的观察者</li><li>Scheduler 线程调度器</li><li>Disposable 一次性的</li></ul><h3 id="how"><a href="#how" class="headerlink" title="how"></a>how</h3><a id="more"></a><h4 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先创建被观察者</span></span><br><span class="line">Observable observable = Observable.create(</span><br><span class="line">                <span class="keyword">new</span> ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;String&gt; observableEmitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        observableEmitter.onNext(<span class="string">"hello"</span>);</span><br><span class="line">                        <span class="keyword">int</span> error = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span> (error == <span class="number">0</span>) &#123;</span><br><span class="line">                            observableEmitter.onError(<span class="keyword">new</span> Exception(<span class="string">"error == 0"</span>));</span><br><span class="line">                        &#125;</span><br><span class="line">                        observableEmitter.onComplete();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"><span class="comment">//创建观察者</span></span><br><span class="line"></span><br><span class="line"> Observer observer = <span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable disposable)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"onSubscribe"</span>);<span class="comment">//产生订阅关系调用，即在调用subscribe线程</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">                System.out.println(str);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"error!!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"onComplete"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//订阅，（注入灵魂233）</span></span><br><span class="line">    observable.subscribe(oberver);</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">onSubscribe</span><br><span class="line">hello</span><br><span class="line">onComplete</span><br></pre></td></tr></table></figure><p>结合使用lambda链式写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(subscribe-&gt; &#123;</span><br><span class="line">            subscribe.onNext(<span class="string">"hello"</span>);</span><br><span class="line">            <span class="keyword">int</span> errorCode = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (errorCode == <span class="number">1</span>) &#123;</span><br><span class="line">                subscribe.onError(<span class="keyword">new</span> Exception(<span class="string">"errorCode = 1"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            subscribe.onComplete();</span><br><span class="line">        &#125;).doOnSubscribe(str -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"onSubscribe"</span>);</span><br><span class="line">        &#125;).subscribe(</span><br><span class="line">                str-&gt; System.out.println(str),</span><br><span class="line">                throwable -&gt; throwable.printStackTrace(),</span><br><span class="line">                ()-&gt; System.out.println(<span class="string">"complete"</span>));</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">onSubscribe</span><br><span class="line">hello</span><br><span class="line">complete</span><br></pre></td></tr></table></figure><h4 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h4><p>Rxjava提供了以下几种线程调度器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Schedulers.single();<span class="comment">//所有任务在单线程</span></span><br><span class="line">Schedulers.newThread();<span class="comment">//使用新线程</span></span><br><span class="line">Schedulers.trampoline();<span class="comment">//</span></span><br><span class="line">Schedulers.io();<span class="comment">//用于IO密集型操作，比如读取文件，数据库，网络</span></span><br><span class="line">Schedulers.computation();<span class="comment">//用于CPU密集型计算，比如xml，json解析，Bitmap压缩取样</span></span><br><span class="line">AndroidSchedulers.mainThread();<span class="comment">//android 主线程</span></span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> Observable.create(emitter -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"observable"</span>);</span><br><span class="line">            emitter.onNext(<span class="string">"hello"</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getId());</span><br><span class="line">        &#125;) .subscribeOn(Schedulers.newThread())<span class="comment">//被观察者执行动作所在线程</span></span><br><span class="line">                .observeOn(Schedulers.newThread())<span class="comment">//观察者执行动作所在线程</span></span><br><span class="line">                .subscribe(str-&gt;&#123;</span><br><span class="line">                    System.out.println(<span class="string">"observer"</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getId());</span><br><span class="line">                    System.out.println(str);</span><br><span class="line">                &#125;);</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">observable</span><br><span class="line"><span class="number">14</span></span><br><span class="line">observer</span><br><span class="line"><span class="number">15</span></span><br><span class="line">hello</span><br></pre></td></tr></table></figure><p>这样就基本上能完成很多线程切换的操作。</p><h4 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h4><p>格式各样的操作符，我就记下我看懂的操作符吧呃呃</p><p>变换</p><ul><li>map</li><li>flatMap</li></ul><p>过滤</p><ul><li>filter</li><li>take</li><li>takeLast</li><li>skip</li><li>skipLast</li><li>elementAt</li><li>debounce</li><li>distinct</li><li>first</li><li>last</li></ul><p>组合</p><ul><li>merge</li><li>startWith</li><li>concat</li><li>zip</li></ul><p>其它</p><ul><li>interval</li><li>compose</li></ul><h5 id="map"><a href="#map" class="headerlink" title="map"></a>map</h5><p>将发射值进行转换成另一种发设值</p><p>map(Func1&lt;? super T, ? extends R&gt; func))</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">                .map(integer -&gt; &#123;</span><br><span class="line">                    <span class="keyword">char</span> tmp = (<span class="keyword">char</span>) (<span class="string">'a'</span> + integer);</span><br><span class="line">                    <span class="keyword">return</span> String.valueOf(integer) + tmp;</span><br><span class="line">                &#125;).subscribe(System.out::println);</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="number">1</span>b</span><br><span class="line"><span class="number">2</span>c</span><br><span class="line"><span class="number">3</span>d</span><br><span class="line"><span class="number">4</span>e</span><br><span class="line"><span class="number">5f</span></span><br></pre></td></tr></table></figure><h5 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h5><p>发射值进行进一步转换成Observable序列，平摊成Observable序列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="string">"1234"</span>, <span class="string">"5678"</span>)</span><br><span class="line">                .flatMap((Function&lt;String, ObservableSource&lt;Character&gt;&gt;) s -&gt; &#123;</span><br><span class="line">                    Character[] characters = <span class="keyword">new</span> Character[s.length()];</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">                        characters[i] = s.charAt(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> Observable.fromArray(characters);</span><br><span class="line">                &#125;).subscribe(System.out::println);</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure><h5 id="scan"><a href="#scan" class="headerlink" title="scan"></a>scan</h5><p>将上一个经过函数处理的发射值作为下一个参数继续处理。</p><p>好比如：第一次处理为1，第二次就是1+2=3，然后第三次3+3=6，依次类推</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">                .scan((integer, integer2) -&gt; integer + integer2)</span><br><span class="line">                .subscribe(System.out::println);</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure><h5 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h5><p>判断式过滤</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">                .filter(integer -&gt; integer % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                .subscribe(System.out::println);</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><h5 id="take"><a href="#take" class="headerlink" title="take"></a>take</h5><p>只取前n个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">                .take(<span class="number">3</span>)</span><br><span class="line">                .subscribe(System.out::println);</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h5 id="takeLast"><a href="#takeLast" class="headerlink" title="takeLast"></a>takeLast</h5><p>只去后n个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">                .takeLast(<span class="number">3</span>)</span><br><span class="line">                .subscribe(System.out::println);</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><h5 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h5><p>跳过前n个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">                .skip(<span class="number">2</span>)</span><br><span class="line">                .subscribe(System.out::println);</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><h5 id="skipLast"><a href="#skipLast" class="headerlink" title="skipLast"></a>skipLast</h5><p>跳过后n个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">                .skipLast(<span class="number">2</span>)</span><br><span class="line">                .subscribe(System.out::println);</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h5 id="elementAt"><a href="#elementAt" class="headerlink" title="elementAt"></a>elementAt</h5><p>只去固定序号元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">                .elementAt(<span class="number">3</span>)</span><br><span class="line">                .subscribe(System.out::println);</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h5 id="debounce"><a href="#debounce" class="headerlink" title="debounce"></a>debounce</h5><p>过滤掉了由Observable发射的速率过快的数据；如果在一个指定的时间间隔过去了仍旧没有发射一个，那么它将发射最后的那个。通常我们用来结合RxBinding(Jake Wharton大神使用RxJava封装的Android UI组件)使用，防止button重复点击。</p><h5 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h5><p>去重</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">                .distinct()</span><br><span class="line">                .subscribe(System.out::println);</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>distinct(Func1) 则需要你给出key作为去重依据</p><p>distinctUntilChanged(Func1)和distinct(Func1)一样，根据Func1中call方法产生一个Key来判断两个相邻的数据项是否相同。</p><h5 id="first"><a href="#first" class="headerlink" title="first"></a>first</h5><p>只发送第一个元素，first参数为，当没有元素发出，则使用参数发出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">                .first(<span class="number">2</span>)</span><br><span class="line">                .subscribe(System.out::println);</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h5 id="last"><a href="#last" class="headerlink" title="last"></a>last</h5><p>类似first，最后一个</p><h5 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h5><p>两个事件序列和一个，合并的数据是无序的。</p><h5 id="startWith"><a href="#startWith" class="headerlink" title="startWith"></a>startWith</h5><p>在某序列前合并</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">startWith(T);</span><br><span class="line">startWith(T...);</span><br><span class="line">startWith(Observable&lt;T&gt;);</span><br><span class="line">startWith(Iterable&lt;T&gt;);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Observable a = Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">Observable b = Observable.just(<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>);</span><br><span class="line">a.startWith(Arrays.asList(<span class="number">0</span>,<span class="number">9</span>,<span class="number">22</span>)).subscribe(System.out::println);</span><br><span class="line">System.out.println(<span class="string">"--------------"</span>);</span><br><span class="line">a.startWith(b).subscribe(System.out::println);</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">22</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">--------------</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h5 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h5><p>严格按照发射顺序组合，上一个没发射完，下一个不会发射。</p><h5 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h5><p>将两个事件序列，通过函数组合新的，数量不匹配的元素丢弃。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Observable a = Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>);</span><br><span class="line">Observable b = Observable.just(<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>);</span><br><span class="line">Observable.zip(a,b,(BiFunction&lt;Integer, Character, String&gt;) </span><br><span class="line">    (integer, character) -&gt; integer + String.valueOf(character))</span><br><span class="line">    .subscribe(System.out::println);</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="number">1</span>a</span><br><span class="line"><span class="number">2</span>b</span><br><span class="line"><span class="number">3</span>c</span><br></pre></td></tr></table></figure><h5 id="interval"><a href="#interval" class="headerlink" title="interval"></a>interval</h5><p>按照间隔执行，但是要产生订阅关系的线程不能立即执行完毕，否则无法执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Observable.interval(<span class="number">300</span>,TimeUnit.MILLISECONDS).subscribe(position -&gt; System.out.println(position));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">20000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">按照间隔<span class="number">300</span>ms打印positon，从<span class="number">0</span>开始，代表次数</span><br></pre></td></tr></table></figure><h5 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h5><p>对事件序列的变换也就是Obervable的变化，之前是mapflatMap是对发射元素的变换，这个可以直接处理事件流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">        Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">                .compose(upstream -&gt; upstream.subscribeOn(Schedulers.io()).observeOn(Schedulers.newThread()))</span><br><span class="line">                .subscribe();</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">  Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">      .subscribeOn(Schedulers.io())</span><br><span class="line">      .observeOn(Schedulers.newThread()))</span><br><span class="line">      .subscribe();</span><br></pre></td></tr></table></figure><p>比如重复代码：线程切换，可以写成通用代码，然后直接传给compose就行了同理有其他的流处理操作也可以复用，然后调用compose</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ObservableTransformer&lt;T, T&gt; <span class="title">rxSchedulerhelper</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> observable -&gt; observable.subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="why"><a href="#why" class="headerlink" title="why"></a>why</h3><p>调用还是挺简单的，内部实现的话可以概括为：</p><p>自上而下生成装饰的Observable，在subscribe时，从下往上订阅上游Observable并且生成装饰的Observer。</p><p>自上而下包装Observable，subscriber自下而上生调用上流的observale，同时消费对应的Observer，即自下而上包装Obserer，在顺序上表现为，下流Obervable不断的调用存储上流的Obervable，在onNext时，上游Oberver依次调用下游Oberver。</p><h4 id="分析最简单的订阅"><a href="#分析最简单的订阅" class="headerlink" title="分析最简单的订阅"></a>分析最简单的订阅</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Observable observable = Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;String&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">               System.out.println(Thread.currentThread().getId());</span><br><span class="line">               System.out.println(<span class="string">"run"</span>);</span><br><span class="line">               emitter.onNext(<span class="string">"test"</span>);</span><br><span class="line">               emitter.onComplete();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       Observer observer = <span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">               System.out.println(Thread.currentThread().getId());</span><br><span class="line">               System.out.println(<span class="string">"onSubscribe"</span>);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String o)</span> </span>&#123;</span><br><span class="line">               System.out.println(Thread.currentThread().getId());</span><br><span class="line">               System.out.println(<span class="string">"onNext"</span> + o);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">               System.out.println(<span class="string">"onError"</span>);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               System.out.println(<span class="string">"onComplete"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">    observable.subscribe(observer);</span><br></pre></td></tr></table></figure><p>首先Observable.create创键出Obervable。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">create</span><span class="params">(ObservableOnSubscribe&lt;T&gt; source)</span> </span>&#123;</span><br><span class="line">        ObjectHelper.requireNonNull(source, <span class="string">"source is null"</span>);</span><br><span class="line">        <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableCreate&lt;T&gt;(source));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>返回了一个ObservableCreate的并且把我们的源储存起来了</p><p>调用subscribe</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">    ObjectHelper.requireNonNull(observer, <span class="string">"observer is null"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        observer = RxJavaPlugins.onSubscribe(<span class="keyword">this</span>, observer);</span><br><span class="line"></span><br><span class="line">        ObjectHelper.requireNonNull(observer, <span class="string">"Plugin returned null Observer"</span>);</span><br><span class="line"></span><br><span class="line">        subscribeActual(observer);/</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException e) &#123; <span class="comment">// NOPMD</span></span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        Exceptions.throwIfFatal(e);</span><br><span class="line">        <span class="comment">// can't call onError because no way to know if a Disposable has been set or not</span></span><br><span class="line">        <span class="comment">// can't call onSubscribe because the call might have set a Subscription already</span></span><br><span class="line">        RxJavaPlugins.onError(e);</span><br><span class="line"></span><br><span class="line">        NullPointerException npe = <span class="keyword">new</span> NullPointerException(<span class="string">"Actually not, but can't throw other exceptions due to RS"</span>);</span><br><span class="line">        npe.initCause(e);</span><br><span class="line">        <span class="keyword">throw</span> npe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着实际调用subscribeActual，这个是抽象方法，所以得看ObservableCreate得实现内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">        CreateEmitter&lt;T&gt; parent = <span class="keyword">new</span> CreateEmitter&lt;T&gt;(observer);<span class="comment">//将observer传入CreateEmitter</span></span><br><span class="line">        observer.onSubscribe(parent);<span class="comment">//触发onSubscribe</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            source.subscribe(parent);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            Exceptions.throwIfFatal(ex);</span><br><span class="line">            parent.onError(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>调用我们源头的source，也就是开始定义得。然后就执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Observable observable = Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;String&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getId());</span><br><span class="line">                System.out.println(<span class="string">"run"</span>);</span><br><span class="line">                emitter.onNext(<span class="string">"test"</span>);<span class="comment">//触发observer的onNext</span></span><br><span class="line">                emitter.onComplete();<span class="comment">//触发observer的onComplete</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>这样就完成一个订阅关系。可以看出每一层Observable和Observer通过subscribe订阅触发，如果调用了线程切换，各种操作符，其实也是在从上层生成新的Observable包裹着上游的Observable，最后在最下层订阅，从下层开始一层一层调用subscribe的最终调到源头的Observable。</p><h4 id="带线程的调度分析"><a href="#带线程的调度分析" class="headerlink" title="带线程的调度分析"></a>带线程的调度分析</h4><p>知道他的触发原理后我们可以直接去看那一层的Observable和Observer</p><h5 id="ObservableSubscribeOn"><a href="#ObservableSubscribeOn" class="headerlink" title="ObservableSubscribeOn"></a>ObservableSubscribeOn</h5><p>这个就是我们使用subscribeOn即在Observable线程调度，看看它实际触发订阅的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(<span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> SubscribeOnObserver&lt;T&gt; parent = <span class="keyword">new</span> SubscribeOnObserver&lt;T&gt;(s);<span class="comment">//新的Observer</span></span><br><span class="line"></span><br><span class="line">        s.onSubscribe(parent);<span class="comment">//onSubscribe总是在订阅触发线程执行</span></span><br><span class="line"></span><br><span class="line">        parent.setDisposable(scheduler.scheduleDirect(<span class="keyword">new</span> SubscribeTask(parent)));<span class="comment">//使用具体的调度器取执行调度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscribeTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> SubscribeOnObserver&lt;T&gt; parent;</span><br><span class="line"></span><br><span class="line">        SubscribeTask(SubscribeOnObserver&lt;T&gt; parent) &#123;</span><br><span class="line">            <span class="keyword">this</span>.parent = parent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            source.subscribe(parent);<span class="comment">//触发上一层的订阅</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>额，scheduler的调度我下次分析把，反正大抵上就是使用线程池啊等来进行线程调度。</p><h5 id="ObservableObserveOn"><a href="#ObservableObserveOn" class="headerlink" title="ObservableObserveOn"></a>ObservableObserveOn</h5><p>这个就是形成obsrverOn的地方，也就是observer的线程调度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (scheduler <span class="keyword">instanceof</span> TrampolineScheduler) &#123;</span><br><span class="line">            source.subscribe(observer);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Scheduler.Worker w = scheduler.createWorker();</span><br><span class="line"></span><br><span class="line">            source.subscribe(<span class="keyword">new</span> ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//这次就没有再subscribe上做手脚，而是再ObserveOnObserver包装类上做了线程切换，下游的onNext进行线程切换处理</span></span><br></pre></td></tr></table></figure><p>因为Obervable是从上到下进行包裹，所以subscribOn多次调用也只会是第一起作用。而Observer是订阅时从下往上包裹，所以observerOn可以变化许多次。</p><p>其它操作符也是如此把。</p><h4 id="RxBus"><a href="#RxBus" class="headerlink" title="RxBus"></a>RxBus</h4><p>RxBus 实现是在一个既为Observable和Observer的实例中内部保存了事件数组，通过触发onNext遍历到对应的事件，进行调用。</p><p>待补充。。。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归纳下广播和内容提供器</title>
      <link href="/2019/07/10/Android-%E5%BD%92%E7%BA%B3%E4%B8%8B%E5%B9%BF%E6%92%AD%E5%92%8C%E5%86%85%E5%AE%B9%E6%8F%90%E4%BE%9B%E5%99%A8/"/>
      <url>/2019/07/10/Android-%E5%BD%92%E7%BA%B3%E4%B8%8B%E5%B9%BF%E6%92%AD%E5%92%8C%E5%86%85%E5%AE%B9%E6%8F%90%E4%BE%9B%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h2><h3 id="what"><a href="#what" class="headerlink" title="what"></a>what</h3><p>android内部封装的一种通信方式，如其名，广播，向注册的接收者广播信息</p><ul><li>标准广播：异步执行，所有接受器几乎同时收到，无法被拦截</li><li>有序广播：同步执行，有先后顺序，按照优先级，可以被拦截</li></ul><h3 id="接受系统广播"><a href="#接受系统广播" class="headerlink" title="接受系统广播"></a>接受系统广播</h3><p>在android系统内部会有巨多的广播，来向向应用扩散重要信息。比如开机，网络，sd卡等等。</p><p>想要接受系统广播首先需要定义<code>广播接收器</code>：</p><ul><li>静态注册：在Manifest中声明关心的广播</li><li>动态注册：通过代码声明</li></ul><a id="more"></a><h4 id="定义广播接收器"><a href="#定义广播接收器" class="headerlink" title="定义广播接收器"></a>定义广播接收器</h4><p>继承<code>BroadcastReceiver</code>重写onReceive即可判断广播</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkChangeRecevier</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        ConnectivityManager connectivityManager = (ConnectivityManager)        getSystemService(Context.CONNECTIVITY_SERVICE);</span><br><span class="line">        NetworkInfo networkInfo = connectivityManager.getActiveNetworkInfo();</span><br><span class="line">        <span class="keyword">if</span> (networkInfo != <span class="keyword">null</span> &amp;&amp; networkInfo.isAvailable()) &#123;</span><br><span class="line">            Toast.makeText(MainActivity.<span class="keyword">this</span>,<span class="string">"网络可用"</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Toast.makeText(MainActivity.<span class="keyword">this</span>,<span class="string">"网络不可用"</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态注册"><a href="#静态注册" class="headerlink" title="静态注册"></a>静态注册</h4><p>直接在Manifest中书写<code>receiver</code>标签，同如activity和service，写好<code>intent-filter</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//1、新建一个BroadcastReceiver</span><br><span class="line">//2、在应用配置文件，设置好权限，以及监听的广播</span><br><span class="line"><span class="tag">&lt;<span class="name">receiver</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">".BootCompleteReceiver"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:enabled</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:exported</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.BOOT_COMPLETED"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line">//enabled表示是否启用</span><br><span class="line">//exproted表示是否接受应用以外的广播</span><br></pre></td></tr></table></figure><h4 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">intentFilter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">intentFilter.addAction(<span class="string">"android.net.conn.CONNECTIVITY_CHANGE"</span>);</span><br><span class="line">recevier = <span class="keyword">new</span> NetworkChangeRecevier();</span><br><span class="line">registerReceiver(recevier,intentFilter);</span><br></pre></td></tr></table></figure><p>只有注册完之后才能监听广播。</p><p>记得在对应的生命周期取消注册。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unregisterReceiver(recevier);</span><br></pre></td></tr></table></figure><h3 id="自定义广播"><a href="#自定义广播" class="headerlink" title="自定义广播"></a>自定义广播</h3><p>需要自行传达某些消息</p><h4 id="发送标准广播"><a href="#发送标准广播" class="headerlink" title="发送标准广播"></a>发送标准广播</h4><p>8.0后自定义广播接受不到解决方案：</p><ul><li>使用动态注册</li><li>静态注册，发送广播时携带ComponentName</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、新建一个自定义的广播接受器</span></span><br><span class="line"><span class="comment">//2、静态注册接受自定义的广播</span></span><br><span class="line"><span class="comment">//3、发送广播</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.example.tt.MY_BROADCAST"</span>);</span><br><span class="line">Log.d(<span class="string">"button"</span>, <span class="string">"onClick: "</span>);</span><br><span class="line">intent.setComponent(<span class="keyword">new</span> ComponentName(<span class="string">"com.example.hujie2.broadcasttest"</span>,</span><br><span class="line">        <span class="string">"com.example.hujie2.broadcasttest.MyBroadcastReceiver"</span>));</span><br><span class="line">sendBroadcast(intent);</span><br></pre></td></tr></table></figure><h4 id="发送有序广播"><a href="#发送有序广播" class="headerlink" title="发送有序广播"></a>发送有序广播</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setOrderBroadcast(intent);</span><br><span class="line">Manifest通过设置android:priority设置优先级</span><br><span class="line">使用 abortBroadcast() 拦截广播</span><br></pre></td></tr></table></figure><h4 id="粘性广播"><a href="#粘性广播" class="headerlink" title="粘性广播"></a>粘性广播</h4><p><strong>需要额外申请权限</strong>在Android系统粘性广播一般用来确保重要的状态改变后的信息被持久保存，并且能随时广播给新的广播接收器使用，使用isInitialStickyBroadcast来判断是否是一个粘性的初始广播值，比如我遇见的耳机插拔的时候就出现的粘性广播。</p><p>声明权限</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.BROADCAST_STICKY"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>发送</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sendStickyBroadcast(intent);<span class="comment">//好像API写了废弃。。</span></span><br></pre></td></tr></table></figure><p>判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isInitialStickyBroadcast()</span><br></pre></td></tr></table></figure><h3 id="本地广播"><a href="#本地广播" class="headerlink" title="本地广播"></a>本地广播</h3><p>只在本地应用实行的广播，如果不需要向外部广播，那就用本地广播咯</p><p>发送和注册方式略有不同，通过获得<code>LocalBroadcastManager</code>实例来管理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">localBroadcastManager = LocalBroadcastManager.getInstance(<span class="keyword">this</span>);<span class="comment">//本地广播管理器</span></span><br><span class="line">Button button = findViewById(R.id.button2);</span><br><span class="line">button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="string">"MY.LocalBroadcast"</span>);<span class="comment">//意图</span></span><br><span class="line">        localBroadcastManager.sendBroadcast(intent);<span class="comment">//发送本地广播</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">intentFilter = <span class="keyword">new</span> IntentFilter();<span class="comment">//意图过滤</span></span><br><span class="line">intentFilter.addAction(<span class="string">"MY.LocalBroadcast"</span>);<span class="comment">//设置监听广播行为</span></span><br><span class="line">localReceiver = <span class="keyword">new</span> LocalReceiver();<span class="comment">//自定义广播接收器</span></span><br><span class="line">localBroadcastManager.registerReceiver(localReceiver,intentFilter);<span class="comment">//注册广播接收器</span></span><br><span class="line">localBroadcastManager.unregisterReceiver(localReceiver);<span class="comment">//注销广播接受器</span></span><br></pre></td></tr></table></figure><h3 id="后续补充"><a href="#后续补充" class="headerlink" title="后续补充"></a>后续补充</h3><h2 id="内容提供器"><a href="#内容提供器" class="headerlink" title="内容提供器"></a>内容提供器</h2><h3 id="what-1"><a href="#what-1" class="headerlink" title="what"></a>what</h3><p>在andorid往往需要访问其它应用的数据共同协作。通过内容提供器的方式安全的提供给其他应用访问修改数据。比如读取通讯录，读取MediaCenter的数据，他们都是暴露除了内容提供器来供其它应用访问数据。其它应用通过内容解析器访问uri，如同访问数据库的方式一样访问修改数据。</p><h3 id="FileContentProvider"><a href="#FileContentProvider" class="headerlink" title="FileContentProvider"></a>FileContentProvider</h3><p>从android 7.0开始直接使用<code>file://Uri</code>这样暴力的传达文件路径进行分享操作将不可用，会报<code>FileUriExposedException</code>异常，必须得用<code>content://Uri</code>这样得形式来解析分享文件的路径</p><h4 id="声明FileContentProvider"><a href="#声明FileContentProvider" class="headerlink" title="声明FileContentProvider"></a>声明FileContentProvider</h4><p>Manifest中配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"android.support.v4.content.FileProvider"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:authorities</span>=<span class="string">"app的包名.fileProvider"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:grantUriPermissions</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"android.support.FILE_PROVIDER_PATHS"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:resource</span>=<span class="string">"@xml/file_paths"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="路径配置文件"><a href="#路径配置文件" class="headerlink" title="路径配置文件"></a>路径配置文件</h4><p>在xml资源文件夹下创键file_paths.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//每个节点都支持两个属性：name+path</span><br><span class="line">//path：需要临时授权访问的路径（.代表所有路径） </span><br><span class="line">//name：就是你给这个访问路径起个名字</span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">paths</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root-path</span> <span class="attr">name</span>=<span class="string">"root"</span> <span class="attr">path</span>=<span class="string">""</span> /&gt;</span> //代表设备的根目录new File("/");</span><br><span class="line">    <span class="tag">&lt;<span class="name">files-path</span> <span class="attr">name</span>=<span class="string">"files"</span> <span class="attr">path</span>=<span class="string">""</span> /&gt;</span> //context.getFilesDir()</span><br><span class="line">    <span class="tag">&lt;<span class="name">cache-path</span> <span class="attr">name</span>=<span class="string">"cache"</span> <span class="attr">path</span>=<span class="string">""</span> /&gt;</span> //context.getCacheDir()</span><br><span class="line">    <span class="tag">&lt;<span class="name">external-path</span> <span class="attr">name</span>=<span class="string">"external"</span> <span class="attr">path</span>=<span class="string">""</span> /&gt;</span> //Environment.getExternalStorageDirectory()</span><br><span class="line">    <span class="tag">&lt;<span class="name">external-files-path</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">path</span>=<span class="string">"path"</span> /&gt;</span> //context.getExternalFilesDirs()</span><br><span class="line">    <span class="tag">&lt;<span class="name">external-cache-path</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">path</span>=<span class="string">"path"</span> /&gt;</span> //getExternalCacheDirs()</span><br><span class="line"><span class="tag">&lt;/<span class="name">paths</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;</span><br><span class="line">    Uri uri = FileProvider.getUriForFile(CameraActivity.<span class="keyword">this</span>, <span class="string">"app的包名.fileProvider"</span>, photoFile);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Uri uri = Uri.fromFile(photoFile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过这样的包装形成uri:<code>content://app的包名/files/path/文件</code> 就可以匹配到具体实际路径了</p><h3 id="访问应用数据"><a href="#访问应用数据" class="headerlink" title="访问应用数据"></a>访问应用数据</h3><p>android 的许多数据都可以获得，但是要申请权限</p><p>比如：通讯录，短信，各种类别的文件</p><h4 id="准备uri"><a href="#准备uri" class="headerlink" title="准备uri"></a>准备uri</h4><p>api的类一般都会暴露uri，比如：<code>MediaStore.Files.getContentUri(&quot;external&quot;)</code> </p><h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">context.getContentResolver().query();</span><br><span class="line">context.getContentResolver().insert();</span><br><span class="line">context.getContentResolver().delete();</span><br><span class="line">context.getContentResolver().update();</span><br></pre></td></tr></table></figure><p>就和操作数据库一样，因为内容提供器本身就是相当于包装了一层数据库访问操作。</p><h3 id="自定义内容提供器"><a href="#自定义内容提供器" class="headerlink" title="自定义内容提供器"></a>自定义内容提供器</h3><h4 id="自然还是要Manifest声明"><a href="#自然还是要Manifest声明" class="headerlink" title="自然还是要Manifest声明"></a>自然还是要Manifest声明</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:name</span>=<span class="string">".provider.MyContentProvider"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:authorities</span>=<span class="string">"com.my.demo.provider"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:enabled</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:exported</span>=<span class="string">"true"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h4 id="继承实现"><a href="#继承实现" class="headerlink" title="继承实现"></a>继承实现</h4><p>感觉是固定代码，内部访问数据库</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.hujie2.filepersistencetest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.ContentProvider;</span><br><span class="line"><span class="keyword">import</span> android.content.ContentValues;</span><br><span class="line"><span class="keyword">import</span> android.content.UriMatcher;</span><br><span class="line"><span class="keyword">import</span> android.database.Cursor;</span><br><span class="line"><span class="keyword">import</span> android.database.sqlite.SQLiteDatabase;</span><br><span class="line"><span class="keyword">import</span> android.net.Uri;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseContentProvider</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BOOK_DIR = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BOOK_ITEM = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CATEGORY_DIR = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CATEGORY_ITEM = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTHORITY = <span class="string">"com.example.hujie2.filepersistencetest.provider"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> UriMatcher uriMatcher;</span><br><span class="line">    <span class="keyword">private</span>  MyDatabaseHelper dbHelper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//uri匹配</span></span><br><span class="line">        uriMatcher = <span class="keyword">new</span> UriMatcher(UriMatcher.NO_MATCH);</span><br><span class="line">        uriMatcher.addURI(AUTHORITY, <span class="string">"book"</span>, BOOK_DIR);</span><br><span class="line">        uriMatcher.addURI(AUTHORITY, <span class="string">"book/#"</span>, BOOK_ITEM);</span><br><span class="line">        uriMatcher.addURI(AUTHORITY, <span class="string">"category"</span>, CATEGORY_DIR);</span><br><span class="line">        uriMatcher.addURI(AUTHORITY, <span class="string">"category/#"</span>, CATEGORY_ITEM);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DatabaseContentProvider</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获得数据库辅助类对象</span></span><br><span class="line">        dbHelper = <span class="keyword">new</span> MyDatabaseHelper(getContext(), <span class="string">"BookStore.db"</span>, <span class="keyword">null</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(Uri uri, String[] projection, String selection,</span></span></span><br><span class="line"><span class="function"><span class="params">                        String[] selectionArgs, String sortOrder)</span> </span>&#123;</span><br><span class="line">        SQLiteDatabase db = dbHelper.getReadableDatabase();</span><br><span class="line">        Cursor cursor = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (uriMatcher.match(uri)) &#123;</span><br><span class="line">            <span class="keyword">case</span> BOOK_DIR:</span><br><span class="line">                cursor = db.query(<span class="string">"book"</span>, projection, selection, selectionArgs, <span class="keyword">null</span>, <span class="keyword">null</span>, sortOrder);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BOOK_ITEM:</span><br><span class="line">                String bookId = uri.getPathSegments().get(<span class="number">1</span>);</span><br><span class="line">                cursor = db.query(<span class="string">"book"</span>, projection, <span class="string">"id = ?"</span>, <span class="keyword">new</span> String[]&#123;bookId&#125;, <span class="keyword">null</span>, <span class="keyword">null</span>, sortOrder);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CATEGORY_DIR:</span><br><span class="line">                cursor = db.query(<span class="string">"category"</span>, projection, selection, selectionArgs, <span class="keyword">null</span>, <span class="keyword">null</span>, sortOrder);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CATEGORY_ITEM:</span><br><span class="line">                String categoryId = uri.getPathSegments().get(<span class="number">1</span>);</span><br><span class="line">                cursor = db.query(<span class="string">"category"</span>, projection, <span class="string">"id = ?"</span>, <span class="keyword">new</span> String[]&#123;categoryId&#125;, <span class="keyword">null</span>, <span class="keyword">null</span>, sortOrder);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cursor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri, ContentValues values)</span> </span>&#123;</span><br><span class="line">        SQLiteDatabase db = dbHelper.getWritableDatabase();</span><br><span class="line">        Uri uriReturn = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (uriMatcher.match(uri)) &#123;</span><br><span class="line">            <span class="keyword">case</span> BOOK_DIR:</span><br><span class="line">            <span class="keyword">case</span> BOOK_ITEM:</span><br><span class="line">                <span class="keyword">long</span> newBookId = db.insert(<span class="string">"book"</span>, <span class="keyword">null</span>, values);</span><br><span class="line">                uriReturn = Uri.parse(<span class="string">"content://"</span> + AUTHORITY + <span class="string">"/book/"</span> + newBookId);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CATEGORY_DIR:</span><br><span class="line">            <span class="keyword">case</span> CATEGORY_ITEM:</span><br><span class="line">                <span class="keyword">long</span> newCategoryId = db.insert(<span class="string">"category"</span>, <span class="keyword">null</span>, values);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uriReturn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Uri uri, ContentValues values, String selection,</span></span></span><br><span class="line"><span class="function"><span class="params">                      String[] selectionArgs)</span> </span>&#123;</span><br><span class="line">        SQLiteDatabase db = dbHelper.getWritableDatabase();</span><br><span class="line">        <span class="keyword">int</span> updatedRows = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span> (uriMatcher.match(uri)) &#123;</span><br><span class="line">            <span class="keyword">case</span> BOOK_DIR:</span><br><span class="line">                updatedRows = db.update(<span class="string">"book"</span>, values, selection, selectionArgs);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BOOK_ITEM:</span><br><span class="line">                String bookId = uri.getPathSegments().get(<span class="number">1</span>);</span><br><span class="line">                updatedRows = db.update(<span class="string">"book"</span>, values, <span class="string">"id = ?"</span>, <span class="keyword">new</span> String[]&#123;bookId&#125;);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CATEGORY_DIR:</span><br><span class="line">                updatedRows = db.update(<span class="string">"category"</span>, values, selection, selectionArgs);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CATEGORY_ITEM:</span><br><span class="line">                String categoryId = uri.getPathSegments().get(<span class="number">1</span>);</span><br><span class="line">                updatedRows = db.update(<span class="string">"category"</span>, values, <span class="string">"id = ?"</span>, <span class="keyword">new</span> String[]&#123;categoryId&#125;);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> updatedRows;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(Uri uri, String selection, String[] selectionArgs)</span> </span>&#123;</span><br><span class="line">        SQLiteDatabase db = dbHelper.getWritableDatabase();</span><br><span class="line">        <span class="keyword">int</span> deletedRows = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span> (uriMatcher.match(uri)) &#123;</span><br><span class="line">            <span class="keyword">case</span> BOOK_DIR:</span><br><span class="line">                deletedRows = db.delete(<span class="string">"book"</span>, selection, selectionArgs);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BOOK_ITEM:</span><br><span class="line">                String bookId = uri.getPathSegments().get(<span class="number">1</span>);</span><br><span class="line">                deletedRows = db.delete(<span class="string">"book"</span>, <span class="string">"id = ?"</span>, <span class="keyword">new</span> String[]&#123;bookId&#125;);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CATEGORY_DIR:</span><br><span class="line">                deletedRows = db.delete(<span class="string">"category"</span>, selection, selectionArgs);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CATEGORY_ITEM:</span><br><span class="line">                String categoryId = uri.getPathSegments().get(<span class="number">1</span>);</span><br><span class="line">                deletedRows = db.delete(<span class="string">"category"</span>, <span class="string">"id = ?"</span>, <span class="keyword">new</span> String[]&#123;categoryId&#125;);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deletedRows;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(Uri uri)</span> </span>&#123;</span><br><span class="line">        String vndDir = <span class="string">"vnd.android.cursor.dir/"</span>;</span><br><span class="line">        String vndItem = <span class="string">"vnd.android.cursor.item/"</span>;</span><br><span class="line">        <span class="keyword">switch</span> (uriMatcher.match(uri)) &#123;</span><br><span class="line">            <span class="keyword">case</span> BOOK_DIR:</span><br><span class="line">                <span class="keyword">return</span> vndDir + <span class="string">"vnd."</span> + AUTHORITY + <span class="string">".book"</span>;</span><br><span class="line">            <span class="keyword">case</span> BOOK_ITEM:</span><br><span class="line">                <span class="keyword">return</span> vndItem + <span class="string">"vnd."</span> + AUTHORITY + <span class="string">".book"</span>;</span><br><span class="line">            <span class="keyword">case</span> CATEGORY_DIR:</span><br><span class="line">                <span class="keyword">return</span> vndDir + <span class="string">"vnd."</span> + AUTHORITY + <span class="string">".category"</span>;</span><br><span class="line">            <span class="keyword">case</span> CATEGORY_ITEM:</span><br><span class="line">                <span class="keyword">return</span> vndItem + <span class="string">"vnd."</span> + AUTHORITY + <span class="string">".category"</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Handler消息机制梳理</title>
      <link href="/2019/07/07/Android-%E5%85%B3%E4%BA%8EHandler%E7%AD%89/"/>
      <url>/2019/07/07/Android-%E5%85%B3%E4%BA%8EHandler%E7%AD%89/</url>
      
        <content type="html"><![CDATA[<h3 id="what"><a href="#what" class="headerlink" title="what"></a>what</h3><p>在Android开发中，Hanldler消息机制可以说无处不在，主线程的调度，View，任务提交，IntentService，Messager中都出现了，可谓无处不在。handler消息发挥作用的包含了：Handler，Looper，Message，MessagerQueue，这四个重要组成。Handler发送消息，Looper开启轮询从MessageQueue中获取消息，交由Handler处理。</p><h3 id="how"><a href="#how" class="headerlink" title="how"></a>how</h3><p>还是从一个使用者角度先了解，具体怎么用Handler吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Handler mHandler = <span class="keyword">new</span> Handler(Looper.getMainLooper())&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    doSomeThing();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    doSomeThing();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mHandler.sendEmptyMessage(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创键Handler对象，传入Looper，发送消息。再Hanlder内部处理消息，当然还可以直接发送Runnable，或者加入延时等。用法就这么简单。下面还是具体介绍吧</p><a id="more"></a><h3 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h3><p>可以发送消息和处理消息，可以有很多个实例，具体根据消息来分辨处理。</p><p>它的成员包括了Looper，MessageQueue，Callback</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常用api，以及加上延时等</span></span><br><span class="line">post(Runnable);<span class="comment">//提交任务</span></span><br><span class="line">sendMessage(Message);<span class="comment">//提交消息</span></span><br><span class="line">handleMessage(Message);<span class="comment">//处理消息</span></span><br></pre></td></tr></table></figure><p>一般使用Handler有两种方法，一般是需要传入Looper，如果不则默认传入当前线程的Looper</p><ul><li>扩展Handler，重写handleMessage</li><li>传入回调，回调也只需要实现handleMessage</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最终被调用的构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper, Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">        mLooper = looper;<span class="comment">//looper</span></span><br><span class="line">        mQueue = looper.mQueue;<span class="comment">//looper的messagequeue</span></span><br><span class="line">        mCallback = callback;<span class="comment">//回调形式处理消息</span></span><br><span class="line">        mAsynchronous = async;<span class="comment">//开启发送异步消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h3><p>这个的话管他叫轮询，反正是有循环的意思。首先它是一个ThreadLocal变量，保证了每个线程间独立运行，再而它的话就是从消息队列中取出消息，转交到Handler处理</p><p>它的成员包括了ThreadLocal，MessageQueue，Thread。</p><p>看下重要api</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">prepare();<span class="comment">//获取线程本地Looper实例</span></span><br><span class="line">loop();<span class="comment">//进入轮询</span></span><br><span class="line">quit();<span class="comment">//退出</span></span><br><span class="line">getMainLooper();<span class="comment">//获得主线程Looper</span></span><br></pre></td></tr></table></figure><h3 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h3><p>封装了消息码，触发时机，runnable，目标handler的消息，内部是一个长度50不断复用的消息池（链表结构），消息分为异步和同步</p><p>看下重要api</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Message.obtain();<span class="comment">//从池里获得消息</span></span><br></pre></td></tr></table></figure><h3 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h3><p>尾插法实现的消息链表，异步消息优先出，称之为消息队列，但是不是那个操作系统的消息队列啊。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">next();<span class="comment">//拿取消息</span></span><br><span class="line">quit();<span class="comment">//退出</span></span><br><span class="line">enqueueMessage();<span class="comment">//入消息</span></span><br></pre></td></tr></table></figure><h3 id="从源码来角度再探析"><a href="#从源码来角度再探析" class="headerlink" title="从源码来角度再探析"></a>从源码来角度再探析</h3><p>本来向从主线程来分析的，但是好像不怎么完整，那就用HandlerTread来分析吧，这个就非常完整了</p><h4 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h4><p>首先这是一个Thread，内部实现了Handler消息机制，即可以通过Handler来进行提交任务和消息到线程中运行。</p><p>先看下是怎么用的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HandlerThread handlerThread = <span class="keyword">new</span> HandlerThread(<span class="string">"test"</span>);<span class="comment">//创键HandlerThread</span></span><br><span class="line">handlerThrad.start();<span class="comment">//开启线程</span></span><br><span class="line">Handler handler = <span class="keyword">new</span> Handler(handlerThread.getLooper());<span class="comment">//关联Handler</span></span><br><span class="line">handler.post(()-&gt; System.out.println(<span class="string">"run1"</span>));<span class="comment">//提交任务或者消息</span></span><br><span class="line">handler.sendEmptyMessage(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>用就是这么用的。原理就是handler提交消息，HandlerThread线程开启轮询，分发消息，处理。</p><p>接下来就可以分析源码了：</p><h4 id="HandlerThread构造"><a href="#HandlerThread构造" class="headerlink" title="HandlerThread构造"></a>HandlerThread构造</h4><p>首先进入HandlerThread构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HandlerThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        mPriority = Process.THREAD_PRIORITY_DEFAULT;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HandlerThread</span><span class="params">(String name, <span class="keyword">int</span> priority)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        mPriority = priority;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//就起了个名字而已</span></span><br></pre></td></tr></table></figure><h4 id="HandlerThread进入run"><a href="#HandlerThread进入run" class="headerlink" title="HandlerThread进入run"></a>HandlerThread进入run</h4><p>接着线程开启进入run方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HandlerThread.run</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mTid = Process.myTid();<span class="comment">//获取进程PID</span></span><br><span class="line">    Looper.prepare();<span class="comment">//Looper准备</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        mLooper = Looper.myLooper();<span class="comment">//获取Looper</span></span><br><span class="line">        notifyAll();<span class="comment">//唤醒</span></span><br><span class="line">    &#125;</span><br><span class="line">    Process.setThreadPriority(mPriority);</span><br><span class="line">    onLooperPrepared();<span class="comment">//回掉</span></span><br><span class="line">    Looper.loop();<span class="comment">//进入Looper轮询</span></span><br><span class="line">    mTid = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在run方法中等于说准备looper，进入轮询</p><h4 id="准备Looper"><a href="#准备Looper" class="headerlink" title="准备Looper"></a>准备Looper</h4><p>接着看下如何准备Looper和获得Looper的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Looper.prepare</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));<span class="comment">//创键本线程的Looper</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里就是入准备本线程的Looper</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Looper.myLooper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sThreadLocal.get();<span class="comment">//获得</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="进入Looper轮询"><a href="#进入Looper轮询" class="headerlink" title="进入Looper轮询"></a>进入Looper轮询</h4><p>接下就是重头戏了，进入轮询，挑关键代码看看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Looper.loop</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Looper me = myLooper();<span class="comment">//获取looper</span></span><br><span class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;<span class="comment">//获取MessageQueue</span></span><br><span class="line">    <span class="comment">//...省略</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Message msg = queue.next(); <span class="comment">// might block，从消息队列中获取消息，也许阻塞</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">            <span class="keyword">return</span>;<span class="comment">//没有消息则代表队列退出了</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//...省略</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            msg.target.dispatchMessage(msg);<span class="comment">//交由给Handler分发消息</span></span><br><span class="line">            dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">                Trace.traceEnd(traceTag);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//...省略</span></span><br><span class="line">        msg.recycleUnchecked();<span class="comment">//回收消息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个过程也还好理解，开启死循环，从消息队列中不断的拿去消息，然后由消息目标 handler进行分发处理。</p><p>接下我先看简单的handler如何分发处理消息的。待会再看如何获取消息的</p><h4 id="消息处理"><a href="#消息处理" class="headerlink" title="消息处理"></a>消息处理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Handler.dispatchMessage</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//看消息本省是否有回掉处理，额，这个callback类型其实是Runnable，其实就是看看这个消息是不是Runnable类型</span></span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;<span class="comment">//交由创键回调handleMessage的处理消息，也就实现的handleMessage</span></span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);<span class="comment">//交由本省的handleMessage处理，也就是扩展的handleMessage</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">    message.callback.run();<span class="comment">//直接调用runnable的run方法，完成提交任务的run</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分发消息比较简单，首先判断这个消息是否是Runnable类型，是则直接调run，不是的在看是由本身的handleMessage处理还是回调的handleMessage处理。</p><h4 id="取出消息"><a href="#取出消息" class="headerlink" title="取出消息"></a>取出消息</h4><p>接着就看如何获取消息的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MessageQueue.next</span></span><br><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Return here if the message loop has already quit and been disposed.</span></span><br><span class="line">    <span class="comment">// This can happen if the application tries to restart a looper after quit</span></span><br><span class="line">    <span class="comment">// which is not supported.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;<span class="comment">//循环去拿出合适时机消息</span></span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line">   <span class="comment">//Linux的管道基础上的，空闲等待nextPollTimeoutMillis，和传统的阻塞不一样，</span></span><br><span class="line">        <span class="comment">//nextPollTimeoutMillis这个时间则是消息延时时间</span></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">            Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">            Message msg = mMessages;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());<span class="comment">//优先出异步消息</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                    <span class="comment">//消息没有准备好运行，设定了延时执行，计算出延时时间，空闲等待</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//消息准备好了，出消息</span></span><br><span class="line">                    <span class="comment">// Got a message.</span></span><br><span class="line">                    mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Returning message: "</span> + msg);</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="keyword">return</span> msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// No more messages.没有消息</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process the quit message now that all pending messages have been handled.</span></span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                dispose();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...省略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MessageQueue中next中进入死循环获取消息，从队列中去拿去消息，遍历队列消息，队列的消息是按照执行时刻从小到大排列的，根据当前时刻取出该执行的消息（优先取异步消息），如果时机未到则会进入空闲等待(基于linux的管道)。等到了时机则会取出消息。</p><p>这一路下来从Looper轮询，消息取出，消息执行的步骤。</p><p>接下看看是如何提交消息的</p><h4 id="构建消息"><a href="#构建消息" class="headerlink" title="构建消息"></a>构建消息</h4><p>构建消息，首先从消息复用池拿去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Message.obtain</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//链表咯</span></span><br><span class="line">            Message m = sPool;</span><br><span class="line">            sPool = m.next;</span><br><span class="line">            m.next = <span class="keyword">null</span>;</span><br><span class="line">            m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></span><br><span class="line">            sPoolSize--;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Message();<span class="comment">//池为空则新建</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="提交消息"><a href="#提交消息" class="headerlink" title="提交消息"></a>提交消息</h4><p>接着Handler提交消息，无论是runnable消息，或者空消息，或者其它的消息，或者带延时的，最终sendMessageAtTime</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Handler.sendMessageAtTime</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">        MessageQueue queue = mQueue;</span><br><span class="line">        <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</span><br><span class="line">            Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);<span class="comment">//入消息队列</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="消息入队列"><a href="#消息入队列" class="headerlink" title="消息入队列"></a>消息入队列</h4><p>接着就是进入消息队列，执行时刻小的在前插入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;<span class="comment">//如果退出</span></span><br><span class="line">            IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</span><br><span class="line">            Log.w(TAG, e.getMessage(), e);</span><br><span class="line">            msg.recycle();<span class="comment">//回收</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">// New head, wake up the event queue if blocked. 新建链表头</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Inserted within the middle of the queue.  Usually we don't have to wake</span></span><br><span class="line">            <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">            <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;<span class="comment">//找到合适的位置，保证时刻顺序</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next 插入</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>差不多流程就是这样了。这个例子使用HandlerThread做示范的，UI主线程同样也是使用这样的实现的。</p><h3 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h3><p>内部实现HandlerThread的Servcie，开启子线程执行，代码比较简单直接截下来了，构建HandlerThread，Handler，在onStartCommand中发送消息，并最终在onHandleIntent响应执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">IntentService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Looper mServiceLooper;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ServiceHandler mServiceHandler;</span><br><span class="line">    <span class="keyword">private</span> String mName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mRedelivery;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ServiceHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(looper);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            onHandleIntent((Intent)msg.obj);<span class="comment">//调用</span></span><br><span class="line">            stopSelf(msg.arg1);<span class="comment">//结束servcie</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IntentService</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        mName = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIntentRedelivery</span><span class="params">(<span class="keyword">boolean</span> enabled)</span> </span>&#123;</span><br><span class="line">        mRedelivery = enabled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        HandlerThread thread = <span class="keyword">new</span> HandlerThread(<span class="string">"IntentService["</span> + mName + <span class="string">"]"</span>);<span class="comment">//构建</span></span><br><span class="line">        thread.start();<span class="comment">//开启</span></span><br><span class="line"></span><br><span class="line">        mServiceLooper = thread.getLooper();</span><br><span class="line">        mServiceHandler = <span class="keyword">new</span> ServiceHandler(mServiceLooper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(@Nullable Intent intent, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">        Message msg = mServiceHandler.obtainMessage();</span><br><span class="line">        msg.arg1 = startId;</span><br><span class="line">        msg.obj = intent;</span><br><span class="line">        mServiceHandler.sendMessage(msg);<span class="comment">//发送</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(@Nullable Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">        onStart(intent, startId);</span><br><span class="line">        <span class="keyword">return</span> mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mServiceLooper.quit();<span class="comment">//退出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@WorkerThread</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(@Nullable Intent intent)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>梳理一波Service</title>
      <link href="/2019/07/06/Android-%E6%A2%B3%E7%90%86%E4%B8%80%E6%B3%A2Service/"/>
      <url>/2019/07/06/Android-%E6%A2%B3%E7%90%86%E4%B8%80%E6%B3%A2Service/</url>
      
        <content type="html"><![CDATA[<h2 id="what"><a href="#what" class="headerlink" title="what"></a>what</h2><p>Android 四大组件之一，名为服务，可见与activity具有同等地位，看名字也只到，服务嘛，一般用于提供进行UI无关的等任务操作。和activity存在不一样，这家伙的存在是可以说是无声无息，甚至在有些流氓的软件中，你关掉了app，那还不一定关掉了服务[捂脸] ，不过这也正突出了service的特点，后台。开始知道是用来进行后台任务就行了，看看怎么用吧。</p><blockquote><p><code>Service</code> 是一个可以在后台执行长时间运行操作而不提供用户界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。 此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信 (IPC)。 例如，服务可以处理网络事务、播放音乐，执行文件 I/O 或与内容提供程序交互，而所有这一切均可在后台进行。</p></blockquote><p>google爸爸说的好条理哦</p><p><code>特别：Service默认也是在主线程进行的。所以也会有ANR风险。</code></p><a id="more"></a><h2 id="how"><a href="#how" class="headerlink" title="how"></a>how</h2><h3 id="定义一个服务"><a href="#定义一个服务" class="headerlink" title="定义一个服务"></a>定义一个服务</h3><h4 id="继承Service"><a href="#继承Service" class="headerlink" title="继承Service"></a>继承Service</h4><p>首先的肯定是要继承一个Service的咯</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span><span class="comment">//服务被第一次创建调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span><span class="comment">//被调用服务调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span><span class="comment">//销毁时调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span><span class="comment">//绑定时调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Manifest声明"><a href="#Manifest声明" class="headerlink" title="Manifest声明"></a>Manifest声明</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">android:enabled</span>=<span class="string">[</span>"<span class="attr">true</span>" | "<span class="attr">false</span>"]</span></span><br><span class="line"><span class="tag">         <span class="attr">android:exported</span>=<span class="string">[</span>"<span class="attr">true</span>" | "<span class="attr">false</span>"]</span></span><br><span class="line"><span class="tag">         <span class="attr">android:icon</span>=<span class="string">"drawable resource"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:isolatedProcess</span>=<span class="string">[</span>"<span class="attr">true</span>" | "<span class="attr">false</span>"]</span></span><br><span class="line"><span class="tag">         <span class="attr">android:label</span>=<span class="string">"string resource"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:name</span>=<span class="string">"string"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:permission</span>=<span class="string">"string"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:process</span>=<span class="string">"string"</span> &gt;</span></span><br><span class="line">    . . .</span><br><span class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="开启服务"><a href="#开启服务" class="headerlink" title="开启服务"></a>开启服务</h3><p>嗯，Intent又来了，哈哈，在持有context的地方调用，既然是用Intent，自然servie的也会有Intent-Filter标签来过滤。不过好像从来没用过类似activity的隐式启动，google发现原来是5.0以上就不允许。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(context, TestService.class);</span><br><span class="line">context.startService(intent);</span><br></pre></td></tr></table></figure><p>首先的话必然先调用onCreate，然后就是onStartCommmand，这个服务就算是开启了，活了。后面再startService也只会调用onStartCommand了。</p><h3 id="停止服务"><a href="#停止服务" class="headerlink" title="停止服务"></a>停止服务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种，通过context关闭</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(context, TestService.class);</span><br><span class="line">context.stopservcie(intent);</span><br><span class="line"><span class="comment">//第二种，在servie内部停止</span></span><br><span class="line">stopSelf();</span><br></pre></td></tr></table></figure><p>停止服务后系统会尽快销毁服务，当然也就会调用onDestroy咯</p><h3 id="服务交互–绑定服务"><a href="#服务交互–绑定服务" class="headerlink" title="服务交互–绑定服务"></a>服务交互–绑定服务</h3><p>好像之前使用开启服务和关闭服务，调用者和服务基本没什么耦合关系。各走各路了呃呃。为了能够保持调用者和服务之间的交互。使用<code>绑定服务</code>，这也是开启服务的另一种方式，话句话说通过绑定的方式来开启服务。这就要用到onBind的方法了。</p><h4 id="绑定本地服务"><a href="#绑定本地服务" class="headerlink" title="绑定本地服务"></a>绑定本地服务</h4><h5 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h5><p>除了基本的使用扩展Binder，或者使用Messenger，AIDL（其实也是Binder，233）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;<span class="comment">//被绑定时调用</span></span><br><span class="line">        <span class="comment">//需要给出一个Binder对象，具体怎么给，都可以，内部类，匿名对象，只要是Binder就行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyBinder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyBinder</span> <span class="keyword">extends</span> <span class="title">Binder</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someActionA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"do some action A"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someActionB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"do some actin B"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h5><p>准备ServiceConnection，发起绑定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> MyBinder mMyBinder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServiceConnection mServiceConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"on connected"</span>);</span><br><span class="line">            mMyBinder = (MyBinder) service;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"on disconnected"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">toBindService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(context, TestService.class);</span><br><span class="line">        context.bindService(intent, mServiceConnection, flag);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//过程为toBindService --&gt; onBinder --&gt; onServiceConnected</span></span><br></pre></td></tr></table></figure><p>通过这样的方法我们就能够拿到一个Binder对象，或者其它东西，这样就算和Service建立起了交互</p><h5 id="取消绑定"><a href="#取消绑定" class="headerlink" title="取消绑定"></a>取消绑定</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unBindService(serviceConnection);</span><br></pre></td></tr></table></figure><p><strong>Flag</strong> ： 关于绑定服务的Flag</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BIND_AUTO_CREATE,<span class="comment">//若绑定服务时服务未启动，则会自动启动服务。 注意，这种情况下服务的onStartCommand,仍然未被调用（它只会在显式调用startService时才会被调用）。</span></span><br><span class="line">BIND_DEBUG_UNBIND,<span class="comment">//使用此标志绑定服务之后的unBindService方法会无效。 这种方法会引起内存泄露，只能在调试时使用。</span></span><br><span class="line">BIND_NOT_FOREGROUND,<span class="comment">//被绑定的服务进程优先级不允许被提到FOREGROUND级别</span></span><br><span class="line">BIND_ABOVE_CLIENT,<span class="comment">//服务比app重要，oom移除killer杀死service前杀死app</span></span><br><span class="line">BIND_ALLOW_OOM_MANAGEMENT,</span><br><span class="line">BIND_WAIVE_PRIORITY,<span class="comment">//被绑定的服务进程不会被OOM列入猎杀对象中。</span></span><br><span class="line">BIND_IMPORTANT,<span class="comment">//被绑定的服务进程优先级会被提到FOREGROUND级别</span></span><br><span class="line">BIND_ADJUST_WITH_ACTIVITY<span class="comment">//允许activity调整重要性</span></span><br></pre></td></tr></table></figure><p>一般使用第一个咯，这里我收集到的翻译的不明确，还是具体参看<code>Context.java</code>源码的英文注释</p><h4 id="绑定远程服务"><a href="#绑定远程服务" class="headerlink" title="绑定远程服务"></a>绑定远程服务</h4><p>也就是IPC，在android 系统中很多服务都是可以直接跨进程调用的，而这些服务也都是由某些组件应用提供的。通过绑定远程的服务可以调用其它的功能，比如蓝牙，wifi等等。进程间通信，这个我放在单独的IPC后面详细归纳</p><ul><li>Messenger</li><li>AIDL</li></ul><h3 id="前台服务"><a href="#前台服务" class="headerlink" title="前台服务"></a>前台服务</h3><p>这个算是用户主动意识到的一种服务，<code>即使内存不足，也不会考虑终止</code>，优先级很高，其实说白点了，就是一个普通的服务通过开启通知栏的形式，讲明了服务在运行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创键通知</span></span><br><span class="line">Notification notification = <span class="keyword">new</span> Notification(R.drawable.icon, getText(R.string.ticker_text),</span><br><span class="line">        System.currentTimeMillis());</span><br><span class="line">Intent notificationIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, ExampleActivity.class);</span><br><span class="line">PendingIntent pendingIntent = PendingIntent.getActivity(<span class="keyword">this</span>, <span class="number">0</span>, notificationIntent, <span class="number">0</span>);</span><br><span class="line">notification.setLatestEventInfo(<span class="keyword">this</span>, getText(R.string.notification_title),</span><br><span class="line">        getText(R.string.notification_message), pendingIntent);</span><br><span class="line"><span class="comment">//服务开启前台，并且关联通知</span></span><br><span class="line">startForeground(ONGOING_NOTIFICATION_ID, notification);</span><br></pre></td></tr></table></figure><h3 id="Intent服务"><a href="#Intent服务" class="headerlink" title="Intent服务"></a>Intent服务</h3><h5 id="what-1"><a href="#what-1" class="headerlink" title="what"></a>what</h5><p>类：IntentService，通过扩展这个类实现的服务，里面操作会在子线程中进行。而且不需要手动关闭服务，它自己就会关闭。那么看看怎么用吧</p><h5 id="how-1"><a href="#how-1" class="headerlink" title="how"></a>how</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloIntentService</span> <span class="keyword">extends</span> <span class="title">IntentService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * A constructor is required, and must call the super IntentService(String)</span></span><br><span class="line"><span class="comment">   * constructor with a name for the worker thread.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HelloIntentService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(<span class="string">"HelloIntentService"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The IntentService calls this method from the default worker thread with</span></span><br><span class="line"><span class="comment">   * the intent that started the service. When this method returns, IntentService</span></span><br><span class="line"><span class="comment">   * stops the service, as appropriate.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Normally we would do some work here, like download a file.</span></span><br><span class="line">      <span class="comment">// For our sample, we just sleep for 5 seconds.</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          <span class="comment">// Restore interrupt status.</span></span><br><span class="line">          Thread.currentThread().interrupt();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开启服务还是和普通的没区别，但是所有的操作可以在<code>onHandleIntent</code>中响应。而且此时这个方法内就是子线程了。还不用关心服务停止</p><h5 id="why"><a href="#why" class="headerlink" title="why"></a>why</h5><p>那么为啥IntentService有这么大魔力呢，子线程，自带关闭，其实原理很简单，内部维护了简单的Looper和Handler操作（关于Handler和IntentService原理下次一起详细归纳下），使得所有的从onStartCommand的操作进入了一个HandlerThread中，然后每次调用都向提交任务给线程。最后也会执行完也会停止自己。</p><h3 id="远程服务"><a href="#远程服务" class="headerlink" title="远程服务"></a>远程服务</h3><p>在service配置声明中有一个属性<code>process</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">android:process</span>=<span class="string">":remote"</span> <span class="attr">android:enable</span>=<span class="string">"true"</span> <span class="attr">andorid:exported</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>这样在运行的时候，这个service就和本应用位于不同的进程中了，那么就轮到IPC上场了。对咯，既然是IPC了，原来的开启服务的方式就行不通，那就的用AIDL咯</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><p>小心ANR:常态下Service的代码是运行在主线程滴</p></li><li><p>不要过多的实现代码在这里，要把服务看成一个后台任务调用代理。。</p></li><li><p>关于onStartCommand返回值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//该返回值描述了在杀死事件中如何继续这个服务</span><br><span class="line">START_NOT_STICKY</span><br><span class="line">杀死后不会重启</span><br><span class="line">START_STICKY</span><br><span class="line">杀死后会重启，但是第一次启动的startCommand()的Intent为null</span><br><span class="line">START_REDELIVER_INTENT</span><br><span class="line">杀死后会重启，并且会重传Intent</span><br></pre></td></tr></table></figure></li></ul><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>普通启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">call to start service</span><br><span class="line">|</span><br><span class="line">onCreate</span><br><span class="line">|</span><br><span class="line">onStartCommand</span><br><span class="line">|</span><br><span class="line">service is running</span><br><span class="line">|</span><br><span class="line">onDestory</span><br><span class="line">|</span><br><span class="line">service shut down</span><br></pre></td></tr></table></figure><p>绑定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">call to bind servie</span><br><span class="line">|</span><br><span class="line">onCreate</span><br><span class="line">|</span><br><span class="line">onBind</span><br><span class="line">|</span><br><span class="line">client are bound to servcie</span><br><span class="line">|</span><br><span class="line">onUnbind</span><br><span class="line">|</span><br><span class="line">onDesotry</span><br><span class="line">|</span><br><span class="line">service shut down</span><br></pre></td></tr></table></figure><p>onStartCommand一定是在调用startServie才会调用的。即使是绑定服务，也不会调用它的。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>梳理一波Activity基础使用</title>
      <link href="/2019/07/03/Android-%E6%A2%B3%E7%90%86%E4%B8%80%E6%B3%A2Activity/"/>
      <url>/2019/07/03/Android-%E6%A2%B3%E7%90%86%E4%B8%80%E6%B3%A2Activity/</url>
      
        <content type="html"><![CDATA[<h2 id="what"><a href="#what" class="headerlink" title="what"></a>what</h2><p>首先初学android第一个学的绝逼是Activity，翻译为活动，即看的见，摸得着的玩意。android SDK提供了一套模板类即Activity，开发者需要继承它，并且在对的时间做相应的事情，比如UI初始化，数据加载等等，通过在Manifest文件中声明这个新的Activity就可以了。这次就先不探讨Activity是怎么工作的，从应用的角度来看看它，（AMS还得再学习学习2333）。</p><h2 id="how"><a href="#how" class="headerlink" title="how"></a>how</h2><p>无非就是创建类然后实现Activity，然后注册到Manifest中。可以了。</p><p>主要来看看Activity中重要的API吧。</p><a id="more"></a><h3 id="首先看看Activity继承结构。"><a href="#首先看看Activity继承结构。" class="headerlink" title="首先看看Activity继承结构。"></a>首先看看Activity继承结构。</h3><ul><li><p>AppCompatActivity ：目前来说默认AS创建的Activity继承自AppcompatActivity,直接意思兼容的Activity咯，支持ActionBar,同时对MD控件提供支持。</p></li><li><p>FragmentActivity：支持Fagment使用的Activity，因为3.0之前是没有Fragmnt，所以为了兼容引入。</p></li><li><p>Activity：原汁原味的。。</p></li></ul><h3 id="接着看看日常必须用得到方法"><a href="#接着看看日常必须用得到方法" class="headerlink" title="接着看看日常必须用得到方法"></a>接着看看日常必须用得到方法</h3><ul><li><p>生命周期方法，放在下面好了。</p></li><li><p>setSupportActionBar和getSupportActionBar，进去ToolBar,出来AcionBar,工具栏相关的者两个一定得用</p></li><li><p>onConfigurationChanged，配置发生改变，就会回调这里。再Manifest中activity的配置中要设定关心那些变化</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">""</span> <span class="attr">android:configChanges</span>=<span class="string">"orientation|keyboard"</span>/&gt;</span></span><br><span class="line">横竖屏切换，键盘等等</span><br></pre></td></tr></table></figure></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">onSaveInstanceState 和 onRestoreInstanceState 保存和恢复当前的某些状态和数据</span><br><span class="line">内存回收后重新创建Activty，可以传递Bundle</span><br><span class="line">onCreateOptionsMenu //创建menu的回调</span><br><span class="line">onOptionsItemSelected //设置响应menu事件的回调</span><br><span class="line">getMenuInflater //填充menu的填充器</span><br><span class="line">onRequestPermissionsResult //请求权限后处理结果的回调</span><br><span class="line">onBackPressed //按下返回回调</span><br><span class="line">onLowMemory //低内存回调</span><br><span class="line">onActivityResult //启动其它activity返回结果回调</span><br></pre></td></tr></table></figure></li></ul><p>好像列出来没什么软用。。</p><h3 id="Intent使用"><a href="#Intent使用" class="headerlink" title="Intent使用"></a>Intent使用</h3><p>能够定义Activity后，接着就是利用Intent进行页面的跳转了。Intent意为意图，在四大组件中基本都是利用Intent进行调用和传递。</p><p>Intent分为启动方和接受方，启动方发出Intent，接收方接收。完成跳转或启动，启动方需要给出Intent目标或方向，而接受方需要明确自己能接受什么Intent</p><p>首先Intent很干脆，就是一个Parcelable 和 Cloneable而已，Intent同样对应着Manifest文件intent-filter标签，代表当前组件能够响应什么样的意图</p><p>显式使用Intent进行跳转Activity：明确目标地点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Context from, Class&lt;? extends Activity&gt; to, Bundle bundle)</span> </span>&#123;</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(from, to);</span><br><span class="line">    <span class="keyword">if</span> (bundle != <span class="keyword">null</span>) &#123;</span><br><span class="line">        intent.putExtras(bundle);</span><br><span class="line">    &#125;</span><br><span class="line">    from.startActivity(intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>隐式使用Intent：不明确目标地点，但是能给出大致的方向。通过action，category，data三种隐式过滤，来搜寻目标。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.addCategory(String);<span class="comment">//可以多个</span></span><br><span class="line">intent.setAction(String);<span class="comment">//单个</span></span><br><span class="line">intent.setData(Uri);<span class="comment">//单个</span></span><br></pre></td></tr></table></figure><p>响应的一方可以设置多个Intent-filter</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.VIEW"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:host</span>=<span class="string">""</span> <span class="attr">android:mimeType</span>=<span class="string">""</span> <span class="attr">android:port</span>=<span class="string">""</span> <span class="attr">android:scheme</span>=<span class="string">""</span> <span class="attr">android:path</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure><p>携带数据</p><p>Intent可以携带基本数据类型，数组，Parcelable，Serializable，不爽的话直接Bundle打包。不过内部实现也是一起打包在Bundle中。</p><p>startActivityForResult 这则是启动activity后返回可以读取返回的数据，需要重写onActivityResult来读取Intent</p><p>到了这里其实也能够做挺多事了，不光能够自己应用内跳转，以及开启相机啊，相册，很多很多。</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="返回栈"><a href="#返回栈" class="headerlink" title="返回栈"></a>返回栈</h3><p>用于管理任务栈，新Activity入栈，finish出栈。</p><h3 id="活动状态"><a href="#活动状态" class="headerlink" title="活动状态"></a>活动状态</h3><ul><li>运行状态：activity位于栈顶</li><li>暂停状态：可见，不位于栈顶</li><li>停止状态：不可见，不位于栈顶</li><li>销毁状态：出栈</li></ul><h3 id="生命周期方法"><a href="#生命周期方法" class="headerlink" title="生命周期方法"></a>生命周期方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">onCreate<span class="comment">//设置Layout</span></span><br><span class="line">onStart<span class="comment">//可见</span></span><br><span class="line">onResume<span class="comment">//可见可交互</span></span><br><span class="line">onPause<span class="comment">//可见不可交互</span></span><br><span class="line">onStop<span class="comment">//不可见</span></span><br><span class="line">onDesotry<span class="comment">//销毁</span></span><br><span class="line">onRestart<span class="comment">//onStop恢复后会走</span></span><br></pre></td></tr></table></figure><p>生命周期方法对应了活动状态时的回调</p><h2 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a>启动模式</h2><p>指定Activity的启动模式，对应着<strong>android:launchMode</strong>属性</p><ul><li>Standard 标准模式，无论站内是否存在实例，都会创建新的</li><li>SingleTop 栈顶存在则不创建新的</li><li>SingleTask 栈内存在则不创建新的，并且把上面的全都出栈</li><li>SingleInstance 用一个单独的栈来管理</li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 泛型</title>
      <link href="/2019/07/02/Java-%E6%B3%9B%E5%9E%8B/"/>
      <url>/2019/07/02/Java-%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="what"><a href="#what" class="headerlink" title="what"></a>what</h3><p>泛型我通俗的认为就是参数化类型，即传入类型提示。告诉它我即将要在这个类型的版本上使用你了。并且在写出大量代码时使用泛型可以写出一套模板代码。而且使用了泛型后，在编译期间泛型这个是能够检测你的代码有没有使用不规范类型的对象，在编译期间有点不好理解，但是当我们用IDE的时候，一旦你使用泛型，产生的对象，在IDE看来所给出的代码提示等检查也都是基于传入的泛型参数。但是呢，编译通过后在jvm中运行表现看来，所有用于参数类型的对象表现为Object， 这也俗称类型擦除。<strong>泛型参数不能时基本类型</strong></p><a id="more"></a><h3 id="how"><a href="#how" class="headerlink" title="how"></a>how</h3><h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><p>首先列举下我们经常用到一些关于泛型的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><p>如何自行定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class Person&lt;T&gt; &#123;</span><br><span class="line">    T t;</span><br><span class="line">    <span class="function">T <span class="title">getT</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setT</span><span class="params">(T t)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person&lt;String&gt; person = <span class="keyword">new</span> Person&lt;&gt;();</span><br><span class="line">        person.setT(<span class="string">"ffff"</span>);</span><br><span class="line">        Person&lt;Integer&gt; person1 = <span class="keyword">new</span> Person&lt;&gt;();</span><br><span class="line">        person1.setT(<span class="number">9</span>);</span><br><span class="line">        System.out.println(person.getT().getClass());</span><br><span class="line">        System.out.println(person1.getT().getClass());</span><br><span class="line">        System.out.println(person.getClass());<span class="comment">//class learn2.GenericTest$Person</span></span><br><span class="line">        System.out.println(person1.getClass());<span class="comment">//class learn2.GenericTest$Person</span></span><br><span class="line">        GenericTest test = <span class="keyword">new</span> GenericTest();</span><br><span class="line">        test.getArray(<span class="number">1</span>,<span class="number">23</span>,<span class="number">4</span>);</span><br><span class="line">        test.getArray(<span class="string">"f"</span>, <span class="string">"f"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> &lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> T t;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setT</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.t = t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">getT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后你就能发挥想象创造代码了呀，别看它加了尖括号和类型，其实看穿了还是一个普通类。通过Class比较你都看不到关于泛型的东西</p><p>以及后续的继承</p><h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Presenter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">attachView</span><span class="params">(T t)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dettachView</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实和泛型类没啥不同</p><h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; T[] getArray(T ...ts) &#123;</span><br><span class="line">        <span class="keyword">return</span> ts;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">static</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="keyword">int</span>[] nums = test.getArray(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">        String[] strs = test.getArray(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子是我比较喜欢的，通过变长的参数返回数组。看在你传入参数一刹那，其实就是相当于把类型参数弄进入了。</p><h4 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h4><p>在jdk的代码中以及框架呀大量使用关于泛型的东西，说明了这玩意很好使。通过接口实现，或者类的继承中加入泛型，又能够写出可复用的代码。以及配合通配符，配合多态呀，那简直爽的不要不要的。</p><p><code>extends</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IPresenter</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">IView</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//说明了传入的参数类型，得要是IView子类</span></span><br></pre></td></tr></table></figure><p>好吧我老是把&lt;? extends T&gt; 和 <t extends sometype>搞混。。</t></p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><p>泛型参数不能是基本类型</p></li><li><p>不能带泛型用于<code>instancof</code>关键字</p></li><li><p>不可以用于泛型数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] lists = <span class="keyword">new</span> ArrayList&lt;String&gt;[<span class="number">10</span>];<span class="comment">//无法这样不行的</span></span><br><span class="line">List&lt;String&gt;[] lists = <span class="keyword">new</span> ArrayList[<span class="number">10</span>];<span class="comment">//这样却是可以的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//唯一的方式就是创建类型擦出的数组，然后再转型</span></span><br><span class="line">List&lt;String&gt;[] lists = <span class="keyword">new</span> ArrayList[<span class="number">10</span>];</span><br><span class="line">lists[<span class="number">0</span>] = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">lists[<span class="number">0</span>].add(<span class="string">"aa"</span>);</span><br><span class="line">System.out.println(lists.getClass());</span><br></pre></td></tr></table></figure></li><li><p>类型捕获</p><p>通同getClass来获取真实的类型咯</p></li><li><p>泛型和重载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span>,<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//因为泛型擦初，所以二者有相同的方法签名</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(List&lt;E&gt; list)</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//同样</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(T t)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(E e)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>自限定的类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">C</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">//这自限定的例子比较简单，即限定比较对象为自己，其实仔细研究还是泛型的事</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(C o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">A</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;&#125; <span class="comment">//这个有点抽象，但是仔细看好像陷入一个无限循环样子</span></span><br><span class="line"><span class="comment">//首先我们继承它看看</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span>&lt;<span class="title">B</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//这样写是否合理，就看B是否能套入&lt;T extentd A&lt;T&gt;&gt; 中，呃呃，看了好久，是可以</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//那么到底有什么用呢，这个通常用于继承关系中的限定。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">A</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">         <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span>&lt;<span class="title">B</span>&gt; </span>&#123;<span class="comment">//这个泛型参数只能事继承链上的，换了其它的不可以，就是这是妙用啊</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(B b)</span> </span>&#123;<span class="comment">//由于限定了这个实现的方法就必须为自己。其它不行。有意思呵呵</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>异常处理中catch是不能捕获泛型类型的异常，因为再运行期间必须知道异常的确切类型</p></li></ul><h3 id="why"><a href="#why" class="headerlink" title="why"></a>why</h3><p>编写用于多种类型的代码。</p><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>前面的其实都还好理解，到了这里就有点要想想了，不然傻傻分不清楚。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?&gt;</span><br><span class="line">&lt;? extends E&gt; <span class="comment">//这个E一般就代表声明出来的类型参数。指代你声明&lt;E&gt;</span></span><br><span class="line">&lt;? <span class="keyword">super</span> E&gt;</span><br></pre></td></tr></table></figure><h4 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h4><p>还是看栗子把2333</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> learn2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericTest2 test2 = <span class="keyword">new</span> GenericTest2();</span><br><span class="line">        List&lt;String&gt; stringList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        stringList.add(<span class="string">"aaa"</span>);</span><br><span class="line">        stringList.add(<span class="string">"bbb"</span>);</span><br><span class="line">        stringList.add(<span class="string">"ccc"</span>);</span><br><span class="line">        List&lt;Integer&gt; integerList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        integerList.add(<span class="number">1</span>);</span><br><span class="line">        integerList.add(<span class="number">2</span>);</span><br><span class="line">        integerList.add(<span class="number">3</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ?任意</span></span><br><span class="line">        test2.runTest(stringList);</span><br><span class="line">        test2.runTest(integerList);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//上界为Number</span></span><br><span class="line">        List&lt;Long&gt; longList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        test2.runTest2(longList, <span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//下界Number</span></span><br><span class="line">        List&lt;Object&gt; objectList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        test2.runTest3(objectList, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runTest</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;<span class="comment">//可以接受任意泛型参数的List</span></span><br><span class="line">        list.add(<span class="keyword">null</span>);<span class="comment">//只能写null</span></span><br><span class="line"><span class="comment">//        list.add(new Object());// error</span></span><br><span class="line">        System.out.println(list.get(<span class="number">3</span>).getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runTest2</span><span class="params">(List&lt;? extends Number&gt; list, Number number2)</span> </span>&#123;<span class="comment">//只能接受泛型参数继承Number的List</span></span><br><span class="line">        Number number = list.get(<span class="number">0</span>);<span class="comment">// 只可以读Number类型</span></span><br><span class="line">        <span class="comment">//list.add(new Object());//写不了</span></span><br><span class="line">        <span class="comment">//list.add(number2);//编译不通过</span></span><br><span class="line">        <span class="comment">//list.add(number);//编译不通过</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runTest3</span><span class="params">(List&lt;? <span class="keyword">super</span> Number&gt; list, Number number)</span> </span>&#123;<span class="comment">//只能接受泛型参数为Number父类的List</span></span><br><span class="line">        list.add(number);<span class="comment">//可以写Number类型</span></span><br><span class="line">        <span class="comment">//list.add(new Object()); 不行</span></span><br><span class="line">        Object object = list.get(<span class="number">0</span>);<span class="comment">//只能捕获为Object</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分析一波"><a href="#分析一波" class="headerlink" title="分析一波"></a>分析一波</h4><ul><li><p><code>&lt;?&gt;</code>这个统配符代表，可以接受任意泛型参数，与之同时，对应的<code>List&lt;?&gt; list</code> 可以接受<code>List&lt;Number&gt;</code> <code>List&lt;String&gt;</code>对象等等，所以嘞，它也就根本不知道实际对象会是带什么泛型参数，所以只能<strong>写<code>null</code></strong>，我没想到的是居然<strong>写Object</strong>也不行，读还是的啊，但是只能为Object，没事啊，你可动态的<code>instance of</code>判断下嘛，写死转换肯定是不行的，因为它压根啥也不知道，咱也不敢问是吧。</p></li><li><p><code>&lt;? extends E&gt;</code>这个通配符代表了，可以接受带上界为E泛型参数。即你的泛型参数得是E或E的子类才行</p><p>List&lt;? extends Number&gt; list这个能能接受<code>List&lt;Int&gt;</code> <code>List&lt;Long&gt;</code>等等为Number的子类泛型参数 。可能有人会觉得有了上界那不为所欲为。我以前也是这么觉得的哈哈。上述实践得知，只<code>能写为E</code>，<code>不能读为E</code>，当然能读为Object。因为它知道你传进来的肯定是带E后代泛型，所以呢，我里面的元素肯定能表现为E，所以读是没问题。但是写E就有问题了，比如我某一次识别的到是Long，然后你要写一个Number，你说怎么能写。</p></li><li><p><code>&lt;? super E&gt;</code> 这个就刚好了上面那个相反，E为下界，可以接受E父类等泛型参数。对于这个而言，就只<code>能写E</code>，<code>不能读E</code> ，你的泛型参数为超类，你压根不知到内容表现为具体是个啥东西，所以读就别想了。但是E可以表现为超类，所以写E就没问题咯。</p></li></ul><p>总结下来就是：</p><p>&lt;?&gt; 可以匹配任何泛型参数，但是只能写null</p><p>&lt;? extends E&gt; 可以匹配E的子类泛型参数，只能读E，不能写E</p><p>&lt;? super E&gt; 可以匹配E的超类泛型参数，不能读E，只能写E</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>其实泛型这个东西呢，以前我想的太简单了，传个类型参数就完事了，以前我也是这么认为的，但是看了《Java编程思想》，卧槽还有这么多东西，而且稍稍不深入就会被带跑偏呃呃。目前还是归纳的不够详细，以后学到再补充！✌，对了想不通的地方，没事一定要敲一敲，比瞎想强，总有好处的。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 并发梳理</title>
      <link href="/2019/07/01/Java-%E5%B9%B6%E5%8F%91/"/>
      <url>/2019/07/01/Java-%E5%B9%B6%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<p>Java 并发</p><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>what：cpu调度的最小单位</p><p>创建方式：</p><ul><li>继承Thread，实现重写run方法，创建Thread对象，调用start方法。</li><li>实现Runnable，实现run方法，创建Runnable对象，传入Thread对象，调用start方法</li><li>后文的中Callable</li></ul><p>线程的状态：新建，可执行，执行，阻塞，死亡</p><p><img src="/images/1561517414845.png" alt="1561517414845"></p><p>yield只是让出cpu的使用权，下次还有可能抢占cpu</p><p>调用其它线程的join，当前线程会阻塞，知道那个线程执行完毕。</p><h5 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h5><p>多线程访并发访问共享资源，会导致数据安全问题。</p><h6 id="synchronized-加悲观锁"><a href="#synchronized-加悲观锁" class="headerlink" title="synchronized 加悲观锁"></a>synchronized 加悲观锁</h6><p>通过synchronized添加锁，可以加载方法上和代码块上。在被锁起来的地方只会又一个线程进入，直到该代码执行完毕。该实现为jvm内置实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span>(obj)&#123;&#125;</span><br></pre></td></tr></table></figure><p>线程8锁问题：</p><p>synchronized锁需要看锁的对象是谁，线程需要锁对象为同一个的情况下，进入了锁区域另外的线程就必须等待。</p><ul><li>锁对象为普通对象</li><li>所对象为class对象，即在静态方法上加锁</li></ul><p>要根据具体锁对象来判断执行效果。持有同一锁对象，操作即为互斥。</p><h6 id="Lock-乐观锁"><a href="#Lock-乐观锁" class="headerlink" title="Lock 乐观锁"></a>Lock 乐观锁</h6><p>代码实现，需要手动释放锁，不然会造成死锁，需要在finally释放锁</p><p>有三个实现类</p><ul><li>ReentrantLock  可重入锁</li><li>ReadLock 读锁，通过new ReentrantReadWriteLock .readLock()获得</li><li>WriteLock写锁，通过new ReentrantReadWriteLock .writeLock()获得</li></ul><p>读写锁：读写互斥，写写互斥，读读共享</p><p><strong>Condition</strong></p><p>在synchronized锁下面，jvm提供了obect.wait,和notify，这两个通信是依赖synchronized关键字的，从等待池到锁池。而在Lock锁下与之对应线程通信的则是Condition对象，condition.await()进入等待和condition.sigal()唤醒</p><h6 id="Lock和synchronized的选择"><a href="#Lock和synchronized的选择" class="headerlink" title="Lock和synchronized的选择"></a>Lock和synchronized的选择</h6><p>　　总结来说，Lock和synchronized有以下几点不同：</p><p>　　1）Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；</p><p>　　2）synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；</p><p>　　3）Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；</p><p>　　4）通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。</p><p>　　5）Lock可以提高多个线程进行读操作的效率。</p><p>　　在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。</p><h6 id="锁的概念"><a href="#锁的概念" class="headerlink" title="锁的概念"></a>锁的概念</h6><p>　　<strong>1.可重入锁</strong></p><p>如果锁具备可重入性，则称作为可重入锁。像synchronized和ReentrantLock都是可重入锁，可重入性在我看来实际上表明了锁的分配机制：基于线程的分配，而不是基于方法调用的分配。举个简单的例子，当一个线程执行到某个synchronized方法时，比如说method1，而在method1中会调用另外一个synchronized方法method2，此时线程不必重新去申请锁，而是可以直接执行方法method2。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>synchronized和Lock都具备可重入性</p><p>​        <strong>2.可中断锁</strong></p><p>　　可中断锁：顾名思义，就是可以相应中断的锁。</p><p>　　在Java中，synchronized就不是可中断锁，而Lock是可中断锁。</p><p>　　如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，这种就是可中断锁。</p><p>　　在前面演示lockInterruptibly()的用法时已经体现了Lock的可中断性。</p><p>​        <strong>3.公平锁</strong></p><p>　　公平锁即尽量以请求锁的顺序来获取锁。比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该所，这种就是公平锁。</p><p>　　非公平锁即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或者一些线程永远获取不到锁。</p><p>　　在Java中，synchronized就是非公平锁，它无法保证等待的线程获取锁的顺序。</p><p>　　而对于ReentrantLock和ReentrantReadWriteLock，它默认情况下是非公平锁，但是可以设置为公平锁。</p><p><code>ReentrantLock lock = new</code> <code>ReentrantLock(true);</code></p><p>true 为公平，false为不公平</p><p>另外在ReentrantLock类中定义了很多方法，比如：</p><p>　　isFair()        //判断锁是否是公平锁</p><p>　　isLocked()    //判断锁是否被任何线程获取了</p><p>　　isHeldByCurrentThread()   //判断锁是否被当前线程获取了</p><p>　　hasQueuedThreads()   //判断是否有线程在等待该锁</p><p>　　在ReentrantReadWriteLock中也有类似的方法，同样也可以设置为公平锁和非公平锁。不过要记住，ReentrantReadWriteLock并未实现Lock接口，它实现的是ReadWriteLock接口。</p><p>​        <strong>4.读写锁</strong></p><h6 id="Volatile关键字"><a href="#Volatile关键字" class="headerlink" title="Volatile关键字"></a><strong>Volatile关键字</strong></h6><p>内存可见性是指当某个线程正在使用对象状态而另一个线程在同时修改该状态，需要确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。当多个线程进行操作共享数据时，可以保证内存中的数据可见。相较于 synchronized 是一种较为轻量级的同步策略</p><ol><li><p>volatile 不具备“互斥性”</p></li><li><p>volatile 不能保证变量的“原子性”</p></li></ol><h6 id="CAS算法-无锁算法"><a href="#CAS算法-无锁算法" class="headerlink" title="CAS算法 无锁算法"></a>CAS算法 无锁算法</h6><p>原子性操作问题，CAS是一种硬件对并发的支持，用于管理对共享数据的访问，CAS是一种无锁的非阻塞算法实现</p><p>1、原子变量：在java.util.concurrent.atomic包下提供了基本的原子变量</p><p>​    【1】Volatile保证内存可见性</p><p>​    【2】CAS算法保证数据变量的原子性</p><p>2、CAS算法实现CAS包含了三个操作变量：</p><p>​    【1】内存值V</p><p>​    【2】内存预估值A</p><p>​    【3】内存更新值B当且仅当V==A时，V=B；否则不会执行任何操作模拟CAS算法</p><h5 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h5><h6 id="基于synchronized-锁"><a href="#基于synchronized-锁" class="headerlink" title="基于synchronized 锁"></a>基于synchronized 锁</h6><p>wait：中断方法的执行，使本线程等待，暂时让出 cpu 的使用权，并允许其他线程使用这个同步方法。</p><p>notify：唤醒由于使用这个同步方法而处于等待线程的 某一个结束等待</p><p>notifyall：唤醒所有由于使用这个同步方法而处于等待的线程结束等待</p><p>锁池:假设线程A已经拥有了某个对象(注意:不是类)的锁，而其它的线程想要调用这个对象的某个synchronized方法(或者synchronized块)，由于这些线程在进入对象的synchronized方法之前必须先获得该对象的锁的拥有权，但是该对象的锁目前正被线程A拥有，所以这些线程就进入了该对象的锁池中。</p><p>等待池:假设一个线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁后，进入到了该对象的等待池中<br>所谓唤醒线程，另一种解释可以说是将线程由等待池移动到锁池，notifyAll调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而notify只会唤醒一个线程。</p><h6 id="基于Lock锁"><a href="#基于Lock锁" class="headerlink" title="基于Lock锁"></a>基于Lock锁</h6><p>从Lock中获得Condition，类似于上面的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> var1)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> var1, TimeUnit var3)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date var1)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><h5 id="what"><a href="#what" class="headerlink" title="what"></a>what</h5><p>维护了一些线程的队列，线程创建和销毁是非常消耗资源的。利用线程池来重用这些线程，提高了响应速度</p><p>降低 资源消耗</p><p>提高响应速度</p><p>提高线程的 可管理性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 一、线程池：提供了一个线程队列，队列中保存着所有等待状态的线程。避免了创建与销毁额外开销，提高了响应的速度。</span><br><span class="line"> * </span><br><span class="line"> * 二、线程池的体系结构：</span><br><span class="line"> * java.util.concurrent.Executor : 负责线程的使用与调度的根接口</span><br><span class="line"> * |--**ExecutorService 子接口: 线程池的主要接口</span><br><span class="line"> * |--ThreadPoolExecutor 线程池的实现类</span><br><span class="line"> * |--ScheduledExecutorService 子接口：负责线程的调度</span><br><span class="line"> * |--ScheduledThreadPoolExecutor ：继承 ThreadPoolExecutor， 实现 ScheduledExecutorService</span><br><span class="line"> * </span><br><span class="line"> * 三、工具类 : Executors </span><br><span class="line"> * ExecutorService newFixedThreadPool() : 创建固定大小的线程池</span><br><span class="line"> * ExecutorService newCachedThreadPool() : 缓存线程池，线程池的数量不固定，可以根据需求自动的更改数量。</span><br><span class="line"> * ExecutorService newSingleThreadExecutor() : 创建单个线程池。线程池中只有一个线程</span><br><span class="line"> * </span><br><span class="line"> * ScheduledExecutorService newScheduledThreadPool() : 创建固定大小的线程，可以延迟或定时的执行任务。</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h5 id="how"><a href="#how" class="headerlink" title="how"></a>how</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">execute 执行任务</span><br><span class="line">submit 提交任务，并且返回Future</span><br><span class="line">shutDown 中止线程池，设置线程池状态为SHUTDOWN，中断没有运行的线程</span><br><span class="line">shtDownNow 中止线程池，设置线程池状态为SHUTDOWN， 尝试停止所有线程，并返回等待任务队列</span><br><span class="line">不同应用场景使用不同的配置线程</span><br><span class="line">任务的性质：CPU密集型任务、IO密集型任务和混合型任务</span><br><span class="line">任务的优先级：高、中和低</span><br><span class="line">任务的执行时间：长、中和短</span><br><span class="line">任务的依赖性：是否依赖其他系统资源，如数据库连接。</span><br><span class="line">CPU密集型任务</span><br><span class="line">应配置尽可能小的线程,配置</span><br><span class="line">N(CPU)+<span class="number">1</span>或者 N(CPU) * <span class="number">2</span></span><br><span class="line">I/O密集型任务</span><br><span class="line">业务读取较多,线程并不是一直在执行任务,则应配置尽可能多的线程</span><br><span class="line">N(CPU)/<span class="number">1</span> - 阻塞系数(<span class="number">0.8</span>~<span class="number">0.9</span>)</span><br><span class="line">混合型的任务,如果可以拆分,将其拆分成一个CPU密集型任务和一个IO密集型任务,只要这两个任务执行的时间相差不是太大,那么分解后执行的吞吐量将高于串行执行的吞吐量.如果这两个任务执行时间相差太大,则没必要进行分解.</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>关于线程池构造方法参数说明：</p><p>corePoolSize 核心线程数量</p><p>maximumPoolSize 最大线程数量</p><p>keepAliveTime 存活时间</p><p>TimeUnit 时间单位</p><p>workQueue 等待队列</p><h5 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h5><ul><li>AbortPolicy：丢弃任务，抛出 RejectedExecutionException</li><li>CallerRunsPolicy:只用调用者所在线程来运行任务,有反馈机制，使任务提交的速度变慢）。</li><li>DiscardOldestPolicy<br>若没有发生shutdown,尝试丢弃队列里最近的一个任务,并执行当前任务, 丢弃任务缓存队列中最老的任务，并且尝试重新提交新的任务</li><li>DiscardPolicy:不处理,丢弃掉, 拒绝执行，不抛异常<br>当然,也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略.如记录日志或持久化存储不能处理的任务  </li></ul><p>一个任务被提交到线程池中，首先会去检查核心线程是否达最大，如果没有则创建新线执行任务，如果核心线程达最大且都在执行任务，下一步将会去判断任务队列是否满，如果没有满则入队列等待，如果满了则创建新的线程，此时线程池最大能达到的线程数量即为最大线程数，当任务执行完毕，线程空闲之后等待存活时间后就会杀死线程。知道线程数量维持在核心线程数量。</p><p>这样就好比如一个工厂本来又四个人在工作，但是订单增加了，但是能工厂负责人认为工人还能承受住，于是就将累计的订单来排队，时间一长还是能完成，但是随着订单的增加，工厂的排队已经排不下了。工厂负责人招了了一些了临时工参与工作，随着时间推移订单还在增加，此时排队满了，工人工作的位置也满了。此时工厂负责人就要考虑使用那种策略来对待新的订单。当订单减少了，临时工没事做了，此时工厂负责人为了成本考虑，就要撤下临时工了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c = ctl.get();</span><br><span class="line"><span class="comment">//工作任务小于核心线程数</span></span><br><span class="line"><span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">    <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))<span class="comment">//创建线程</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    c = ctl.get();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//大于核心线程数，尝试入工作队列</span></span><br><span class="line"><span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">    <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">        reject(command);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;<span class="comment">//入队列失败，尝试新增线程，此时线程数即将大于核心线程，但是要小于最大线程数</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">    reject(command);<span class="comment">//达到最大线程数，采取拒绝策略</span></span><br></pre></td></tr></table></figure><h5 id="关于获取Worker"><a href="#关于获取Worker" class="headerlink" title="关于获取Worker"></a>关于获取Worker</h5><p>线程池维持一个Worker的HashSet，Work本身也是一个Runnable，内部包含了一个第一个任务，和一个Thread对象（线程），也就是一个work持有一个线程。这个线程在addWorker成功时，会去开启线程。也就是调用线程池外围的runWorker方法。从这里就开始进入worker的线程任务了，在线程中开启while循环去获得Task，Task的获得同样时循环去阻塞队列拿runnable。如果工作队列空了，拿取超时，则会去减少Worker数量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.....</span><br><span class="line">//Worker类</span><br><span class="line">Worker(Runnable firstTask) &#123;</span><br><span class="line">            setState(-1); // inhibit interrupts until runWorker</span><br><span class="line">            this.firstTask = firstTask;</span><br><span class="line">            this.thread = getThreadFactory().newThread(this);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /** Delegates main run loop to outer runWorker. */</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            runWorker(this);</span><br><span class="line">        &#125;</span><br><span class="line">....</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//addWorke方法 </span></span><br><span class="line">w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">            <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">                mainLock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                    <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                    <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                    <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                        (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                        workers.add(w);</span><br><span class="line">                        <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                        <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                            largestPoolSize = s;</span><br><span class="line">                        workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    mainLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                    t.start();</span><br><span class="line">                    workerStarted = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//runThis方法</span></span><br><span class="line"><span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                w.lock();</span><br><span class="line">                <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">                <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">                <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">                <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">                <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                     (Thread.interrupted() &amp;&amp;</span><br><span class="line">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                    !wt.isInterrupted())</span><br><span class="line">                    wt.interrupt();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    beforeExecute(wt, task);</span><br><span class="line">                    Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        task.run();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        afterExecute(task, thrown);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="keyword">null</span>;</span><br><span class="line">                    w.completedTasks++;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">               decrementWorkerCount();</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">           <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">               &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">               <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://www.nowcoder.com/discuss/152050?type=0&amp;order=0&amp;pos=6&amp;page=0" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/152050?type=0&amp;order=0&amp;pos=6&amp;page=0</a></p><h4 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h4><h5 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h5><p>参考：<a href="https://blog.csdn.net/yudiandemingzi/article/details/82318390" target="_blank" rel="noopener">https://blog.csdn.net/yudiandemingzi/article/details/82318390</a></p><p>内部基于Lock锁的通信实现等待阻塞。</p><h5 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h5><p>ConcurrentMap</p><p>CopyOnWriteList</p><h5 id="原子变量"><a href="#原子变量" class="headerlink" title="原子变量"></a>原子变量</h5><p>硬件级别实现，普通变量int进行自增时，在jvm表现看来，这不是一个原子操作，所以线程就有可能打断，从而造成数据安全问题。</p><p>而原子变量通过使用volatile来保证内存可见性以及通过cas算法保证原子性。</p><h5 id="CountDownLatch-闭锁"><a href="#CountDownLatch-闭锁" class="headerlink" title="CountDownLatch 闭锁"></a>CountDownLatch 闭锁</h5><p>也可以叫倒计数器</p><p>what:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建计数为10的闭锁</span></span><br><span class="line">CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//计数减一</span></span><br><span class="line">countDownLath.countDown();</span><br><span class="line"><span class="comment">//线程等待,直到计数为0</span></span><br><span class="line">countDownLath.await();</span><br></pre></td></tr></table></figure><p>在线程完成某项操作之前它允许让一个或多个线程进行等待。倒计数，在内部计数到零之前，所调用countDownLatch.await的线程会等待，直到计数到达0为止。 </p><p>how:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> learn2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CountDownLatchTest test = <span class="keyword">new</span> CountDownLatchTest();</span><br><span class="line">        test.runTest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Main is waiting."</span>);</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Main is over"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CountDownLatch countDownLatch;</span><br><span class="line"></span><br><span class="line">    Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Current Thred is "</span> + Thread.currentThread().getId() + <span class="string">",print : "</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">Main is waiting.</span><br><span class="line">Current Thred is <span class="number">12</span>,print : <span class="number">0</span></span><br><span class="line">Current Thred is <span class="number">13</span>,print : <span class="number">0</span></span><br><span class="line">Current Thred is <span class="number">12</span>,print : <span class="number">1</span></span><br><span class="line">Current Thred is <span class="number">13</span>,print : <span class="number">1</span></span><br><span class="line">Current Thred is <span class="number">12</span>,print : <span class="number">2</span></span><br><span class="line">Current Thred is <span class="number">12</span>,print : <span class="number">3</span></span><br><span class="line">Current Thred is <span class="number">12</span>,print : <span class="number">4</span></span><br><span class="line">Current Thred is <span class="number">12</span>,print : <span class="number">5</span></span><br><span class="line">Current Thred is <span class="number">13</span>,print : <span class="number">2</span></span><br><span class="line">Current Thred is <span class="number">12</span>,print : <span class="number">6</span></span><br><span class="line">Current Thred is <span class="number">13</span>,print : <span class="number">3</span></span><br><span class="line">Current Thred is <span class="number">12</span>,print : <span class="number">7</span></span><br><span class="line">Current Thred is <span class="number">13</span>,print : <span class="number">4</span></span><br><span class="line">Current Thred is <span class="number">12</span>,print : <span class="number">8</span></span><br><span class="line">Current Thred is <span class="number">13</span>,print : <span class="number">5</span></span><br><span class="line">Current Thred is <span class="number">13</span>,print : <span class="number">6</span></span><br><span class="line">Current Thred is <span class="number">12</span>,print : <span class="number">9</span></span><br><span class="line">Current Thred is <span class="number">13</span>,print : <span class="number">7</span></span><br><span class="line">Current Thred is <span class="number">13</span>,print : <span class="number">8</span></span><br><span class="line">Current Thred is <span class="number">13</span>,print : <span class="number">9</span></span><br><span class="line">Main is over</span><br></pre></td></tr></table></figure><h5 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h5><p>What：栅栏，类似于闭锁，但是呢，闭锁是等待事件，即线程等待到countDown数量为0为止。而栅栏则是，线程到达栅栏开始等待，知道所有线程都达到栅栏了，就不在等待。而且闭锁使用一次，栅栏可以重置，继续使用。</p><blockquote><p>书上是这么说的：你希望创建一组任务，使他们并行执行，然后下一个步骤之前等待，直到所有任务完成，它使得所有并行任务在栅栏处排队，因此可以一致的向前移动。</p></blockquote><p>How：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line">CyclicBarrier(<span class="keyword">int</span> parties);<span class="comment">//parties 表示会有多少到达的栅栏的线程</span></span><br><span class="line">CyclicBarrier(<span class="keyword">int</span> parties, Runnable barrierAction);<span class="comment">//barrierAction 所有线程到达栅栏，会触发</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//关键方法</span></span><br><span class="line">await();<span class="comment">//某线程到达栅栏，并且等待，知道所有线程都到达栅栏</span></span><br><span class="line">reset();<span class="comment">//重置栅栏到初始状态</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> learn2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CyclicBarrierTest test = <span class="keyword">new</span> CyclicBarrierTest();</span><br><span class="line">        test.runTest();</span><br><span class="line">    &#125;</span><br><span class="line">    CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(runnable, <span class="string">"thread "</span> + i);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"for is over"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Runnable runnable = () -&gt; &#123;</span><br><span class="line">        System.out.println( Thread.currentThread().getName() + <span class="string">" waited"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cyclicBarrier.await();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" wake up"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//outputs 大概就是这个效果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> is over</span><br><span class="line">thread <span class="number">2</span> waited</span><br><span class="line">thread <span class="number">1</span> waited</span><br><span class="line">thread <span class="number">3</span> waited</span><br><span class="line">thread <span class="number">0</span> waited</span><br><span class="line">thread <span class="number">4</span> waited</span><br><span class="line">thread <span class="number">4</span> wake up</span><br><span class="line">thread <span class="number">1</span> wake up</span><br><span class="line">thread <span class="number">0</span> wake up</span><br><span class="line">thread <span class="number">3</span> wake up</span><br><span class="line">thread <span class="number">2</span> wake up</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h5 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h5><p>What：目前的Runnable执行方式是无法返回数据的。使用Callable创建线程以及配合FutureTask使用</p><p>FurtureTask.get时会所在线程锁等FurtureTask执行完毕</p><p>How：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 一、创建执行线程的方式三：实现 Callable 接口。 相较于实现 Runnable 接口的方式，方法可以有返回值，并且可以抛出异常。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 二、执行 Callable 方式，需要 FutureTask 实现类的支持，用于接收运算结果。  FutureTask 是  Future 接口的实现类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCallable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadDemo td = <span class="keyword">new</span> ThreadDemo();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.执行 Callable 方式，需要 FutureTask 实现类的支持，用于接收运算结果。</span></span><br><span class="line">        FutureTask&lt;Integer&gt; result = <span class="keyword">new</span> FutureTask&lt;&gt;(td);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(result).start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.接收线程运算后的结果</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Integer sum = result.get();  <span class="comment">//FutureTask 可用于 闭锁</span></span><br><span class="line">            System.out.println(sum);</span><br><span class="line">            System.out.println(<span class="string">"------------------------------------"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h5><h5 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h5><h5 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h5><p>What：继承自AbstractExecutorService，是一种特殊的线程池，通过分治法来分拆合并任务，使用有限的线程进行处理任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"><span class="keyword">import</span> java.time.Instant;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinTask;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.LongStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestForkJoinPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Instant start = Instant.now();</span><br><span class="line"></span><br><span class="line">ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line"></span><br><span class="line">ForkJoinTask&lt;Long&gt; task = <span class="keyword">new</span> ForkJoinSumCalculate(<span class="number">0L</span>, <span class="number">50000000000L</span>);</span><br><span class="line"></span><br><span class="line">Long sum = pool.invoke(task);</span><br><span class="line"></span><br><span class="line">System.out.println(sum);</span><br><span class="line"></span><br><span class="line">Instant end = Instant.now();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"耗费时间为："</span> + Duration.between(start, end).toMillis());<span class="comment">//166-1996-10590</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">Instant start = Instant.now();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> sum = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0L</span>; i &lt;= <span class="number">50000000000L</span>; i++) &#123;</span><br><span class="line">sum += i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(sum);</span><br><span class="line"></span><br><span class="line">Instant end = Instant.now();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"耗费时间为："</span> + Duration.between(start, end).toMillis());<span class="comment">//35-3142-15704</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//java8 新特性</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">Instant start = Instant.now();</span><br><span class="line"></span><br><span class="line">Long sum = LongStream.rangeClosed(<span class="number">0L</span>, <span class="number">50000000000L</span>)</span><br><span class="line"> .parallel()</span><br><span class="line"> .reduce(<span class="number">0L</span>, Long::sum);</span><br><span class="line"></span><br><span class="line">System.out.println(sum);</span><br><span class="line"></span><br><span class="line">Instant end = Instant.now();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"耗费时间为："</span> + Duration.between(start, end).toMillis());<span class="comment">//1536-8118</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ForkJoinSumCalculate</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">259195479995561737L</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> start;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> end;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> THURSHOLD = <span class="number">10000L</span>;  <span class="comment">//临界值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ForkJoinSumCalculate</span><span class="params">(<span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.start = start;</span><br><span class="line"><span class="keyword">this</span>.end = end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> length = end - start;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(length &lt;= THURSHOLD)&#123;</span><br><span class="line"><span class="keyword">long</span> sum = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">sum += i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">long</span> middle = (start + end) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">ForkJoinSumCalculate left = <span class="keyword">new</span> ForkJoinSumCalculate(start, middle); </span><br><span class="line">left.fork(); <span class="comment">//进行拆分，同时压入线程队列</span></span><br><span class="line"></span><br><span class="line">ForkJoinSumCalculate right = <span class="keyword">new</span> ForkJoinSumCalculate(middle+<span class="number">1</span>, end);</span><br><span class="line">right.fork(); <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> left.join() + right.join();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 反射</title>
      <link href="/2019/07/01/Java-%E5%8F%8D%E5%B0%84/"/>
      <url>/2019/07/01/Java-%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<p>Java 反射</p><ul><li>类加载器</li><li>反射</li><li>动态代理</li></ul><p>what：在运行时加载某个类，获得某个类的相关信息，以及进行操作。</p><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>what:用于将节字码文件加载到JVM</p><ul><li>启动类加载器：bootstrap，c++编写，jvm自带，负责加载rt.jar（runtime），无法直接获取，它是所有类加载器的父加载器</li><li>扩展类加载器：extension ，jdk_home/lib/ext目录下的jar包或者 -D java.ext.dirs指定目录下的jar包装入工作库</li><li>System ClassLoader ：负责java -classpath或者-D java.class.path所指目录 下的类和jar包装入</li></ul><p>委托、可见性以及单一性原理</p><p>委托:即子加载器会请求父加载器是否加载,并且加载,如果不能加载就交会子加载器,即自下而上请求,自上而下加载.</p><p>可见性: 子类加载器可以看到父类加载器加载的类，而反之则不行</p><p>单一性: 父加载器加载过的类不能被子加载器加载第二次</p><h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><p>what：<strong>运行</strong>时获得类信息，注意是运行时。</p><p>Class：字节码在jvm存在形式即为Class的对象，是由jvm创建的。</p><ul><li><p>运行时构造任意一个对象</p></li><li><p>运行取得任意一个类所拥有成员变量和方法</p></li><li><p>运行时获得任意对象的方法属性</p></li><li><p>动态代理</p></li></ul><p>how：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"全类名"</span>);</span><br><span class="line">Class clazz = SomeClass.class;</span><br><span class="line">Class clazz = someClassObj.getClass();</span><br></pre></td></tr></table></figure><p>相关操作：可以拿到以下的信息</p><p>Constructor：getConstructor， getContructors</p><p>Method：getMethods（继承链上public的），getDeclareMethods（当前类声明的所有）</p><p>Field：getFields（继承链上public），getDeclareFields（当前类声明所有）</p><p>Annotation：getAnnotation，getDeclareAnnotaions(),getParameterAnnotations() </p><p>以及newInstance去创建对象</p><p>invoke去调用方法</p><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Boy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Boy</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打印"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Boy boy = <span class="keyword">new</span> Student();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boy <span class="title">getProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Boy) Proxy.newProxyInstance(boy.getClass().getClassLoader(), boy.getClass().getInterfaces(), <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"我是代理"</span>);</span><br><span class="line">                <span class="keyword">return</span> method.invoke(boy,args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 注解</title>
      <link href="/2019/07/01/Java-%E6%B3%A8%E8%A7%A3/"/>
      <url>/2019/07/01/Java-%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><strong>注解</strong></p><p>what：用于描述数据，并且可以被编译期以及jvm捕获的信息</p><ul><li>注解基本使用</li><li>运行时处理注解</li><li>编译处理注解</li><li>其它用处</li></ul><h3 id="注解基本使用"><a href="#注解基本使用" class="headerlink" title="注解基本使用"></a>注解基本使用</h3><p>how：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="meta">@interface</span> One&#123;</span><br><span class="line">    <span class="comment">//类似方法声明的方式来声明属性</span></span><br><span class="line">     <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="meta">@One</span>(name = <span class="string">"fdaf"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//基本注解</span></span><br><span class="line"><span class="meta">@Overrider</span> 描述限定重现父类方法</span><br><span class="line"><span class="meta">@Deprecated</span> 描述某个类或方法过时</span><br><span class="line"><span class="meta">@SupressWarnings</span> 抑制编译期警告</span><br></pre></td></tr></table></figure><p>元注解：描述注解的注解，用于限定注解的行为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span> 描述注解将注解的位置。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ElementType &#123;</span><br><span class="line">    TYPE, <span class="comment">//类，接口，注解，枚举</span></span><br><span class="line">    FIELD,<span class="comment">//属性</span></span><br><span class="line">    METHOD,<span class="comment">//方法</span></span><br><span class="line">    PARAMETER,<span class="comment">//参数</span></span><br><span class="line">    CONSTRUCTOR,<span class="comment">//构造方法</span></span><br><span class="line">    LOCAL_VARIABLE,<span class="comment">//局部变量</span></span><br><span class="line">    ANNOTATION_TYPE,<span class="comment">//注解</span></span><br><span class="line">    PACKAGE,<span class="comment">//包</span></span><br><span class="line">    TYPE_PARAMETER,<span class="comment">//Type parameter declaration</span></span><br><span class="line">    TYPE_USE<span class="comment">//Use of a type</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Retention</span> </span><br><span class="line">以下三种</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RetentionPolicy &#123;</span><br><span class="line">    SOURCE,</span><br><span class="line">    CLASS,</span><br><span class="line">    RUNTIME</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Documented</span> 表示可以被javadoc工具提取成文档</span><br><span class="line"><span class="meta">@Inherited</span> 表示继承性，如果某个使用了该注解修饰的注解，那么其子类会自动具有该注解</span><br></pre></td></tr></table></figure><p>通过注解在相应的位置，我们可以在下面的注解处理器，或者反射处理，获得到我们想要的得到的数据。这就是注解的任务啦。</p><h3 id="运行处理注解"><a href="#运行处理注解" class="headerlink" title="运行处理注解"></a>运行处理注解</h3><p>通过反射获得Class对象，Method等等，从而通过getAnnotation继而获得值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> learn2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationTest test = <span class="keyword">new</span> AnnotationTest();</span><br><span class="line">        test.test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TestAnnotation</span>(msg = <span class="string">"test"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> someOne;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Class clazz = getClass();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field field = clazz.getField(<span class="string">"someOne"</span>);</span><br><span class="line">            String msg = field.getAnnotation(TestAnnotation.class).msg();</span><br><span class="line">            System.out.println(field.getAnnotation(TestAnnotation.class));</span><br><span class="line">            System.out.println(msg);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line">    <span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line">    <span class="meta">@interface</span> TestAnnotation&#123;</span><br><span class="line">        <span class="function">String <span class="title">msg</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编译处理注解"><a href="#编译处理注解" class="headerlink" title="编译处理注解"></a>编译处理注解</h3><p>编译时处理注解，生成java文件</p><h3 id="处理注解时的相关类和API"><a href="#处理注解时的相关类和API" class="headerlink" title="处理注解时的相关类和API"></a>处理注解时的相关类和API</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//接口</span><br><span class="line">AnnotatedElement // 被注解的元素，这个接口声明的方法包含了一些获得注解注解对象的方法</span><br><span class="line">AnnotatedType //被注解的类型，有一个getType的方法//这些接口都从1.8开始的，感觉和泛型相关</span><br><span class="line">AnnotatedArrayType //被注解的数组类型</span><br><span class="line">AnnotatedParameterizedType//被注解的参数化类型 </span><br><span class="line">AnnotatedTypeVariable//被注解的类型变量</span><br><span class="line">AnnotatedWildcardType//被注解的统配符类型 获取上界和下界的AnnotatedType</span><br><span class="line">//类</span><br><span class="line">Filed</span><br><span class="line">Class</span><br><span class="line">Method</span><br><span class="line">Package</span><br><span class="line">Construcotr</span><br><span class="line">Paramter</span><br><span class="line">Executable</span><br><span class="line">AccessibleObject</span><br><span class="line"></span><br><span class="line">注解一个普通的int产生的AnnotatedType对象是sun.reflect.annotation.AnnotatedTypeFactory$AnnotatedTypeBaseImpl@1d44bcfa</span><br><span class="line">而注解List&lt;String&gt; list类型产生的的AnnotatedType对象是sun.reflect.annotation.AnnotatedTypeFactory$AnnotatedParameterizedTypeImpl@1d44bcfa</span><br><span class="line">而对int[] list 产生的是</span><br><span class="line">sun.reflect.annotation.AnnotatedTypeFactory$AnnotatedArrayTypeImpl@1d44bcfa</span><br><span class="line">与之对应的是那几个接口的实现类，虽然我没搞懂有啥用。。</span><br></pre></td></tr></table></figure><h3 id="其它用处"><a href="#其它用处" class="headerlink" title="其它用处"></a>其它用处</h3><p>用于设定常量</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 容器</title>
      <link href="/2019/06/30/Java-%E5%AE%B9%E5%99%A8/"/>
      <url>/2019/06/30/Java-%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="Java-容器"><a href="#Java-容器" class="headerlink" title="Java  容器"></a>Java  容器</h3><ul><li>List</li><li>Set</li><li>Map</li><li>Queue</li><li>Iterator</li><li>工具类</li><li>并发容器</li><li>android中的特殊集合</li></ul><h4 id="相关接口"><a href="#相关接口" class="headerlink" title="相关接口"></a>相关接口</h4><ul><li><p>Iterable 代表可迭代，实现的方法需要产出一个迭代器</p></li><li><p>Collection 除了Map外的祖先集合接口</p></li><li><p>List</p></li><li><p>Set</p></li><li><p>Map</p><p>Set 和 List都是一路继承Collection下来</p><p>Map则是单独的</p></li></ul><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p>定义了以套通过索引进行获取，和添加的集合</p><ul><li>ArrayList     内部是一个动态扩容的数组实现。</li><li>LinkedList   内部是一个双向链表实现</li><li>Vector 内部也是动态扩容的数组实现，不过大部分方法通过synchronized进行锁住方法，是线程安全的，但是效率不高。</li><li>Stack Vector的子类</li></ul><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>定义了一组不可重复的集合，通过哈希值来判断</p><ul><li>HashSet 内部是通过一个HashMap来实现，等同于HashMap的键，值恒为同一个Object</li><li>TreeSet 内部是通过一个TreeMap来实现</li></ul><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>定义了通过键值映射的集合</p><ul><li>HashMap 内部通过 数组 + 链表 + 红黑树进行实现的Map</li><li>TreeMap  内部通过红黑树进行实现，保持内部排序顺序</li><li>HashTable 古老实现，线程安全，效率不高</li><li>Properties key和value都是String类型</li></ul><h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><p>队列</p><h4 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h4><p>生成器，用于foreach循环</p><h4 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h4><ul><li>Arrays包含了许多对数组进行排序，复制等操作的工具类</li><li>Collections包含许多对集合进行操作</li><li>Comparators包含对比较器的工具</li></ul><h4 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h4><p>以上中只有Vectoer和HashTable是线程安全的，但是它是将整个集合都锁住了，效率不高。</p><ul><li>CopyOnWriteArryList</li><li>CopyOnWriteArraySet 写时复制，在写入的时候创建一个副本进行写入，当迭代多于修改，应该使用写时复制容器</li><li>ConcurrentHashMap </li><li>ConcurrentSkipListSet </li><li>阻塞队列</li></ul><p>ConcurrentMap容器:1.8以前采用锁分段技术，1.8开始使用CAS无锁技术。</p><h4 id="android中特殊容器"><a href="#android中特殊容器" class="headerlink" title="android中特殊容器"></a>android中特殊容器</h4><p>SparseArray 使用稀疏数组实现的一个key为int，value为Object的集合</p><p>LongSparseArray key为long value为object</p><p>SparseLongArray key为int value为long</p><p>SparseBooleanArray key为int value为boolean</p><p>SparseIntArray key为int value为int</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 基础知识梳理</title>
      <link href="/2019/06/30/Java-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"/>
      <url>/2019/06/30/Java-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="Java-基础内容"><a href="#Java-基础内容" class="headerlink" title="Java  基础内容"></a>Java  基础内容</h3><ul><li>数据类型</li><li>运算符</li><li>流程控制</li><li>面向对象</li><li>重要关键字</li><li>异常</li><li>编码</li><li>Object类</li></ul><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>计算机中最小的单位是bit，一个位0/1表示</p><h5 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h5><ul><li><p>byte  1字节 </p></li><li><p>short 2字节 </p></li><li><p>int  4字节</p></li><li><p>long 8字节</p></li><li><p>float 4字节</p></li><li><p>double 8字节</p></li><li><p>boolean 1字节</p></li><li><p>char 2字节 可以为unicode编码，位于栈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a = <span class="string">'\u1233'</span>;<span class="comment">//unicode编码表达</span></span><br></pre></td></tr></table></figure></li></ul><p>引用数据类型：引用位于栈，引用的对象位于堆</p><p>高精度向低精度可能丢失，表达式中默认转换为当前表达式的最大精度进行计算</p><h5 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h5><ul><li>基础运算符</li><li>instanceof 用于判断对象是否是某类型</li></ul><h4 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h4><ul><li><p>if else</p></li><li><p>if elseif </p></li><li><p>while</p></li><li><p>do while</p></li><li><p>for</p></li><li><p>foreach 需要容器实现Iterable接口和Iterator接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(SomeType obj: objList) &#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><p>关键字extends，类的继承和接口的继承</p><h5 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h5><p>访问控制private，default，protected，public</p><h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h5><p>通过父类或者接口引用访问实际对象的方法，称为动态绑定，实在运行时才能决定的。</p><h5 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h5><p>静态绑定，即同名方法存在不同的参数列表（类型，数量）</p><h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><p>成员和方法修饰为public ，实现的类需要实现方法，与接口间可以继承。只有声明，但是新版jdk可以存在默认方法，使用default定义</p><h5 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h5><p>匿名内部类，默认持有外部类this引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只是将匿名内部类复制给了一个引用，其实再参数传递中的内部类，同样也是将匿名内部类对象传递给了，临时的引用。</span></span><br><span class="line">   <span class="comment">//方法实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    B b = <span class="keyword">new</span> B()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成员内部类，默认持有外部类this引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        B b = a.new B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态内部类，不会持有外部引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class A&#123;</span><br><span class="line"><span class="keyword">static</span> B&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">B b = <span class="keyword">new</span> A.B();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部类可以和成员一样访问外部类的成员。</p><p>匿名内部类对象在访问方法参数，参数需要定义为final，因为在方法中一旦一开，参数的生命周期也就结束了，但是匿名内部类对象还引用着，通过使用final来拷贝一份使用，间接的延长了生命周期，也就可以正常访问了。</p><h5 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h5><ul><li>强引用 只要持有强引用，JVM宁可抛出内存泄漏也不愿意去回收</li><li>软引用 在没有强引用的情况下且内存不足情况下会去回收对象</li><li>弱引用 在没有强引用的情况下回去回收对象</li><li>虚引用 形同虚设，常用于jvm内部跟踪垃圾回收过程</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你好, Hexo</title>
      <link href="/2019/06/29/%E4%BD%A0%E5%A5%BD-Hexo/"/>
      <url>/2019/06/29/%E4%BD%A0%E5%A5%BD-Hexo/</url>
      
        <content type="html"><![CDATA[<h3 id="你好，Hexo"><a href="#你好，Hexo" class="headerlink" title="你好，Hexo"></a>你好，Hexo</h3><h4 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h4><p>首先用hexo搭建博客还是蛮爽的，基本只需要配置加上写md文件即可，颜值高的我都想学前端了2333。最近我是想着准备找新工作了，但是呢，得复习知识，而我基本上又不怎么喜欢归纳知识，即使是归纳也只用印象笔记做做速记，所以我感觉自己很虚，太浮躁了。但是看别人得博客，他们怎么能写这么多呀！于是我觉得我得认真对待做笔记这件事了，写的博客不能像以前写速记似的。</p><p>抛开关于工作学习上事情，其实用博客来记录生活也很必要。</p><a id="more"></a><p>第一、我表达能力不过关，有时候后脑子可以想很多话语，但是落实到口头综合起来就不是一回事了，想法千奇百怪，转瞬即逝，综合到嘴巴说出来的就更少了。究其原因是我的语文水平驾驭不住这些意识，呃呃（比如现在2333），也就是俗称的看书看少了，写东西写少了。对于文字掌控能力，我感觉是其它很多技能的基础，所以咯，得做！</p><p>第二、 记忆对抗，现在我闭上眼睛，一周平平淡淡，竟然回忆不到太多事情，随着时间的推移，能留在我记忆中东西更是少之又少，甚至我得拼命回忆才能回想到曾今得同学以及生活得情。尽可能得通过博客来记录生活的轨迹。我不想过的虚无缥缈。</p><p>第三、写博客，是一次和自己对话的机会，试问有多久没有静下心来和自己对话了（其实就是反省2333）。</p><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><ul><li>坚持写</li><li>认真总结并写出技术类文章 （虽然目前写的东西是真的水，我会改善的！！）</li><li>有什么想法以及能记录一定要记录</li><li>待完善。。。</li></ul><p>明明在路上的时候还想了待会要写啥的，结果呃呃，这个字数和水平还不到一篇作文。shit，看吧，有多重要了。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
